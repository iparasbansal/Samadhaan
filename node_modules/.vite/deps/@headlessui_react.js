import { __commonJS, __toESM } from "./chunk-DbKvDyjX.js";
import { require_react } from "./react-CaBbP8XX.js";
import { require_react_dom } from "./react-dom-C4HG9ENh.js";

//#region node_modules/@react-aria/utils/dist/useLayoutEffect.mjs
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
var $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== "undefined" ? import_react.useLayoutEffect : () => {};

//#endregion
//#region node_modules/@react-aria/utils/dist/useEffectEvent.mjs
var $8ae05eaa5c114e9c$var$_React_useInsertionEffect;
var $8ae05eaa5c114e9c$var$useEarlyEffect = ($8ae05eaa5c114e9c$var$_React_useInsertionEffect = import_react.useInsertionEffect) !== null && $8ae05eaa5c114e9c$var$_React_useInsertionEffect !== void 0 ? $8ae05eaa5c114e9c$var$_React_useInsertionEffect : $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c;
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {
	const ref = (0, import_react.useRef)(null);
	$8ae05eaa5c114e9c$var$useEarlyEffect(() => {
		ref.current = fn;
	}, [fn]);
	return (0, import_react.useCallback)((...args) => {
		const f$21 = ref.current;
		return f$21 === null || f$21 === void 0 ? void 0 : f$21(...args);
	}, []);
}

//#endregion
//#region node_modules/@react-aria/utils/dist/domHelpers.mjs
var $431fbd86ca7dc216$export$b204af158042fbac = (el) => {
	var _el_ownerDocument;
	return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
};
var $431fbd86ca7dc216$export$f21a1ffae260145a = (el) => {
	if (el && "window" in el && el.window === el) return el;
	return $431fbd86ca7dc216$export$b204af158042fbac(el).defaultView || window;
};
/**
* Type guard that checks if a value is a Node. Verifies the presence and type of the nodeType property.
*/ function $431fbd86ca7dc216$var$isNode(value) {
	return value !== null && typeof value === "object" && "nodeType" in value && typeof value.nodeType === "number";
}
function $431fbd86ca7dc216$export$af51f0f06c0f328a(node) {
	return $431fbd86ca7dc216$var$isNode(node) && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in node;
}

//#endregion
//#region node_modules/@react-stately/flags/dist/import.mjs
var $f4e2df6bd15f8569$var$_shadowDOM = false;
function $f4e2df6bd15f8569$export$98658e8c59125e6a() {
	return $f4e2df6bd15f8569$var$_shadowDOM;
}

//#endregion
//#region node_modules/@react-aria/utils/dist/DOMFunctions.mjs
function $d4ee10de306f2510$export$4282f70798064fe0(node, otherNode) {
	if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return otherNode && node ? node.contains(otherNode) : false;
	if (!node || !otherNode) return false;
	let currentNode = otherNode;
	while (currentNode !== null) {
		if (currentNode === node) return true;
		if (currentNode.tagName === "SLOT" && currentNode.assignedSlot) currentNode = currentNode.assignedSlot.parentNode;
		else if ($431fbd86ca7dc216$export$af51f0f06c0f328a(currentNode)) currentNode = currentNode.host;
		else currentNode = currentNode.parentNode;
	}
	return false;
}
var $d4ee10de306f2510$export$cd4e5573fbe2b576 = (doc = document) => {
	var _activeElement_shadowRoot;
	if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return doc.activeElement;
	let activeElement$1 = doc.activeElement;
	while (activeElement$1 && "shadowRoot" in activeElement$1 && ((_activeElement_shadowRoot = activeElement$1.shadowRoot) === null || _activeElement_shadowRoot === void 0 ? void 0 : _activeElement_shadowRoot.activeElement)) activeElement$1 = activeElement$1.shadowRoot.activeElement;
	return activeElement$1;
};
function $d4ee10de306f2510$export$e58f029f0fbfdb29(event) {
	if ($f4e2df6bd15f8569$export$98658e8c59125e6a() && event.target.shadowRoot) {
		if (event.composedPath) return event.composedPath()[0];
	}
	return event.target;
}

//#endregion
//#region node_modules/@react-aria/utils/dist/platform.mjs
function $c87311424ea30a05$var$testUserAgent(re$4) {
	var _window_navigator_userAgentData;
	if (typeof window === "undefined" || window.navigator == null) return false;
	let brands = (_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands;
	return Array.isArray(brands) && brands.some((brand) => re$4.test(brand.brand)) || re$4.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re$4) {
	var _window_navigator_userAgentData;
	return typeof window !== "undefined" && window.navigator != null ? re$4.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$var$cached(fn) {
	let res = null;
	return () => {
		if (res == null) res = fn();
		return res;
	};
}
var $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
	return $c87311424ea30a05$var$testPlatform(/^Mac/i);
});
var $c87311424ea30a05$export$186c6964ca17d99 = $c87311424ea30a05$var$cached(function() {
	return $c87311424ea30a05$var$testPlatform(/^iPhone/i);
});
var $c87311424ea30a05$export$7bef049ce92e4224 = $c87311424ea30a05$var$cached(function() {
	return $c87311424ea30a05$var$testPlatform(/^iPad/i) || $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
});
var $c87311424ea30a05$export$fedb369cb70207f1 = $c87311424ea30a05$var$cached(function() {
	return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();
});
var $c87311424ea30a05$export$e1865c3bedcd822b = $c87311424ea30a05$var$cached(function() {
	return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();
});
var $c87311424ea30a05$export$78551043582a6a98 = $c87311424ea30a05$var$cached(function() {
	return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();
});
var $c87311424ea30a05$export$6446a186d09e379e = $c87311424ea30a05$var$cached(function() {
	return $c87311424ea30a05$var$testUserAgent(/Chrome/i);
});
var $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
	return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
var $c87311424ea30a05$export$b7d78993b74f766d = $c87311424ea30a05$var$cached(function() {
	return $c87311424ea30a05$var$testUserAgent(/Firefox/i);
});

//#endregion
//#region node_modules/@react-aria/utils/dist/useGlobalListeners.mjs
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
	let globalListeners = (0, import_react.useRef)(/* @__PURE__ */ new Map());
	let addGlobalListener = (0, import_react.useCallback)((eventTarget, type, listener, options) => {
		let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args) => {
			globalListeners.current.delete(listener);
			listener(...args);
		} : listener;
		globalListeners.current.set(listener, {
			type,
			eventTarget,
			fn,
			options
		});
		eventTarget.addEventListener(type, fn, options);
	}, []);
	let removeGlobalListener = (0, import_react.useCallback)((eventTarget, type, listener, options) => {
		var _globalListeners_current_get;
		let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
		eventTarget.removeEventListener(type, fn, options);
		globalListeners.current.delete(listener);
	}, []);
	let removeAllGlobalListeners = (0, import_react.useCallback)(() => {
		globalListeners.current.forEach((value, key) => {
			removeGlobalListener(value.eventTarget, value.type, key, value.options);
		});
	}, [removeGlobalListener]);
	(0, import_react.useEffect)(() => {
		return removeAllGlobalListeners;
	}, [removeAllGlobalListeners]);
	return {
		addGlobalListener,
		removeGlobalListener,
		removeAllGlobalListeners
	};
}

//#endregion
//#region node_modules/@react-aria/utils/dist/isVirtualEvent.mjs
function $6a7db85432448f7f$export$60278871457622de(event) {
	if (event.pointerType === "" && event.isTrusted) return true;
	if ($c87311424ea30a05$export$a11b0059900ceec8() && event.pointerType) return event.type === "click" && event.buttons === 1;
	return event.detail === 0 && !event.pointerType;
}

//#endregion
//#region node_modules/@react-aria/interactions/dist/utils.mjs
function $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent) {
	let event = nativeEvent;
	event.nativeEvent = nativeEvent;
	event.isDefaultPrevented = () => event.defaultPrevented;
	event.isPropagationStopped = () => event.cancelBubble;
	event.persist = () => {};
	return event;
}
function $8a9cb279dc87e130$export$c2b7abe5d61ec696(event, target) {
	Object.defineProperty(event, "target", { value: target });
	Object.defineProperty(event, "currentTarget", { value: target });
}
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
	let stateRef = (0, import_react.useRef)({
		isFocused: false,
		observer: null
	});
	$f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
		const state = stateRef.current;
		return () => {
			if (state.observer) {
				state.observer.disconnect();
				state.observer = null;
			}
		};
	}, []);
	let dispatchBlur = $8ae05eaa5c114e9c$export$7f54fc3180508a52((e$8) => {
		onBlur === null || onBlur === void 0 || onBlur(e$8);
	});
	return (0, import_react.useCallback)((e$8) => {
		if (e$8.target instanceof HTMLButtonElement || e$8.target instanceof HTMLInputElement || e$8.target instanceof HTMLTextAreaElement || e$8.target instanceof HTMLSelectElement) {
			stateRef.current.isFocused = true;
			let target = e$8.target;
			let onBlurHandler = (e$9) => {
				stateRef.current.isFocused = false;
				if (target.disabled) {
					let event = $8a9cb279dc87e130$export$525bc4921d56d4a(e$9);
					dispatchBlur(event);
				}
				if (stateRef.current.observer) {
					stateRef.current.observer.disconnect();
					stateRef.current.observer = null;
				}
			};
			target.addEventListener("focusout", onBlurHandler, { once: true });
			stateRef.current.observer = new MutationObserver(() => {
				if (stateRef.current.isFocused && target.disabled) {
					var _stateRef_current_observer;
					(_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 || _stateRef_current_observer.disconnect();
					let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
					target.dispatchEvent(new FocusEvent("blur", { relatedTarget: relatedTargetEl }));
					target.dispatchEvent(new FocusEvent("focusout", {
						bubbles: true,
						relatedTarget: relatedTargetEl
					}));
				}
			});
			stateRef.current.observer.observe(target, {
				attributes: true,
				attributeFilter: ["disabled"]
			});
		}
	}, [dispatchBlur]);
}
var $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;

//#endregion
//#region node_modules/@react-aria/interactions/dist/useFocusVisible.mjs
var $507fabe10e71c6fb$var$currentModality = null;
var $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set();
var $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map();
var $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
var $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
var $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
	Tab: true,
	Escape: true
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e$8) {
	for (let handler of $507fabe10e71c6fb$var$changeHandlers) handler(modality, e$8);
}
/**
* Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
*/ function $507fabe10e71c6fb$var$isValidKey(e$8) {
	return !(e$8.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && e$8.altKey || e$8.ctrlKey || e$8.key === "Control" || e$8.key === "Shift" || e$8.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e$8) {
	$507fabe10e71c6fb$var$hasEventBeforeFocus = true;
	if ($507fabe10e71c6fb$var$isValidKey(e$8)) {
		$507fabe10e71c6fb$var$currentModality = "keyboard";
		$507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e$8);
	}
}
function $507fabe10e71c6fb$var$handlePointerEvent(e$8) {
	$507fabe10e71c6fb$var$currentModality = "pointer";
	if (e$8.type === "mousedown" || e$8.type === "pointerdown") {
		$507fabe10e71c6fb$var$hasEventBeforeFocus = true;
		$507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e$8);
	}
}
function $507fabe10e71c6fb$var$handleClickEvent(e$8) {
	if ($6a7db85432448f7f$export$60278871457622de(e$8)) {
		$507fabe10e71c6fb$var$hasEventBeforeFocus = true;
		$507fabe10e71c6fb$var$currentModality = "virtual";
	}
}
function $507fabe10e71c6fb$var$handleFocusEvent(e$8) {
	if (e$8.target === window || e$8.target === document || $8a9cb279dc87e130$export$fda7da73ab5d4c48 || !e$8.isTrusted) return;
	if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {
		$507fabe10e71c6fb$var$currentModality = "virtual";
		$507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e$8);
	}
	$507fabe10e71c6fb$var$hasEventBeforeFocus = false;
	$507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
	if ($8a9cb279dc87e130$export$fda7da73ab5d4c48) return;
	$507fabe10e71c6fb$var$hasEventBeforeFocus = false;
	$507fabe10e71c6fb$var$hasBlurredWindowRecently = true;
}
/**
* Setup global event listeners to control when keyboard focus style should be visible.
*/ function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {
	if (typeof window === "undefined" || typeof document === "undefined" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(element))) return;
	const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element);
	const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
	let focus = windowObject.HTMLElement.prototype.focus;
	windowObject.HTMLElement.prototype.focus = function() {
		$507fabe10e71c6fb$var$hasEventBeforeFocus = true;
		focus.apply(this, arguments);
	};
	documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
	documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
	documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
	windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
	windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
	if (typeof PointerEvent !== "undefined") {
		documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
		documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
		documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
	}
	windowObject.addEventListener("beforeunload", () => {
		$507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);
	}, { once: true });
	$507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, { focus });
}
var $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {
	const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element);
	const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
	if (loadListener) documentObject.removeEventListener("DOMContentLoaded", loadListener);
	if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;
	windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;
	documentObject.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
	documentObject.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
	documentObject.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
	windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
	windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
	if (typeof PointerEvent !== "undefined") {
		documentObject.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
		documentObject.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
		documentObject.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
	}
	$507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element) {
	const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
	let loadListener;
	if (documentObject.readyState !== "loading") $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
	else {
		loadListener = () => {
			$507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
		};
		documentObject.addEventListener("DOMContentLoaded", loadListener);
	}
	return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);
}
if (typeof document !== "undefined") $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
	return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
var $507fabe10e71c6fb$var$nonTextInputTypes = new Set([
	"checkbox",
	"radio",
	"range",
	"color",
	"file",
	"image",
	"button",
	"submit",
	"reset"
]);
/**
* If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
* focus visible style can be properly set.
*/ function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e$8) {
	let document1 = $431fbd86ca7dc216$export$b204af158042fbac(e$8 === null || e$8 === void 0 ? void 0 : e$8.target);
	const IHTMLInputElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e$8 === null || e$8 === void 0 ? void 0 : e$8.target).HTMLInputElement : HTMLInputElement;
	const IHTMLTextAreaElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e$8 === null || e$8 === void 0 ? void 0 : e$8.target).HTMLTextAreaElement : HTMLTextAreaElement;
	const IHTMLElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e$8 === null || e$8 === void 0 ? void 0 : e$8.target).HTMLElement : HTMLElement;
	const IKeyboardEvent = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e$8 === null || e$8 === void 0 ? void 0 : e$8.target).KeyboardEvent : KeyboardEvent;
	isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable;
	return !(isTextInput && modality === "keyboard" && e$8 instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e$8.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {
	$507fabe10e71c6fb$var$setupGlobalFocusEvents();
	(0, import_react.useEffect)(() => {
		let handler = (modality, e$8) => {
			if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e$8)) return;
			fn($507fabe10e71c6fb$export$b9b3dfddab17db27());
		};
		$507fabe10e71c6fb$var$changeHandlers.add(handler);
		return () => {
			$507fabe10e71c6fb$var$changeHandlers.delete(handler);
		};
	}, deps);
}

//#endregion
//#region node_modules/@react-aria/interactions/dist/useFocus.mjs
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
	let { isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;
	const onBlur = (0, import_react.useCallback)((e$8) => {
		if (e$8.target === e$8.currentTarget) {
			if (onBlurProp) onBlurProp(e$8);
			if (onFocusChange) onFocusChange(false);
			return true;
		}
	}, [onBlurProp, onFocusChange]);
	const onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);
	const onFocus = (0, import_react.useCallback)((e$8) => {
		const ownerDocument = $431fbd86ca7dc216$export$b204af158042fbac(e$8.target);
		const activeElement$1 = ownerDocument ? $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument) : $d4ee10de306f2510$export$cd4e5573fbe2b576();
		if (e$8.target === e$8.currentTarget && activeElement$1 === $d4ee10de306f2510$export$e58f029f0fbfdb29(e$8.nativeEvent)) {
			if (onFocusProp) onFocusProp(e$8);
			if (onFocusChange) onFocusChange(true);
			onSyntheticFocus(e$8);
		}
	}, [
		onFocusChange,
		onFocusProp,
		onSyntheticFocus
	]);
	return { focusProps: {
		onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,
		onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : void 0
	} };
}

//#endregion
//#region node_modules/@react-aria/interactions/dist/useFocusWithin.mjs
function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
	let { isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange } = props;
	let state = (0, import_react.useRef)({ isFocusWithin: false });
	let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6();
	let onBlur = (0, import_react.useCallback)((e$8) => {
		if (!e$8.currentTarget.contains(e$8.target)) return;
		if (state.current.isFocusWithin && !e$8.currentTarget.contains(e$8.relatedTarget)) {
			state.current.isFocusWithin = false;
			removeAllGlobalListeners();
			if (onBlurWithin) onBlurWithin(e$8);
			if (onFocusWithinChange) onFocusWithinChange(false);
		}
	}, [
		onBlurWithin,
		onFocusWithinChange,
		state,
		removeAllGlobalListeners
	]);
	let onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);
	let onFocus = (0, import_react.useCallback)((e$8) => {
		if (!e$8.currentTarget.contains(e$8.target)) return;
		const ownerDocument = $431fbd86ca7dc216$export$b204af158042fbac(e$8.target);
		const activeElement$1 = $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument);
		if (!state.current.isFocusWithin && activeElement$1 === $d4ee10de306f2510$export$e58f029f0fbfdb29(e$8.nativeEvent)) {
			if (onFocusWithin) onFocusWithin(e$8);
			if (onFocusWithinChange) onFocusWithinChange(true);
			state.current.isFocusWithin = true;
			onSyntheticFocus(e$8);
			let currentTarget = e$8.currentTarget;
			addGlobalListener(ownerDocument, "focus", (e$9) => {
				if (state.current.isFocusWithin && !$d4ee10de306f2510$export$4282f70798064fe0(currentTarget, e$9.target)) {
					let nativeEvent = new ownerDocument.defaultView.FocusEvent("blur", { relatedTarget: e$9.target });
					$8a9cb279dc87e130$export$c2b7abe5d61ec696(nativeEvent, currentTarget);
					let event = $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent);
					onBlur(event);
				}
			}, { capture: true });
		}
	}, [
		onFocusWithin,
		onFocusWithinChange,
		onSyntheticFocus,
		addGlobalListener,
		onBlur
	]);
	if (isDisabled) return { focusWithinProps: {
		onFocus: void 0,
		onBlur: void 0
	} };
	return { focusWithinProps: {
		onFocus,
		onBlur
	} };
}

//#endregion
//#region node_modules/@react-aria/interactions/dist/useHover.mjs
var $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
var $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
	$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;
	setTimeout(() => {
		$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
	}, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e$8) {
	if (e$8.pointerType === "touch") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
	if (typeof document === "undefined") return;
	if ($6179b936705e76d3$var$hoverCount === 0) {
		if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
	}
	$6179b936705e76d3$var$hoverCount++;
	return () => {
		$6179b936705e76d3$var$hoverCount--;
		if ($6179b936705e76d3$var$hoverCount > 0) return;
		if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
	};
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
	let { onHoverStart, onHoverChange, onHoverEnd, isDisabled } = props;
	let [isHovered, setHovered] = (0, import_react.useState)(false);
	let state = (0, import_react.useRef)({
		isHovered: false,
		ignoreEmulatedMouseEvents: false,
		pointerType: "",
		target: null
	}).current;
	(0, import_react.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);
	let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6();
	let { hoverProps, triggerHoverEnd } = (0, import_react.useMemo)(() => {
		let triggerHoverStart = (event, pointerType) => {
			state.pointerType = pointerType;
			if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
			state.isHovered = true;
			let target = event.currentTarget;
			state.target = target;
			addGlobalListener($431fbd86ca7dc216$export$b204af158042fbac(event.target), "pointerover", (e$8) => {
				if (state.isHovered && state.target && !$d4ee10de306f2510$export$4282f70798064fe0(state.target, e$8.target)) triggerHoverEnd$1(e$8, e$8.pointerType);
			}, { capture: true });
			if (onHoverStart) onHoverStart({
				type: "hoverstart",
				target,
				pointerType
			});
			if (onHoverChange) onHoverChange(true);
			setHovered(true);
		};
		let triggerHoverEnd$1 = (event, pointerType) => {
			let target = state.target;
			state.pointerType = "";
			state.target = null;
			if (pointerType === "touch" || !state.isHovered || !target) return;
			state.isHovered = false;
			removeAllGlobalListeners();
			if (onHoverEnd) onHoverEnd({
				type: "hoverend",
				target,
				pointerType
			});
			if (onHoverChange) onHoverChange(false);
			setHovered(false);
		};
		let hoverProps$1 = {};
		if (typeof PointerEvent !== "undefined") {
			hoverProps$1.onPointerEnter = (e$8) => {
				if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e$8.pointerType === "mouse") return;
				triggerHoverStart(e$8, e$8.pointerType);
			};
			hoverProps$1.onPointerLeave = (e$8) => {
				if (!isDisabled && e$8.currentTarget.contains(e$8.target)) triggerHoverEnd$1(e$8, e$8.pointerType);
			};
		}
		return {
			hoverProps: hoverProps$1,
			triggerHoverEnd: triggerHoverEnd$1
		};
	}, [
		onHoverStart,
		onHoverChange,
		onHoverEnd,
		isDisabled,
		state,
		addGlobalListener,
		removeAllGlobalListeners
	]);
	(0, import_react.useEffect)(() => {
		if (isDisabled) triggerHoverEnd({ currentTarget: state.target }, state.pointerType);
	}, [isDisabled]);
	return {
		hoverProps,
		isHovered
	};
}

//#endregion
//#region node_modules/@react-aria/focus/dist/useFocusRing.mjs
function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
	let { autoFocus = false, isTextInput, within } = props;
	let state = (0, import_react.useRef)({
		isFocused: false,
		isFocusVisible: autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27()
	});
	let [isFocused, setFocused] = (0, import_react.useState)(false);
	let [isFocusVisibleState, setFocusVisible] = (0, import_react.useState)(() => state.current.isFocused && state.current.isFocusVisible);
	let updateState = (0, import_react.useCallback)(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
	let onFocusChange = (0, import_react.useCallback)((isFocused$1) => {
		state.current.isFocused = isFocused$1;
		setFocused(isFocused$1);
		updateState();
	}, [updateState]);
	$507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible) => {
		state.current.isFocusVisible = isFocusVisible;
		updateState();
	}, [], { isTextInput });
	let { focusProps } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
		isDisabled: within,
		onFocusChange
	});
	let { focusWithinProps } = $9ab94262bd0047c7$export$420e68273165f4ec({
		isDisabled: !within,
		onFocusWithinChange: onFocusChange
	});
	return {
		isFocused,
		isFocusVisible: isFocusVisibleState,
		focusProps: within ? focusWithinProps : focusProps
	};
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/env.js
var i$14 = Object.defineProperty;
var d$12 = (t$12, e$8, n$16) => e$8 in t$12 ? i$14(t$12, e$8, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: n$16
}) : t$12[e$8] = n$16;
var r$19 = (t$12, e$8, n$16) => (d$12(t$12, typeof e$8 != "symbol" ? e$8 + "" : e$8, n$16), n$16);
var o$18 = class {
	constructor() {
		r$19(this, "current", this.detect());
		r$19(this, "handoffState", "pending");
		r$19(this, "currentId", 0);
	}
	set(e$8) {
		this.current !== e$8 && (this.handoffState = "pending", this.currentId = 0, this.current = e$8);
	}
	reset() {
		this.set(this.detect());
	}
	nextId() {
		return ++this.currentId;
	}
	get isServer() {
		return this.current === "server";
	}
	get isClient() {
		return this.current === "client";
	}
	detect() {
		return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
	}
	handoff() {
		this.handoffState === "pending" && (this.handoffState = "complete");
	}
	get isHandoffComplete() {
		return this.handoffState === "complete";
	}
};
var s$10 = new o$18();

//#endregion
//#region node_modules/@headlessui/react/dist/utils/owner.js
function l$1(n$16) {
	var u$24;
	return s$10.isServer ? null : n$16 == null ? document : (u$24 = n$16 == null ? void 0 : n$16.ownerDocument) != null ? u$24 : document;
}
function r(n$16) {
	var u$24, o$19;
	return s$10.isServer ? null : n$16 == null ? document : (o$19 = (u$24 = n$16 == null ? void 0 : n$16.getRootNode) == null ? void 0 : u$24.call(n$16)) != null ? o$19 : document;
}
function e$1(n$16) {
	var u$24, o$19;
	return (o$19 = (u$24 = r(n$16)) == null ? void 0 : u$24.activeElement) != null ? o$19 : null;
}
function d$1(n$16) {
	return e$1(n$16) === n$16;
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/micro-task.js
function t(e$8) {
	typeof queueMicrotask == "function" ? queueMicrotask(e$8) : Promise.resolve().then(e$8).catch((o$19) => setTimeout(() => {
		throw o$19;
	}));
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/disposables.js
function o$2() {
	let s$19 = [], r$20 = {
		addEventListener(e$8, t$12, n$16, i$15) {
			return e$8.addEventListener(t$12, n$16, i$15), r$20.add(() => e$8.removeEventListener(t$12, n$16, i$15));
		},
		requestAnimationFrame(...e$8) {
			let t$12 = requestAnimationFrame(...e$8);
			return r$20.add(() => cancelAnimationFrame(t$12));
		},
		nextFrame(...e$8) {
			return r$20.requestAnimationFrame(() => r$20.requestAnimationFrame(...e$8));
		},
		setTimeout(...e$8) {
			let t$12 = setTimeout(...e$8);
			return r$20.add(() => clearTimeout(t$12));
		},
		microTask(...e$8) {
			let t$12 = { current: !0 };
			return t(() => {
				t$12.current && e$8[0]();
			}), r$20.add(() => {
				t$12.current = !1;
			});
		},
		style(e$8, t$12, n$16) {
			let i$15 = e$8.style.getPropertyValue(t$12);
			return Object.assign(e$8.style, { [t$12]: n$16 }), this.add(() => {
				Object.assign(e$8.style, { [t$12]: i$15 });
			});
		},
		group(e$8) {
			let t$12 = o$2();
			return e$8(t$12), this.add(() => t$12.dispose());
		},
		add(e$8) {
			return s$19.includes(e$8) || s$19.push(e$8), () => {
				let t$12 = s$19.indexOf(e$8);
				if (t$12 >= 0) for (let n$16 of s$19.splice(t$12, 1)) n$16();
			};
		},
		dispose() {
			for (let e$8 of s$19.splice(0)) e$8();
		}
	};
	return r$20;
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-disposables.js
function p() {
	let [e$8] = (0, import_react.useState)(o$2);
	return (0, import_react.useEffect)(() => () => e$8.dispose(), [e$8]), e$8;
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var n$1 = (e$8, t$12) => {
	s$10.isServer ? (0, import_react.useEffect)(e$8, t$12) : (0, import_react.useLayoutEffect)(e$8, t$12);
};

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-latest-value.js
function s(e$8) {
	let r$20 = (0, import_react.useRef)(e$8);
	return n$1(() => {
		r$20.current = e$8;
	}, [e$8]), r$20;
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-event.js
var o = function(t$12) {
	let e$8 = s(t$12);
	return import_react.useCallback((...r$20) => e$8.current(...r$20), [e$8]);
};

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-active-press.js
function E$12(e$8) {
	let t$12 = e$8.width / 2, n$16 = e$8.height / 2;
	return {
		top: e$8.clientY - n$16,
		right: e$8.clientX + t$12,
		bottom: e$8.clientY + n$16,
		left: e$8.clientX - t$12
	};
}
function P$6(e$8, t$12) {
	return !(!e$8 || !t$12 || e$8.right < t$12.left || e$8.left > t$12.right || e$8.bottom < t$12.top || e$8.top > t$12.bottom);
}
function w$1({ disabled: e$8 = !1 } = {}) {
	let t$12 = (0, import_react.useRef)(null), [n$16, l$17] = (0, import_react.useState)(!1), r$20 = p(), o$19 = o(() => {
		t$12.current = null, l$17(!1), r$20.dispose();
	}), f$21 = o((s$19) => {
		if (r$20.dispose(), t$12.current === null) {
			t$12.current = s$19.currentTarget, l$17(!0);
			{
				let i$15 = l$1(s$19.currentTarget);
				r$20.addEventListener(i$15, "pointerup", o$19, !1), r$20.addEventListener(i$15, "pointermove", (c$20) => {
					if (t$12.current) {
						let p$12 = E$12(c$20);
						l$17(P$6(p$12, t$12.current.getBoundingClientRect()));
					}
				}, !1), r$20.addEventListener(i$15, "pointercancel", o$19, !1);
			}
		}
	});
	return {
		pressed: n$16,
		pressProps: e$8 ? {} : {
			onPointerDown: f$21,
			onPointerUp: o$19,
			onClick: o$19
		}
	};
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-slot.js
function n(e$8) {
	return (0, import_react.useMemo)(() => e$8, Object.values(e$8));
}

//#endregion
//#region node_modules/@headlessui/react/dist/internal/disabled.js
var e$7 = (0, import_react.createContext)(void 0);
function a() {
	return (0, import_react.useContext)(e$7);
}
function l$3({ value: t$12, children: o$19 }) {
	return import_react.createElement(e$7.Provider, { value: t$12 }, o$19);
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/class-names.js
function t$3(...r$20) {
	return Array.from(new Set(r$20.flatMap((n$16) => typeof n$16 == "string" ? n$16.split(" ") : []))).filter(Boolean).join(" ");
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/match.js
function u$2(r$20, n$16, ...a$27) {
	if (r$20 in n$16) {
		let e$8 = n$16[r$20];
		return typeof e$8 == "function" ? e$8(...a$27) : e$8;
	}
	let t$12 = /* @__PURE__ */ new Error(`Tried to handle "${r$20}" but there is no handler defined. Only defined handlers are: ${Object.keys(n$16).map((e$8) => `"${e$8}"`).join(", ")}.`);
	throw Error.captureStackTrace && Error.captureStackTrace(t$12, u$2), t$12;
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/render.js
var A$1 = ((a$27) => (a$27[a$27.None = 0] = "None", a$27[a$27.RenderStrategy = 1] = "RenderStrategy", a$27[a$27.Static = 2] = "Static", a$27))(A$1 || {}), C$5 = ((e$8) => (e$8[e$8.Unmount = 0] = "Unmount", e$8[e$8.Hidden = 1] = "Hidden", e$8))(C$5 || {});
function K() {
	let n$16 = $$4();
	return (0, import_react.useCallback)((r$20) => U$1({
		mergeRefs: n$16,
		...r$20
	}), [n$16]);
}
function U$1({ ourProps: n$16, theirProps: r$20, slot: e$8, defaultTag: a$27, features: s$19, visible: t$12 = !0, name: l$17, mergeRefs: i$15 }) {
	i$15 = i$15 != null ? i$15 : I$8;
	let o$19 = P$5(r$20, n$16);
	if (t$12) return F$5(o$19, e$8, a$27, l$17, i$15);
	let y$9 = s$19 != null ? s$19 : 0;
	if (y$9 & 2) {
		let { static: f$21 = !1,...u$24 } = o$19;
		if (f$21) return F$5(u$24, e$8, a$27, l$17, i$15);
	}
	if (y$9 & 1) {
		let { unmount: f$21 = !0,...u$24 } = o$19;
		return u$2(f$21 ? 0 : 1, {
			[0]() {
				return null;
			},
			[1]() {
				return F$5({
					...u$24,
					hidden: !0,
					style: { display: "none" }
				}, e$8, a$27, l$17, i$15);
			}
		});
	}
	return F$5(o$19, e$8, a$27, l$17, i$15);
}
function F$5(n$16, r$20 = {}, e$8, a$27, s$19) {
	let { as: t$12 = e$8, children: l$17, refName: i$15 = "ref",...o$19 } = h$13(n$16, ["unmount", "static"]), y$9 = n$16.ref !== void 0 ? { [i$15]: n$16.ref } : {}, f$21 = typeof l$17 == "function" ? l$17(r$20) : l$17;
	"className" in o$19 && o$19.className && typeof o$19.className == "function" && (o$19.className = o$19.className(r$20)), o$19["aria-labelledby"] && o$19["aria-labelledby"] === o$19.id && (o$19["aria-labelledby"] = void 0);
	let u$24 = {};
	if (r$20) {
		let d$13 = !1, p$12 = [];
		for (let [c$20, T$9] of Object.entries(r$20)) typeof T$9 == "boolean" && (d$13 = !0), T$9 === !0 && p$12.push(c$20.replace(/([A-Z])/g, (g$8) => `-${g$8.toLowerCase()}`));
		if (d$13) {
			u$24["data-headlessui-state"] = p$12.join(" ");
			for (let c$20 of p$12) u$24[`data-${c$20}`] = "";
		}
	}
	if (b$5(t$12) && (Object.keys(m(o$19)).length > 0 || Object.keys(m(u$24)).length > 0)) if (!(0, import_react.isValidElement)(f$21) || Array.isArray(f$21) && f$21.length > 1 || D$10(f$21)) {
		if (Object.keys(m(o$19)).length > 0) throw new Error([
			"Passing props on \"Fragment\"!",
			"",
			`The current component <${a$27} /> is rendering a "Fragment".`,
			"However we need to passthrough the following props:",
			Object.keys(m(o$19)).concat(Object.keys(m(u$24))).map((d$13) => `  - ${d$13}`).join(`
`),
			"",
			"You can apply a few solutions:",
			["Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".", "Render a single element as the child so that we can forward the props onto that element."].map((d$13) => `  - ${d$13}`).join(`
`)
		].join(`
`));
	} else {
		let d$13 = f$21.props, p$12 = d$13 == null ? void 0 : d$13.className, c$20 = typeof p$12 == "function" ? (...R$6) => t$3(p$12(...R$6), o$19.className) : t$3(p$12, o$19.className), T$9 = c$20 ? { className: c$20 } : {}, g$8 = P$5(f$21.props, m(h$13(o$19, ["ref"])));
		for (let R$6 in u$24) R$6 in g$8 && delete u$24[R$6];
		return (0, import_react.cloneElement)(f$21, Object.assign({}, g$8, u$24, y$9, { ref: s$19(H$7(f$21), y$9.ref) }, T$9));
	}
	return (0, import_react.createElement)(t$12, Object.assign({}, h$13(o$19, ["ref"]), !b$5(t$12) && y$9, !b$5(t$12) && u$24), f$21);
}
function $$4() {
	let n$16 = (0, import_react.useRef)([]), r$20 = (0, import_react.useCallback)((e$8) => {
		for (let a$27 of n$16.current) a$27 != null && (typeof a$27 == "function" ? a$27(e$8) : a$27.current = e$8);
	}, []);
	return (...e$8) => {
		if (!e$8.every((a$27) => a$27 == null)) return n$16.current = e$8, r$20;
	};
}
function I$8(...n$16) {
	return n$16.every((r$20) => r$20 == null) ? void 0 : (r$20) => {
		for (let e$8 of n$16) e$8 != null && (typeof e$8 == "function" ? e$8(r$20) : e$8.current = r$20);
	};
}
function P$5(...n$16) {
	if (n$16.length === 0) return {};
	if (n$16.length === 1) return n$16[0];
	let r$20 = {}, e$8 = {};
	for (let s$19 of n$16) for (let t$12 in s$19) t$12.startsWith("on") && typeof s$19[t$12] == "function" ? (e$8[t$12] ?? (e$8[t$12] = []), e$8[t$12].push(s$19[t$12])) : r$20[t$12] = s$19[t$12];
	if (r$20.disabled || r$20["aria-disabled"]) for (let s$19 in e$8) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(s$19) && (e$8[s$19] = [(t$12) => {
		var l$17;
		return (l$17 = t$12 == null ? void 0 : t$12.preventDefault) == null ? void 0 : l$17.call(t$12);
	}]);
	for (let s$19 in e$8) Object.assign(r$20, { [s$19](t$12, ...l$17) {
		let i$15 = e$8[s$19];
		for (let o$19 of i$15) {
			if ((t$12 instanceof Event || (t$12 == null ? void 0 : t$12.nativeEvent) instanceof Event) && t$12.defaultPrevented) return;
			o$19(t$12, ...l$17);
		}
	} });
	return r$20;
}
function V(...n$16) {
	if (n$16.length === 0) return {};
	if (n$16.length === 1) return n$16[0];
	let r$20 = {}, e$8 = {};
	for (let s$19 of n$16) for (let t$12 in s$19) t$12.startsWith("on") && typeof s$19[t$12] == "function" ? (e$8[t$12] ?? (e$8[t$12] = []), e$8[t$12].push(s$19[t$12])) : r$20[t$12] = s$19[t$12];
	for (let s$19 in e$8) Object.assign(r$20, { [s$19](...t$12) {
		let l$17 = e$8[s$19];
		for (let i$15 of l$17) i$15?.(...t$12);
	} });
	return r$20;
}
function Y(n$16) {
	var r$20;
	return Object.assign((0, import_react.forwardRef)(n$16), { displayName: (r$20 = n$16.displayName) != null ? r$20 : n$16.name });
}
function m(n$16) {
	let r$20 = Object.assign({}, n$16);
	for (let e$8 in r$20) r$20[e$8] === void 0 && delete r$20[e$8];
	return r$20;
}
function h$13(n$16, r$20 = []) {
	let e$8 = Object.assign({}, n$16);
	for (let a$27 of r$20) a$27 in e$8 && delete e$8[a$27];
	return e$8;
}
function H$7(n$16) {
	return import_react.version.split(".")[0] >= "19" ? n$16.props.ref : n$16.ref;
}
function b$5(n$16) {
	return n$16 === import_react.Fragment || n$16 === Symbol.for("react.fragment");
}
function D$10(n$16) {
	return b$5(n$16.type);
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/button/button.js
var R$5 = "button";
function v$8(s$19, n$16) {
	var r$20;
	let p$12 = a(), { disabled: e$8 = p$12 || !1, autoFocus: t$12 = !1,...o$19 } = s$19, { isFocusVisible: a$27, focusProps: l$17 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: t$12 }), { isHovered: u$24, hoverProps: i$15 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e$8 }), { pressed: T$9, pressProps: d$13 } = w$1({ disabled: e$8 }), f$21 = V({
		ref: n$16,
		type: (r$20 = o$19.type) != null ? r$20 : "button",
		disabled: e$8 || void 0,
		autoFocus: t$12
	}, l$17, i$15, d$13), m$9 = n({
		disabled: e$8,
		hover: u$24,
		focus: a$27,
		active: T$9,
		autofocus: t$12
	});
	return K()({
		ourProps: f$21,
		theirProps: o$19,
		slot: m$9,
		defaultTag: R$5,
		name: "Button"
	});
}
var L = Y(v$8);

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-controllable.js
var import_react_dom$8 = /* @__PURE__ */ __toESM(require_react_dom(), 1);
function b$2(l$17, r$20, c$20) {
	let [i$15, s$19] = (0, import_react.useState)(c$20), e$8 = l$17 !== void 0, t$12 = (0, import_react.useRef)(e$8), u$24 = (0, import_react.useRef)(!1), d$13 = (0, import_react.useRef)(!1);
	return e$8 && !t$12.current && !u$24.current ? (u$24.current = !0, t$12.current = e$8, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !e$8 && t$12.current && !d$13.current && (d$13.current = !0, t$12.current = e$8, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [e$8 ? l$17 : i$15, o((n$16) => (e$8 || (0, import_react_dom$8.flushSync)(() => s$19(n$16)), r$20 == null ? void 0 : r$20(n$16)))];
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-default-value.js
function l(e$8) {
	let [t$12] = (0, import_react.useState)(e$8);
	return t$12;
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/form.js
function p$11(t$12 = {}, i$15 = null, n$16 = []) {
	for (let [e$8, o$19] of Object.entries(t$12)) s$17(n$16, r$16(i$15, e$8), o$19);
	return n$16;
}
function r$16(t$12, i$15) {
	return t$12 ? t$12 + "[" + i$15 + "]" : i$15;
}
function s$17(t$12, i$15, n$16) {
	if (Array.isArray(n$16)) for (let [e$8, o$19] of n$16.entries()) s$17(t$12, r$16(i$15, e$8.toString()), o$19);
	else n$16 instanceof Date ? t$12.push([i$15, n$16.toISOString()]) : typeof n$16 == "boolean" ? t$12.push([i$15, n$16 ? "1" : "0"]) : typeof n$16 == "string" ? t$12.push([i$15, n$16]) : typeof n$16 == "number" ? t$12.push([i$15, `${n$16}`]) : n$16 == null ? t$12.push([i$15, ""]) : c$18(n$16) && !(0, import_react.isValidElement)(n$16) && p$11(n$16, i$15, t$12);
}
function g(t$12) {
	var n$16, e$8;
	let i$15 = (n$16 = t$12 == null ? void 0 : t$12.form) != null ? n$16 : t$12.closest("form");
	if (i$15) {
		for (let o$19 of i$15.elements) if (o$19 !== t$12 && (o$19.tagName === "INPUT" && o$19.type === "submit" || o$19.tagName === "BUTTON" && o$19.type === "submit" || o$19.nodeName === "INPUT" && o$19.type === "image")) {
			o$19.click();
			return;
		}
		(e$8 = i$15.requestSubmit) == null || e$8.call(i$15);
	}
}
function c$18(t$12) {
	if (Object.prototype.toString.call(t$12) !== "[object Object]") return !1;
	let i$15 = Object.getPrototypeOf(t$12);
	return i$15 === null || Object.getPrototypeOf(i$15) === null;
}

//#endregion
//#region node_modules/@headlessui/react/dist/internal/hidden.js
var a$23 = "span";
var s$3 = ((e$8) => (e$8[e$8.None = 1] = "None", e$8[e$8.Focusable = 2] = "Focusable", e$8[e$8.Hidden = 4] = "Hidden", e$8))(s$3 || {});
function l$16(t$12, r$20) {
	var n$16;
	let { features: d$13 = 1,...e$8 } = t$12, o$19 = {
		ref: r$20,
		"aria-hidden": (d$13 & 2) === 2 ? !0 : (n$16 = e$8["aria-hidden"]) != null ? n$16 : void 0,
		hidden: (d$13 & 4) === 4 ? !0 : void 0,
		style: {
			position: "fixed",
			top: 1,
			left: 1,
			width: 1,
			height: 0,
			padding: 0,
			margin: -1,
			overflow: "hidden",
			clip: "rect(0, 0, 0, 0)",
			whiteSpace: "nowrap",
			borderWidth: "0",
			...(d$13 & 4) === 4 && (d$13 & 2) !== 2 && { display: "none" }
		}
	};
	return K()({
		ourProps: o$19,
		theirProps: e$8,
		slot: {},
		defaultTag: a$23,
		name: "Hidden"
	});
}
var f = Y(l$16);

//#endregion
//#region node_modules/@headlessui/react/dist/internal/form-fields.js
var import_react_dom$7 = /* @__PURE__ */ __toESM(require_react_dom(), 1);
var f$17 = (0, import_react.createContext)(null);
function W$2(t$12) {
	let [e$8, r$20] = (0, import_react.useState)(null);
	return import_react.createElement(f$17.Provider, { value: { target: e$8 } }, t$12.children, import_react.createElement(f, {
		features: s$3.Hidden,
		ref: r$20
	}));
}
function c$17({ children: t$12 }) {
	let e$8 = (0, import_react.useContext)(f$17);
	if (!e$8) return import_react.createElement(import_react.Fragment, null, t$12);
	let { target: r$20 } = e$8;
	return r$20 ? (0, import_react_dom$7.createPortal)(import_react.createElement(import_react.Fragment, null, t$12), r$20) : null;
}
function j({ data: t$12, form: e$8, disabled: r$20, onReset: n$16, overrides: F$6 }) {
	let [i$15, a$27] = (0, import_react.useState)(null), p$12 = p();
	return (0, import_react.useEffect)(() => {
		if (n$16 && i$15) return p$12.addEventListener(i$15, "reset", n$16);
	}, [
		i$15,
		e$8,
		n$16
	]), import_react.createElement(c$17, null, import_react.createElement(C$9, {
		setForm: a$27,
		formId: e$8
	}), p$11(t$12).map(([s$19, v$10]) => import_react.createElement(f, {
		features: s$3.Hidden,
		...m({
			key: s$19,
			as: "input",
			type: "hidden",
			hidden: !0,
			readOnly: !0,
			form: e$8,
			disabled: r$20,
			name: s$19,
			value: v$10,
			...F$6
		})
	})));
}
function C$9({ setForm: t$12, formId: e$8 }) {
	return (0, import_react.useEffect)(() => {
		if (e$8) {
			let r$20 = document.getElementById(e$8);
			r$20 && t$12(r$20);
		}
	}, [t$12, e$8]), e$8 ? null : import_react.createElement(f, {
		features: s$3.Hidden,
		as: "input",
		type: "hidden",
		hidden: !0,
		readOnly: !0,
		ref: (r$20) => {
			if (!r$20) return;
			let n$16 = r$20.closest("form");
			n$16 && t$12(n$16);
		}
	});
}

//#endregion
//#region node_modules/@headlessui/react/dist/internal/id.js
var e$6 = (0, import_react.createContext)(void 0);
function u$1() {
	return (0, import_react.useContext)(e$6);
}
function f$8({ id: t$12, children: r$20 }) {
	return import_react.createElement(e$6.Provider, { value: t$12 }, r$20);
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/dom.js
function o$14(e$8) {
	return typeof e$8 != "object" || e$8 === null ? !1 : "nodeType" in e$8;
}
function t$9(e$8) {
	return o$14(e$8) && "tagName" in e$8;
}
function n$13(e$8) {
	return t$9(e$8) && "accessKey" in e$8;
}
function i$11(e$8) {
	return t$9(e$8) && "tabIndex" in e$8;
}
function r$15(e$8) {
	return t$9(e$8) && "style" in e$8;
}
function u$21(e$8) {
	return n$13(e$8) && e$8.nodeName === "IFRAME";
}
function l$15(e$8) {
	return n$13(e$8) && e$8.nodeName === "INPUT";
}
function m$6(e$8) {
	return n$13(e$8) && e$8.nodeName === "LABEL";
}
function a$22(e$8) {
	return n$13(e$8) && e$8.nodeName === "FIELDSET";
}
function E$9(e$8) {
	return n$13(e$8) && e$8.nodeName === "LEGEND";
}
function L$5(e$8) {
	return t$9(e$8) ? e$8.matches("a[href],audio[controls],button,details,embed,iframe,img[usemap],input:not([type=\"hidden\"]),label,select,textarea,video[controls]") : !1;
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/bugs.js
function s$4(l$17) {
	let e$8 = l$17.parentElement, t$12 = null;
	for (; e$8 && !a$22(e$8);) E$9(e$8) && (t$12 = e$8), e$8 = e$8.parentElement;
	let i$15 = (e$8 == null ? void 0 : e$8.getAttribute("disabled")) === "";
	return i$15 && r$14(t$12) ? !1 : i$15;
}
function r$14(l$17) {
	if (!l$17) return !1;
	let e$8 = l$17.previousElementSibling;
	for (; e$8 !== null;) {
		if (E$9(e$8)) return !1;
		e$8 = e$8.previousElementSibling;
	}
	return !0;
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var u$20 = Symbol();
function T$1(t$12, n$16 = !0) {
	return Object.assign(t$12, { [u$20]: n$16 });
}
function y$1(...t$12) {
	let n$16 = (0, import_react.useRef)(t$12);
	(0, import_react.useEffect)(() => {
		n$16.current = t$12;
	}, [t$12]);
	let c$20 = o((e$8) => {
		for (let o$19 of n$16.current) o$19 != null && (typeof o$19 == "function" ? o$19(e$8) : o$19.current = e$8);
	});
	return t$12.every((e$8) => e$8 == null || (e$8 == null ? void 0 : e$8[u$20])) ? void 0 : c$20;
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/description/description.js
var a$21 = (0, import_react.createContext)(null);
a$21.displayName = "DescriptionContext";
function f$16() {
	let r$20 = (0, import_react.useContext)(a$21);
	if (r$20 === null) {
		let e$8 = /* @__PURE__ */ new Error("You used a <Description /> component, but it is not inside a relevant parent.");
		throw Error.captureStackTrace && Error.captureStackTrace(e$8, f$16), e$8;
	}
	return r$20;
}
function w() {
	var r$20, e$8;
	return (e$8 = (r$20 = (0, import_react.useContext)(a$21)) == null ? void 0 : r$20.value) != null ? e$8 : void 0;
}
function H$1() {
	let [r$20, e$8] = (0, import_react.useState)([]);
	return [r$20.length > 0 ? r$20.join(" ") : void 0, (0, import_react.useMemo)(() => function(t$12) {
		let i$15 = o((n$16) => (e$8((o$19) => [...o$19, n$16]), () => e$8((o$19) => {
			let s$19 = o$19.slice(), p$12 = s$19.indexOf(n$16);
			return p$12 !== -1 && s$19.splice(p$12, 1), s$19;
		}))), l$17 = (0, import_react.useMemo)(() => ({
			register: i$15,
			slot: t$12.slot,
			name: t$12.name,
			props: t$12.props,
			value: t$12.value
		}), [
			i$15,
			t$12.slot,
			t$12.name,
			t$12.props,
			t$12.value
		]);
		return import_react.createElement(a$21.Provider, { value: l$17 }, t$12.children);
	}, [e$8])];
}
var I$7 = "p";
function C$8(r$20, e$8) {
	let c$20 = (0, import_react.useId)(), t$12 = a(), { id: i$15 = `headlessui-description-${c$20}`,...l$17 } = r$20, n$16 = f$16(), o$19 = y$1(e$8);
	n$1(() => n$16.register(i$15), [i$15, n$16.register]);
	let s$19 = n({
		...n$16.slot,
		disabled: t$12 || !1
	}), p$12 = {
		ref: o$19,
		...n$16.props,
		id: i$15
	};
	return K()({
		ourProps: p$12,
		theirProps: l$17,
		slot: s$19,
		defaultTag: I$7,
		name: n$16.name || "Description"
	});
}
var _$9 = Y(C$8), M = Object.assign(_$9, {});

//#endregion
//#region node_modules/@headlessui/react/dist/components/keyboard.js
var o$1 = ((r$20) => (r$20.Space = " ", r$20.Enter = "Enter", r$20.Escape = "Escape", r$20.Backspace = "Backspace", r$20.Delete = "Delete", r$20.ArrowLeft = "ArrowLeft", r$20.ArrowUp = "ArrowUp", r$20.ArrowRight = "ArrowRight", r$20.ArrowDown = "ArrowDown", r$20.Home = "Home", r$20.End = "End", r$20.PageUp = "PageUp", r$20.PageDown = "PageDown", r$20.Tab = "Tab", r$20))(o$1 || {});

//#endregion
//#region node_modules/@headlessui/react/dist/components/label/label.js
var L$4 = (0, import_react.createContext)(null);
L$4.displayName = "LabelContext";
function C$2() {
	let n$16 = (0, import_react.useContext)(L$4);
	if (n$16 === null) {
		let l$17 = /* @__PURE__ */ new Error("You used a <Label /> component, but it is not inside a relevant parent.");
		throw Error.captureStackTrace && Error.captureStackTrace(l$17, C$2), l$17;
	}
	return n$16;
}
function N(n$16) {
	var a$27, e$8, o$19;
	let l$17 = (e$8 = (a$27 = (0, import_react.useContext)(L$4)) == null ? void 0 : a$27.value) != null ? e$8 : void 0;
	return ((o$19 = n$16 == null ? void 0 : n$16.length) != null ? o$19 : 0) > 0 ? [l$17, ...n$16].filter(Boolean).join(" ") : l$17;
}
function V$2({ inherit: n$16 = !1 } = {}) {
	let l$17 = N(), [a$27, e$8] = (0, import_react.useState)([]), o$19 = n$16 ? [l$17, ...a$27].filter(Boolean) : a$27;
	return [o$19.length > 0 ? o$19.join(" ") : void 0, (0, import_react.useMemo)(() => function(t$12) {
		let p$12 = o((i$15) => (e$8((u$24) => [...u$24, i$15]), () => e$8((u$24) => {
			let d$13 = u$24.slice(), f$21 = d$13.indexOf(i$15);
			return f$21 !== -1 && d$13.splice(f$21, 1), d$13;
		}))), b$13 = (0, import_react.useMemo)(() => ({
			register: p$12,
			slot: t$12.slot,
			name: t$12.name,
			props: t$12.props,
			value: t$12.value
		}), [
			p$12,
			t$12.slot,
			t$12.name,
			t$12.props,
			t$12.value
		]);
		return import_react.createElement(L$4.Provider, { value: b$13 }, t$12.children);
	}, [e$8])];
}
var G$4 = "label";
function U(n$16, l$17) {
	var y$9;
	let a$27 = (0, import_react.useId)(), e$8 = C$2(), o$19 = u$1(), T$9 = a(), { id: t$12 = `headlessui-label-${a$27}`, htmlFor: p$12 = o$19 != null ? o$19 : (y$9 = e$8.props) == null ? void 0 : y$9.htmlFor, passive: b$13 = !1,...i$15 } = n$16, u$24 = y$1(l$17);
	n$1(() => e$8.register(t$12), [t$12, e$8.register]);
	let d$13 = o((s$19) => {
		let g$8 = s$19.currentTarget;
		if (!(s$19.target !== s$19.currentTarget && L$5(s$19.target)) && (m$6(g$8) && s$19.preventDefault(), e$8.props && "onClick" in e$8.props && typeof e$8.props.onClick == "function" && e$8.props.onClick(s$19), m$6(g$8))) {
			let r$20 = document.getElementById(g$8.htmlFor);
			if (r$20) {
				let E$13 = r$20.getAttribute("disabled");
				if (E$13 === "true" || E$13 === "") return;
				let x$9 = r$20.getAttribute("aria-disabled");
				if (x$9 === "true" || x$9 === "") return;
				(l$15(r$20) && (r$20.type === "file" || r$20.type === "radio" || r$20.type === "checkbox") || r$20.role === "radio" || r$20.role === "checkbox" || r$20.role === "switch") && r$20.click(), r$20.focus({ preventScroll: !0 });
			}
		}
	}), f$21 = n({
		...e$8.slot,
		disabled: T$9 || !1
	}), c$20 = {
		ref: u$24,
		...e$8.props,
		id: t$12,
		htmlFor: p$12,
		onClick: d$13
	};
	return b$13 && ("onClick" in c$20 && (delete c$20.htmlFor, delete c$20.onClick), "onClick" in i$15 && delete i$15.onClick), K()({
		ourProps: c$20,
		theirProps: i$15,
		slot: f$21,
		defaultTag: p$12 ? G$4 : "div",
		name: e$8.name || "Label"
	});
}
var j$7 = Y(U), Z = Object.assign(j$7, {});

//#endregion
//#region node_modules/@headlessui/react/dist/components/checkbox/checkbox.js
var de$4 = "span";
function pe$2(u$24, b$13) {
	let f$21 = (0, import_react.useId)(), y$9 = u$1(), T$9 = a(), { id: h$14 = y$9 || `headlessui-checkbox-${f$21}`, disabled: o$19 = T$9 || !1, autoFocus: i$15 = !1, checked: C$10, defaultChecked: k$13, onChange: x$9, name: d$13, value: g$8, form: E$13, indeterminate: l$17 = !1, tabIndex: v$10 = 0,...P$7 } = u$24, r$20 = l(k$13), [a$27, t$12] = b$2(C$10, x$9, r$20 != null ? r$20 : !1), D$11 = N(), R$6 = w(), A$4 = p(), [F$6, p$12] = (0, import_react.useState)(!1), c$20 = o(() => {
		p$12(!0), t$12?.(!a$27), A$4.nextFrame(() => {
			p$12(!1);
		});
	}), K$3 = o((e$8) => {
		if (s$4(e$8.currentTarget)) return e$8.preventDefault();
		e$8.preventDefault(), c$20();
	}), _$10 = o((e$8) => {
		e$8.key === o$1.Space ? (e$8.preventDefault(), c$20()) : e$8.key === o$1.Enter && g(e$8.currentTarget);
	}), H$8 = o((e$8) => e$8.preventDefault()), { isFocusVisible: B$3, focusProps: I$9 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: i$15 }), { isHovered: L$6, hoverProps: M$11 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: o$19 }), { pressed: U$2, pressProps: O$4 } = w$1({ disabled: o$19 }), S$9 = V({
		ref: b$13,
		id: h$14,
		role: "checkbox",
		"aria-checked": l$17 ? "mixed" : a$27 ? "true" : "false",
		"aria-labelledby": D$11,
		"aria-describedby": R$6,
		"aria-disabled": o$19 ? !0 : void 0,
		indeterminate: l$17 ? "true" : void 0,
		tabIndex: o$19 ? void 0 : v$10,
		onKeyUp: o$19 ? void 0 : _$10,
		onKeyPress: o$19 ? void 0 : H$8,
		onClick: o$19 ? void 0 : K$3
	}, I$9, M$11, O$4), X$4 = n({
		checked: a$27,
		disabled: o$19,
		hover: L$6,
		focus: B$3,
		active: U$2,
		indeterminate: l$17,
		changing: F$6,
		autofocus: i$15
	}), G$5 = (0, import_react.useCallback)(() => {
		if (r$20 !== void 0) return t$12 == null ? void 0 : t$12(r$20);
	}, [t$12, r$20]), W$4 = K();
	return import_react.createElement(import_react.Fragment, null, d$13 != null && import_react.createElement(j, {
		disabled: o$19,
		data: { [d$13]: g$8 || "on" },
		overrides: {
			type: "checkbox",
			checked: a$27
		},
		form: E$13,
		onReset: G$5
	}), W$4({
		ourProps: S$9,
		theirProps: P$7,
		slot: X$4,
		defaultTag: de$4,
		name: "Checkbox"
	}));
}
var Ke = Y(pe$2);

//#endregion
//#region node_modules/@headlessui/react/dist/internal/close-provider.js
var e$5 = (0, import_react.createContext)(() => {});
function u() {
	return (0, import_react.useContext)(e$5);
}
function C$1({ value: t$12, children: o$19 }) {
	return import_react.createElement(e$5.Provider, { value: t$12 }, o$19);
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/close-button/close-button.js
function l$13(t$12, e$8) {
	let o$19 = u();
	return import_react.createElement(L, {
		ref: e$8,
		...V({ onClick: o$19 }, t$12)
	});
}
var y = Y(l$13);

//#endregion
//#region node_modules/@tanstack/virtual-core/dist/esm/utils.js
function memo(getDeps, fn, opts) {
	let deps = opts.initialDeps ?? [];
	let result;
	let isInitial = true;
	function memoizedFunction() {
		var _a, _b, _c;
		let depTime;
		if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();
		const newDeps = getDeps();
		if (!(newDeps.length !== deps.length || newDeps.some((dep, index$2) => deps[index$2] !== dep))) return result;
		deps = newDeps;
		let resultTime;
		if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();
		result = fn(...newDeps);
		if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {
			const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
			const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
			const resultFpsPercentage = resultEndTime / 16;
			const pad = (str, num) => {
				str = String(str);
				while (str.length < num) str = " " + str;
				return str;
			};
			console.info(`%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
		}
		if ((opts == null ? void 0 : opts.onChange) && !(isInitial && opts.skipInitialOnChange)) opts.onChange(result);
		isInitial = false;
		return result;
	}
	memoizedFunction.updateDeps = (newDeps) => {
		deps = newDeps;
	};
	return memoizedFunction;
}
function notUndefined(value, msg) {
	if (value === void 0) throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ""}`);
	else return value;
}
var approxEqual = (a$27, b$13) => Math.abs(a$27 - b$13) < 1.01;
var debounce = (targetWindow, fn, ms) => {
	let timeoutId;
	return function(...args) {
		targetWindow.clearTimeout(timeoutId);
		timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);
	};
};

//#endregion
//#region node_modules/@tanstack/virtual-core/dist/esm/index.js
var getRect = (element) => {
	const { offsetWidth, offsetHeight } = element;
	return {
		width: offsetWidth,
		height: offsetHeight
	};
};
var defaultKeyExtractor = (index$2) => index$2;
var defaultRangeExtractor = (range) => {
	const start = Math.max(range.startIndex - range.overscan, 0);
	const end = Math.min(range.endIndex + range.overscan, range.count - 1);
	const arr = [];
	for (let i$15 = start; i$15 <= end; i$15++) arr.push(i$15);
	return arr;
};
var observeElementRect = (instance, cb) => {
	const element = instance.scrollElement;
	if (!element) return;
	const targetWindow = instance.targetWindow;
	if (!targetWindow) return;
	const handler = (rect) => {
		const { width, height } = rect;
		cb({
			width: Math.round(width),
			height: Math.round(height)
		});
	};
	handler(getRect(element));
	if (!targetWindow.ResizeObserver) return () => {};
	const observer = new targetWindow.ResizeObserver((entries) => {
		const run = () => {
			const entry = entries[0];
			if (entry == null ? void 0 : entry.borderBoxSize) {
				const box = entry.borderBoxSize[0];
				if (box) {
					handler({
						width: box.inlineSize,
						height: box.blockSize
					});
					return;
				}
			}
			handler(getRect(element));
		};
		instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
	});
	observer.observe(element, { box: "border-box" });
	return () => {
		observer.unobserve(element);
	};
};
var addEventListenerOptions = { passive: true };
var supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
var observeElementOffset = (instance, cb) => {
	const element = instance.scrollElement;
	if (!element) return;
	const targetWindow = instance.targetWindow;
	if (!targetWindow) return;
	let offset$3 = 0;
	const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(targetWindow, () => {
		cb(offset$3, false);
	}, instance.options.isScrollingResetDelay);
	const createHandler = (isScrolling) => () => {
		const { horizontal, isRtl } = instance.options;
		offset$3 = horizontal ? element["scrollLeft"] * (isRtl && -1 || 1) : element["scrollTop"];
		fallback();
		cb(offset$3, isScrolling);
	};
	const handler = createHandler(true);
	const endHandler = createHandler(false);
	endHandler();
	element.addEventListener("scroll", handler, addEventListenerOptions);
	const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
	if (registerScrollendEvent) element.addEventListener("scrollend", endHandler, addEventListenerOptions);
	return () => {
		element.removeEventListener("scroll", handler);
		if (registerScrollendEvent) element.removeEventListener("scrollend", endHandler);
	};
};
var measureElement = (element, entry, instance) => {
	if (entry == null ? void 0 : entry.borderBoxSize) {
		const box = entry.borderBoxSize[0];
		if (box) return Math.round(box[instance.options.horizontal ? "inlineSize" : "blockSize"]);
	}
	return element[instance.options.horizontal ? "offsetWidth" : "offsetHeight"];
};
var elementScroll = (offset$3, { adjustments = 0, behavior }, instance) => {
	var _a, _b;
	const toOffset = offset$3 + adjustments;
	(_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null || _b.call(_a, {
		[instance.options.horizontal ? "left" : "top"]: toOffset,
		behavior
	});
};
var Virtualizer = class {
	constructor(opts) {
		this.unsubs = [];
		this.scrollElement = null;
		this.targetWindow = null;
		this.isScrolling = false;
		this.measurementsCache = [];
		this.itemSizeCache = /* @__PURE__ */ new Map();
		this.laneAssignments = /* @__PURE__ */ new Map();
		this.pendingMeasuredCacheIndexes = [];
		this.prevLanes = void 0;
		this.lanesChangedFlag = false;
		this.lanesSettling = false;
		this.scrollRect = null;
		this.scrollOffset = null;
		this.scrollDirection = null;
		this.scrollAdjustments = 0;
		this.elementsCache = /* @__PURE__ */ new Map();
		this.observer = /* @__PURE__ */ (() => {
			let _ro = null;
			const get = () => {
				if (_ro) return _ro;
				if (!this.targetWindow || !this.targetWindow.ResizeObserver) return null;
				return _ro = new this.targetWindow.ResizeObserver((entries) => {
					entries.forEach((entry) => {
						const run = () => {
							this._measureElement(entry.target, entry);
						};
						this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
					});
				});
			};
			return {
				disconnect: () => {
					var _a;
					(_a = get()) == null || _a.disconnect();
					_ro = null;
				},
				observe: (target) => {
					var _a;
					return (_a = get()) == null ? void 0 : _a.observe(target, { box: "border-box" });
				},
				unobserve: (target) => {
					var _a;
					return (_a = get()) == null ? void 0 : _a.unobserve(target);
				}
			};
		})();
		this.range = null;
		this.setOptions = (opts2) => {
			Object.entries(opts2).forEach(([key, value]) => {
				if (typeof value === "undefined") delete opts2[key];
			});
			this.options = {
				debug: false,
				initialOffset: 0,
				overscan: 1,
				paddingStart: 0,
				paddingEnd: 0,
				scrollPaddingStart: 0,
				scrollPaddingEnd: 0,
				horizontal: false,
				getItemKey: defaultKeyExtractor,
				rangeExtractor: defaultRangeExtractor,
				onChange: () => {},
				measureElement,
				initialRect: {
					width: 0,
					height: 0
				},
				scrollMargin: 0,
				gap: 0,
				indexAttribute: "data-index",
				initialMeasurementsCache: [],
				lanes: 1,
				isScrollingResetDelay: 150,
				enabled: true,
				isRtl: false,
				useScrollendEvent: false,
				useAnimationFrameWithResizeObserver: false,
				...opts2
			};
		};
		this.notify = (sync) => {
			var _a, _b;
			(_b = (_a = this.options).onChange) == null || _b.call(_a, this, sync);
		};
		this.maybeNotify = memo(() => {
			this.calculateRange();
			return [
				this.isScrolling,
				this.range ? this.range.startIndex : null,
				this.range ? this.range.endIndex : null
			];
		}, (isScrolling) => {
			this.notify(isScrolling);
		}, {
			key: "maybeNotify",
			debug: () => this.options.debug,
			initialDeps: [
				this.isScrolling,
				this.range ? this.range.startIndex : null,
				this.range ? this.range.endIndex : null
			]
		});
		this.cleanup = () => {
			this.unsubs.filter(Boolean).forEach((d$13) => d$13());
			this.unsubs = [];
			this.observer.disconnect();
			this.scrollElement = null;
			this.targetWindow = null;
		};
		this._didMount = () => {
			return () => {
				this.cleanup();
			};
		};
		this._willUpdate = () => {
			var _a;
			const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
			if (this.scrollElement !== scrollElement) {
				this.cleanup();
				if (!scrollElement) {
					this.maybeNotify();
					return;
				}
				this.scrollElement = scrollElement;
				if (this.scrollElement && "ownerDocument" in this.scrollElement) this.targetWindow = this.scrollElement.ownerDocument.defaultView;
				else this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;
				this.elementsCache.forEach((cached) => {
					this.observer.observe(cached);
				});
				this._scrollToOffset(this.getScrollOffset(), {
					adjustments: void 0,
					behavior: void 0
				});
				this.unsubs.push(this.options.observeElementRect(this, (rect) => {
					this.scrollRect = rect;
					this.maybeNotify();
				}));
				this.unsubs.push(this.options.observeElementOffset(this, (offset$3, isScrolling) => {
					this.scrollAdjustments = 0;
					this.scrollDirection = isScrolling ? this.getScrollOffset() < offset$3 ? "forward" : "backward" : null;
					this.scrollOffset = offset$3;
					this.isScrolling = isScrolling;
					this.maybeNotify();
				}));
			}
		};
		this.getSize = () => {
			if (!this.options.enabled) {
				this.scrollRect = null;
				return 0;
			}
			this.scrollRect = this.scrollRect ?? this.options.initialRect;
			return this.scrollRect[this.options.horizontal ? "width" : "height"];
		};
		this.getScrollOffset = () => {
			if (!this.options.enabled) {
				this.scrollOffset = null;
				return 0;
			}
			this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset);
			return this.scrollOffset;
		};
		this.getFurthestMeasurement = (measurements, index$2) => {
			const furthestMeasurementsFound = /* @__PURE__ */ new Map();
			const furthestMeasurements = /* @__PURE__ */ new Map();
			for (let m$9 = index$2 - 1; m$9 >= 0; m$9--) {
				const measurement = measurements[m$9];
				if (furthestMeasurementsFound.has(measurement.lane)) continue;
				const previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);
				if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) furthestMeasurements.set(measurement.lane, measurement);
				else if (measurement.end < previousFurthestMeasurement.end) furthestMeasurementsFound.set(measurement.lane, true);
				if (furthestMeasurementsFound.size === this.options.lanes) break;
			}
			return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a$27, b$13) => {
				if (a$27.end === b$13.end) return a$27.index - b$13.index;
				return a$27.end - b$13.end;
			})[0] : void 0;
		};
		this.getMeasurementOptions = memo(() => [
			this.options.count,
			this.options.paddingStart,
			this.options.scrollMargin,
			this.options.getItemKey,
			this.options.enabled,
			this.options.lanes
		], (count$1, paddingStart, scrollMargin, getItemKey, enabled, lanes) => {
			if (this.prevLanes !== void 0 && this.prevLanes !== lanes) this.lanesChangedFlag = true;
			this.prevLanes = lanes;
			this.pendingMeasuredCacheIndexes = [];
			return {
				count: count$1,
				paddingStart,
				scrollMargin,
				getItemKey,
				enabled,
				lanes
			};
		}, {
			key: false,
			skipInitialOnChange: true,
			onChange: () => {
				this.notify(this.isScrolling);
			}
		});
		this.getMeasurements = memo(() => [this.getMeasurementOptions(), this.itemSizeCache], ({ count: count$1, paddingStart, scrollMargin, getItemKey, enabled, lanes }, itemSizeCache) => {
			if (!enabled) {
				this.measurementsCache = [];
				this.itemSizeCache.clear();
				this.laneAssignments.clear();
				return [];
			}
			if (this.laneAssignments.size > count$1) {
				for (const index$2 of this.laneAssignments.keys()) if (index$2 >= count$1) this.laneAssignments.delete(index$2);
			}
			if (this.lanesChangedFlag) {
				this.lanesChangedFlag = false;
				this.lanesSettling = true;
				this.measurementsCache = [];
				this.itemSizeCache.clear();
				this.laneAssignments.clear();
				this.pendingMeasuredCacheIndexes = [];
			}
			if (this.measurementsCache.length === 0) {
				this.measurementsCache = this.options.initialMeasurementsCache;
				this.measurementsCache.forEach((item) => {
					this.itemSizeCache.set(item.key, item.size);
				});
			}
			const min$1 = this.lanesSettling ? 0 : this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
			this.pendingMeasuredCacheIndexes = [];
			if (this.lanesSettling && this.measurementsCache.length === count$1) this.lanesSettling = false;
			const measurements = this.measurementsCache.slice(0, min$1);
			const laneLastIndex = new Array(lanes).fill(void 0);
			for (let m$9 = 0; m$9 < min$1; m$9++) {
				const item = measurements[m$9];
				if (item) laneLastIndex[item.lane] = m$9;
			}
			for (let i$15 = min$1; i$15 < count$1; i$15++) {
				const key = getItemKey(i$15);
				const cachedLane = this.laneAssignments.get(i$15);
				let lane;
				let start;
				if (cachedLane !== void 0 && this.options.lanes > 1) {
					lane = cachedLane;
					const prevIndex = laneLastIndex[lane];
					const prevInLane = prevIndex !== void 0 ? measurements[prevIndex] : void 0;
					start = prevInLane ? prevInLane.end + this.options.gap : paddingStart + scrollMargin;
				} else {
					const furthestMeasurement = this.options.lanes === 1 ? measurements[i$15 - 1] : this.getFurthestMeasurement(measurements, i$15);
					start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
					lane = furthestMeasurement ? furthestMeasurement.lane : i$15 % this.options.lanes;
					if (this.options.lanes > 1) this.laneAssignments.set(i$15, lane);
				}
				const measuredSize = itemSizeCache.get(key);
				const size$3 = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i$15);
				const end = start + size$3;
				measurements[i$15] = {
					index: i$15,
					start,
					size: size$3,
					end,
					key,
					lane
				};
				laneLastIndex[lane] = i$15;
			}
			this.measurementsCache = measurements;
			return measurements;
		}, {
			key: "getMeasurements",
			debug: () => this.options.debug
		});
		this.calculateRange = memo(() => [
			this.getMeasurements(),
			this.getSize(),
			this.getScrollOffset(),
			this.options.lanes
		], (measurements, outerSize, scrollOffset, lanes) => {
			return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
				measurements,
				outerSize,
				scrollOffset,
				lanes
			}) : null;
		}, {
			key: "calculateRange",
			debug: () => this.options.debug
		});
		this.getVirtualIndexes = memo(() => {
			let startIndex = null;
			let endIndex = null;
			const range = this.calculateRange();
			if (range) {
				startIndex = range.startIndex;
				endIndex = range.endIndex;
			}
			this.maybeNotify.updateDeps([
				this.isScrolling,
				startIndex,
				endIndex
			]);
			return [
				this.options.rangeExtractor,
				this.options.overscan,
				this.options.count,
				startIndex,
				endIndex
			];
		}, (rangeExtractor, overscan, count$1, startIndex, endIndex) => {
			return startIndex === null || endIndex === null ? [] : rangeExtractor({
				startIndex,
				endIndex,
				overscan,
				count: count$1
			});
		}, {
			key: "getVirtualIndexes",
			debug: () => this.options.debug
		});
		this.indexFromElement = (node) => {
			const attributeName = this.options.indexAttribute;
			const indexStr = node.getAttribute(attributeName);
			if (!indexStr) {
				console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`);
				return -1;
			}
			return parseInt(indexStr, 10);
		};
		this._measureElement = (node, entry) => {
			const index$2 = this.indexFromElement(node);
			const item = this.measurementsCache[index$2];
			if (!item) return;
			const key = item.key;
			const prevNode = this.elementsCache.get(key);
			if (prevNode !== node) {
				if (prevNode) this.observer.unobserve(prevNode);
				this.observer.observe(node);
				this.elementsCache.set(key, node);
			}
			if (node.isConnected) this.resizeItem(index$2, this.options.measureElement(node, entry, this));
		};
		this.resizeItem = (index$2, size$3) => {
			const item = this.measurementsCache[index$2];
			if (!item) return;
			const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
			const delta = size$3 - itemSize;
			if (delta !== 0) {
				if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {
					if (this.options.debug) console.info("correction", delta);
					this._scrollToOffset(this.getScrollOffset(), {
						adjustments: this.scrollAdjustments += delta,
						behavior: void 0
					});
				}
				this.pendingMeasuredCacheIndexes.push(item.index);
				this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size$3));
				this.notify(false);
			}
		};
		this.measureElement = (node) => {
			if (!node) {
				this.elementsCache.forEach((cached, key) => {
					if (!cached.isConnected) {
						this.observer.unobserve(cached);
						this.elementsCache.delete(key);
					}
				});
				return;
			}
			this._measureElement(node, void 0);
		};
		this.getVirtualItems = memo(() => [this.getVirtualIndexes(), this.getMeasurements()], (indexes, measurements) => {
			const virtualItems = [];
			for (let k$13 = 0, len = indexes.length; k$13 < len; k$13++) {
				const i$15 = indexes[k$13];
				const measurement = measurements[i$15];
				virtualItems.push(measurement);
			}
			return virtualItems;
		}, {
			key: "getVirtualItems",
			debug: () => this.options.debug
		});
		this.getVirtualItemForOffset = (offset$3) => {
			const measurements = this.getMeasurements();
			if (measurements.length === 0) return;
			return notUndefined(measurements[findNearestBinarySearch(0, measurements.length - 1, (index$2) => notUndefined(measurements[index$2]).start, offset$3)]);
		};
		this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
			const size$3 = this.getSize();
			const scrollOffset = this.getScrollOffset();
			if (align === "auto") align = toOffset >= scrollOffset + size$3 ? "end" : "start";
			if (align === "center") toOffset += (itemSize - size$3) / 2;
			else if (align === "end") toOffset -= size$3;
			const maxOffset = this.getTotalSize() + this.options.scrollMargin - size$3;
			return Math.max(Math.min(maxOffset, toOffset), 0);
		};
		this.getOffsetForIndex = (index$2, align = "auto") => {
			index$2 = Math.max(0, Math.min(index$2, this.options.count - 1));
			const item = this.measurementsCache[index$2];
			if (!item) return;
			const size$3 = this.getSize();
			const scrollOffset = this.getScrollOffset();
			if (align === "auto") if (item.end >= scrollOffset + size$3 - this.options.scrollPaddingEnd) align = "end";
			else if (item.start <= scrollOffset + this.options.scrollPaddingStart) align = "start";
			else return [scrollOffset, align];
			const toOffset = align === "end" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;
			return [this.getOffsetForAlignment(toOffset, align, item.size), align];
		};
		this.isDynamicMode = () => this.elementsCache.size > 0;
		this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
			if (behavior === "smooth" && this.isDynamicMode()) console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
			this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
				adjustments: void 0,
				behavior
			});
		};
		this.scrollToIndex = (index$2, { align: initialAlign = "auto", behavior } = {}) => {
			if (behavior === "smooth" && this.isDynamicMode()) console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
			index$2 = Math.max(0, Math.min(index$2, this.options.count - 1));
			let attempts = 0;
			const maxAttempts = 10;
			const tryScroll = (currentAlign) => {
				if (!this.targetWindow) return;
				const offsetInfo = this.getOffsetForIndex(index$2, currentAlign);
				if (!offsetInfo) {
					console.warn("Failed to get offset for index:", index$2);
					return;
				}
				const [offset$3, align] = offsetInfo;
				this._scrollToOffset(offset$3, {
					adjustments: void 0,
					behavior
				});
				this.targetWindow.requestAnimationFrame(() => {
					const currentOffset = this.getScrollOffset();
					const afterInfo = this.getOffsetForIndex(index$2, align);
					if (!afterInfo) {
						console.warn("Failed to get offset for index:", index$2);
						return;
					}
					if (!approxEqual(afterInfo[0], currentOffset)) scheduleRetry(align);
				});
			};
			const scheduleRetry = (align) => {
				if (!this.targetWindow) return;
				attempts++;
				if (attempts < maxAttempts) {
					if (this.options.debug) console.info("Schedule retry", attempts, maxAttempts);
					this.targetWindow.requestAnimationFrame(() => tryScroll(align));
				} else console.warn(`Failed to scroll to index ${index$2} after ${maxAttempts} attempts.`);
			};
			tryScroll(initialAlign);
		};
		this.scrollBy = (delta, { behavior } = {}) => {
			if (behavior === "smooth" && this.isDynamicMode()) console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
			this._scrollToOffset(this.getScrollOffset() + delta, {
				adjustments: void 0,
				behavior
			});
		};
		this.getTotalSize = () => {
			var _a;
			const measurements = this.getMeasurements();
			let end;
			if (measurements.length === 0) end = this.options.paddingStart;
			else if (this.options.lanes === 1) end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;
			else {
				const endByLane = Array(this.options.lanes).fill(null);
				let endIndex = measurements.length - 1;
				while (endIndex >= 0 && endByLane.some((val) => val === null)) {
					const item = measurements[endIndex];
					if (endByLane[item.lane] === null) endByLane[item.lane] = item.end;
					endIndex--;
				}
				end = Math.max(...endByLane.filter((val) => val !== null));
			}
			return Math.max(end - this.options.scrollMargin + this.options.paddingEnd, 0);
		};
		this._scrollToOffset = (offset$3, { adjustments, behavior }) => {
			this.options.scrollToFn(offset$3, {
				behavior,
				adjustments
			}, this);
		};
		this.measure = () => {
			this.itemSizeCache = /* @__PURE__ */ new Map();
			this.laneAssignments = /* @__PURE__ */ new Map();
			this.notify(false);
		};
		this.setOptions(opts);
	}
};
var findNearestBinarySearch = (low, high, getCurrentValue, value) => {
	while (low <= high) {
		const middle = (low + high) / 2 | 0;
		const currentValue = getCurrentValue(middle);
		if (currentValue < value) low = middle + 1;
		else if (currentValue > value) high = middle - 1;
		else return middle;
	}
	if (low > 0) return low - 1;
	else return 0;
};
function calculateRange({ measurements, outerSize, scrollOffset, lanes }) {
	const lastIndex = measurements.length - 1;
	const getOffset = (index$2) => measurements[index$2].start;
	if (measurements.length <= lanes) return {
		startIndex: 0,
		endIndex: lastIndex
	};
	let startIndex = findNearestBinarySearch(0, lastIndex, getOffset, scrollOffset);
	let endIndex = startIndex;
	if (lanes === 1) while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) endIndex++;
	else if (lanes > 1) {
		const endPerLane = Array(lanes).fill(0);
		while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {
			const item = measurements[endIndex];
			endPerLane[item.lane] = item.end;
			endIndex++;
		}
		const startPerLane = Array(lanes).fill(scrollOffset + outerSize);
		while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {
			const item = measurements[startIndex];
			startPerLane[item.lane] = item.start;
			startIndex--;
		}
		startIndex = Math.max(0, startIndex - startIndex % lanes);
		endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));
	}
	return {
		startIndex,
		endIndex
	};
}

//#endregion
//#region node_modules/@tanstack/react-virtual/dist/esm/index.js
var import_react_dom$6 = /* @__PURE__ */ __toESM(require_react_dom());
var useIsomorphicLayoutEffect = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function useVirtualizerBase(options) {
	const rerender = import_react.useReducer(() => ({}), {})[1];
	const resolvedOptions = {
		...options,
		onChange: (instance2, sync) => {
			var _a;
			if (sync) (0, import_react_dom$6.flushSync)(rerender);
			else rerender();
			(_a = options.onChange) == null || _a.call(options, instance2, sync);
		}
	};
	const [instance] = import_react.useState(() => new Virtualizer(resolvedOptions));
	instance.setOptions(resolvedOptions);
	useIsomorphicLayoutEffect(() => {
		return instance._didMount();
	}, []);
	useIsomorphicLayoutEffect(() => {
		return instance._willUpdate();
	});
	return instance;
}
function useVirtualizer(options) {
	return useVirtualizerBase({
		observeElementRect,
		observeElementOffset,
		scrollToFn: elementScroll,
		...options
	});
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-by-comparator.js
function l$12(e$8, r$20) {
	return e$8 !== null && r$20 !== null && typeof e$8 == "object" && typeof r$20 == "object" && "id" in e$8 && "id" in r$20 ? e$8.id === r$20.id : e$8 === r$20;
}
function u$3(e$8 = l$12) {
	return (0, import_react.useCallback)((r$20, t$12) => {
		if (typeof e$8 == "string") {
			let o$19 = e$8;
			return (r$20 == null ? void 0 : r$20[o$19]) === (t$12 == null ? void 0 : t$12[o$19]);
		}
		return e$8(r$20, t$12);
	}, [e$8]);
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-element-size.js
function h$11(i$15) {
	if (i$15 === null) return {
		width: 0,
		height: 0
	};
	let { width: t$12, height: e$8 } = i$15.getBoundingClientRect();
	return {
		width: t$12,
		height: e$8
	};
}
function w$3(i$15, t$12, e$8 = !1) {
	let [r$20, f$21] = (0, import_react.useState)(() => h$11(t$12));
	return n$1(() => {
		if (!t$12 || !i$15) return;
		let n$16 = o$2();
		return n$16.requestAnimationFrame(function s$19() {
			n$16.requestAnimationFrame(s$19), f$21((u$24) => {
				let o$19 = h$11(t$12);
				return o$19.width === u$24.width && o$19.height === u$24.height ? u$24 : o$19;
			});
		}), () => {
			n$16.dispose();
		};
	}, [t$12, i$15]), e$8 ? {
		width: `${r$20.width}px`,
		height: `${r$20.height}px`
	} : r$20;
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/mouse.js
var g$4 = ((f$21) => (f$21[f$21.Left = 0] = "Left", f$21[f$21.Right = 2] = "Right", f$21))(g$4 || {});

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-handle-toggle.js
function s$6(t$12) {
	let r$20 = (0, import_react.useRef)(null), u$24 = o((e$8) => {
		r$20.current = e$8.pointerType, !s$4(e$8.currentTarget) && e$8.pointerType === "mouse" && e$8.button === g$4.Left && (e$8.preventDefault(), t$12(e$8));
	}), i$15 = o((e$8) => {
		r$20.current !== "mouse" && (s$4(e$8.currentTarget) || t$12(e$8));
	});
	return {
		onPointerDown: u$24,
		onClick: i$15
	};
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/default-map.js
var a$18 = class extends Map {
	constructor(t$12) {
		super();
		this.factory = t$12;
	}
	get(t$12) {
		let e$8 = super.get(t$12);
		return e$8 === void 0 && (e$8 = this.factory(t$12), this.set(t$12, e$8)), e$8;
	}
};

//#endregion
//#region node_modules/@headlessui/react/dist/machine.js
var h$10 = Object.defineProperty;
var v$6 = (t$12, e$8, r$20) => e$8 in t$12 ? h$10(t$12, e$8, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: r$20
}) : t$12[e$8] = r$20;
var S$7 = (t$12, e$8, r$20) => (v$6(t$12, typeof e$8 != "symbol" ? e$8 + "" : e$8, r$20), r$20), b$12 = (t$12, e$8, r$20) => {
	if (!e$8.has(t$12)) throw TypeError("Cannot " + r$20);
};
var i$8 = (t$12, e$8, r$20) => (b$12(t$12, e$8, "read from private field"), r$20 ? r$20.call(t$12) : e$8.get(t$12)), c$16 = (t$12, e$8, r$20) => {
	if (e$8.has(t$12)) throw TypeError("Cannot add the same private member more than once");
	e$8 instanceof WeakSet ? e$8.add(t$12) : e$8.set(t$12, r$20);
}, u$18 = (t$12, e$8, r$20, s$19) => (b$12(t$12, e$8, "write to private field"), s$19 ? s$19.call(t$12, r$20) : e$8.set(t$12, r$20), r$20);
var n$9, a$20, o$13;
var T$2 = class {
	constructor(e$8) {
		c$16(this, n$9, {});
		c$16(this, a$20, new a$18(() => /* @__PURE__ */ new Set()));
		c$16(this, o$13, /* @__PURE__ */ new Set());
		S$7(this, "disposables", o$2());
		u$18(this, n$9, e$8), s$10.isServer && this.disposables.microTask(() => {
			this.dispose();
		});
	}
	dispose() {
		this.disposables.dispose();
	}
	get state() {
		return i$8(this, n$9);
	}
	subscribe(e$8, r$20) {
		if (s$10.isServer) return () => {};
		let s$19 = {
			selector: e$8,
			callback: r$20,
			current: e$8(i$8(this, n$9))
		};
		return i$8(this, o$13).add(s$19), this.disposables.add(() => {
			i$8(this, o$13).delete(s$19);
		});
	}
	on(e$8, r$20) {
		return s$10.isServer ? () => {} : (i$8(this, a$20).get(e$8).add(r$20), this.disposables.add(() => {
			i$8(this, a$20).get(e$8).delete(r$20);
		}));
	}
	send(e$8) {
		let r$20 = this.reduce(i$8(this, n$9), e$8);
		if (r$20 !== i$8(this, n$9)) {
			u$18(this, n$9, r$20);
			for (let s$19 of i$8(this, o$13)) {
				let l$17 = s$19.selector(i$8(this, n$9));
				j$6(s$19.current, l$17) || (s$19.current = l$17, s$19.callback(l$17));
			}
			for (let s$19 of i$8(this, a$20).get(e$8.type)) s$19(i$8(this, n$9), e$8);
		}
	}
};
n$9 = /* @__PURE__ */ new WeakMap(), a$20 = /* @__PURE__ */ new WeakMap(), o$13 = /* @__PURE__ */ new WeakMap();
function j$6(t$12, e$8) {
	return Object.is(t$12, e$8) ? !0 : typeof t$12 != "object" || t$12 === null || typeof e$8 != "object" || e$8 === null ? !1 : Array.isArray(t$12) && Array.isArray(e$8) ? t$12.length !== e$8.length ? !1 : f$15(t$12[Symbol.iterator](), e$8[Symbol.iterator]()) : t$12 instanceof Map && e$8 instanceof Map || t$12 instanceof Set && e$8 instanceof Set ? t$12.size !== e$8.size ? !1 : f$15(t$12.entries(), e$8.entries()) : p$10(t$12) && p$10(e$8) ? f$15(Object.entries(t$12)[Symbol.iterator](), Object.entries(e$8)[Symbol.iterator]()) : !1;
}
function f$15(t$12, e$8) {
	do {
		let r$20 = t$12.next(), s$19 = e$8.next();
		if (r$20.done && s$19.done) return !0;
		if (r$20.done || s$19.done || !Object.is(r$20.value, s$19.value)) return !1;
	} while (!0);
}
function p$10(t$12) {
	if (Object.prototype.toString.call(t$12) !== "[object Object]") return !1;
	let e$8 = Object.getPrototypeOf(t$12);
	return e$8 === null || Object.getPrototypeOf(e$8) === null;
}
function k$3(t$12) {
	let [e$8, r$20] = t$12(), s$19 = o$2();
	return (...l$17) => {
		e$8(...l$17), s$19.dispose(), s$19.microTask(r$20);
	};
}

//#endregion
//#region node_modules/@headlessui/react/dist/machines/stack-machine.js
var a$19 = Object.defineProperty;
var r$12 = (e$8, c$20, t$12) => c$20 in e$8 ? a$19(e$8, c$20, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t$12
}) : e$8[c$20] = t$12;
var p$9 = (e$8, c$20, t$12) => (r$12(e$8, typeof c$20 != "symbol" ? c$20 + "" : c$20, t$12), t$12);
var k$4 = ((t$12) => (t$12[t$12.Push = 0] = "Push", t$12[t$12.Pop = 1] = "Pop", t$12))(k$4 || {});
var y$8 = {
	[0](e$8, c$20) {
		let t$12 = c$20.id, s$19 = e$8.stack, i$15 = e$8.stack.indexOf(t$12);
		if (i$15 !== -1) {
			let n$16 = e$8.stack.slice();
			return n$16.splice(i$15, 1), n$16.push(t$12), s$19 = n$16, {
				...e$8,
				stack: s$19
			};
		}
		return {
			...e$8,
			stack: [...e$8.stack, t$12]
		};
	},
	[1](e$8, c$20) {
		let t$12 = c$20.id, s$19 = e$8.stack.indexOf(t$12);
		if (s$19 === -1) return e$8;
		let i$15 = e$8.stack.slice();
		return i$15.splice(s$19, 1), {
			...e$8,
			stack: i$15
		};
	}
};
var o$12 = class o$12 extends T$2 {
	constructor() {
		super(...arguments);
		p$9(this, "actions", {
			push: (t$12) => this.send({
				type: 0,
				id: t$12
			}),
			pop: (t$12) => this.send({
				type: 1,
				id: t$12
			})
		});
		p$9(this, "selectors", {
			isTop: (t$12, s$19) => t$12.stack[t$12.stack.length - 1] === s$19,
			inStack: (t$12, s$19) => t$12.stack.includes(s$19)
		});
	}
	static new() {
		return new o$12({ stack: [] });
	}
	reduce(t$12, s$19) {
		return u$2(s$19.type, y$8, t$12, s$19);
	}
};
var x$3 = new a$18(() => o$12.new());

//#endregion
//#region node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js
var require_use_sync_external_store_with_selector_development = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js": ((exports) => {
	(function() {
		function is(x$9, y$9) {
			return x$9 === y$9 && (0 !== x$9 || 1 / x$9 === 1 / y$9) || x$9 !== x$9 && y$9 !== y$9;
		}
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var React = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = React.useSyncExternalStore, useRef$1 = React.useRef, useEffect$1 = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
		exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
			var instRef = useRef$1(null);
			if (null === instRef.current) {
				var inst = {
					hasValue: !1,
					value: null
				};
				instRef.current = inst;
			} else inst = instRef.current;
			instRef = useMemo(function() {
				function memoizedSelector(nextSnapshot) {
					if (!hasMemo) {
						hasMemo = !0;
						memoizedSnapshot = nextSnapshot;
						nextSnapshot = selector(nextSnapshot);
						if (void 0 !== isEqual && inst.hasValue) {
							var currentSelection = inst.value;
							if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
						}
						return memoizedSelection = nextSnapshot;
					}
					currentSelection = memoizedSelection;
					if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
					var nextSelection = selector(nextSnapshot);
					if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
					memoizedSnapshot = nextSnapshot;
					return memoizedSelection = nextSelection;
				}
				var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
				return [function() {
					return memoizedSelector(getSnapshot());
				}, null === maybeGetServerSnapshot ? void 0 : function() {
					return memoizedSelector(maybeGetServerSnapshot());
				}];
			}, [
				getSnapshot,
				getServerSnapshot,
				selector,
				isEqual
			]);
			var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
			useEffect$1(function() {
				inst.hasValue = !0;
				inst.value = value;
			}, [value]);
			useDebugValue(value);
			return value;
		};
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
}) });

//#endregion
//#region node_modules/use-sync-external-store/with-selector.js
var require_with_selector = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/with-selector.js": ((exports, module) => {
	module.exports = require_use_sync_external_store_with_selector_development();
}) });

//#endregion
//#region node_modules/@headlessui/react/dist/react-glue.js
var import_with_selector = /* @__PURE__ */ __toESM(require_with_selector(), 1);
function S$1(e$8, n$16, r$20 = j$6) {
	return (0, import_with_selector.useSyncExternalStoreWithSelector)(o((i$15) => e$8.subscribe(s$15, i$15)), o(() => e$8.state), o(() => e$8.state), o(n$16), r$20);
}
function s$15(e$8) {
	return e$8;
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-is-top-layer.js
function I$3(o$19, s$19) {
	let t$12 = (0, import_react.useId)(), r$20 = x$3.get(s$19), [i$15, c$20] = S$1(r$20, (0, import_react.useCallback)((e$8) => [r$20.selectors.isTop(e$8, t$12), r$20.selectors.inStack(e$8, t$12)], [r$20, t$12]));
	return n$1(() => {
		if (o$19) return r$20.actions.push(t$12), () => r$20.actions.pop(t$12);
	}, [
		r$20,
		o$19,
		t$12
	]), o$19 ? c$20 ? i$15 : !0 : !1;
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-inert-others.js
var f$14 = /* @__PURE__ */ new Map(), u$16 = /* @__PURE__ */ new Map();
function h$9(t$12) {
	var e$8;
	let r$20 = (e$8 = u$16.get(t$12)) != null ? e$8 : 0;
	return u$16.set(t$12, r$20 + 1), r$20 !== 0 ? () => m$4(t$12) : (f$14.set(t$12, {
		"aria-hidden": t$12.getAttribute("aria-hidden"),
		inert: t$12.inert
	}), t$12.setAttribute("aria-hidden", "true"), t$12.inert = !0, () => m$4(t$12));
}
function m$4(t$12) {
	var i$15;
	let r$20 = (i$15 = u$16.get(t$12)) != null ? i$15 : 1;
	if (r$20 === 1 ? u$16.delete(t$12) : u$16.set(t$12, r$20 - 1), r$20 !== 1) return;
	let e$8 = f$14.get(t$12);
	e$8 && (e$8["aria-hidden"] === null ? t$12.removeAttribute("aria-hidden") : t$12.setAttribute("aria-hidden", e$8["aria-hidden"]), t$12.inert = e$8.inert, f$14.delete(t$12));
}
function y$2(t$12, { allowed: r$20, disallowed: e$8 } = {}) {
	let i$15 = I$3(t$12, "inert-others");
	n$1(() => {
		var d$13, c$20;
		if (!i$15) return;
		let a$27 = o$2();
		for (let n$16 of (d$13 = e$8 == null ? void 0 : e$8()) != null ? d$13 : []) n$16 && a$27.add(h$9(n$16));
		let s$19 = (c$20 = r$20 == null ? void 0 : r$20()) != null ? c$20 : [];
		for (let n$16 of s$19) {
			if (!n$16) continue;
			let l$17 = l$1(n$16);
			if (!l$17) continue;
			let o$19 = n$16.parentElement;
			for (; o$19 && o$19 !== l$17.body;) {
				for (let p$12 of o$19.children) s$19.some((E$13) => p$12.contains(E$13)) || a$27.add(h$9(p$12));
				o$19 = o$19.parentElement;
			}
		}
		return a$27.dispose;
	}, [
		i$15,
		r$20,
		e$8
	]);
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-on-disappear.js
function p$1(s$19, n$16, o$19) {
	let i$15 = s((t$12) => {
		let e$8 = t$12.getBoundingClientRect();
		e$8.x === 0 && e$8.y === 0 && e$8.width === 0 && e$8.height === 0 && o$19();
	});
	(0, import_react.useEffect)(() => {
		if (!s$19) return;
		let t$12 = n$16 === null ? null : n$13(n$16) ? n$16 : n$16.current;
		if (!t$12) return;
		let e$8 = o$2();
		if (typeof ResizeObserver != "undefined") {
			let r$20 = new ResizeObserver(() => i$15.current(t$12));
			r$20.observe(t$12), e$8.add(() => r$20.disconnect());
		}
		if (typeof IntersectionObserver != "undefined") {
			let r$20 = new IntersectionObserver(() => i$15.current(t$12));
			r$20.observe(t$12), e$8.add(() => r$20.disconnect());
		}
		return () => e$8.dispose();
	}, [
		n$16,
		i$15,
		s$19
	]);
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/focus-management.js
var E$6 = [
	"[contentEditable=true]",
	"[tabindex]",
	"a[href]",
	"area[href]",
	"button:not([disabled])",
	"iframe",
	"input:not([disabled])",
	"select:not([disabled])",
	"details>summary",
	"textarea:not([disabled])"
].map((e$8) => `${e$8}:not([tabindex='-1'])`).join(","), S$6 = ["[data-autofocus]"].map((e$8) => `${e$8}:not([tabindex='-1'])`).join(",");
var T = ((o$19) => (o$19[o$19.First = 1] = "First", o$19[o$19.Previous = 2] = "Previous", o$19[o$19.Next = 4] = "Next", o$19[o$19.Last = 8] = "Last", o$19[o$19.WrapAround = 16] = "WrapAround", o$19[o$19.NoScroll = 32] = "NoScroll", o$19[o$19.AutoFocus = 64] = "AutoFocus", o$19))(T || {}), A = ((n$16) => (n$16[n$16.Error = 0] = "Error", n$16[n$16.Overflow = 1] = "Overflow", n$16[n$16.Success = 2] = "Success", n$16[n$16.Underflow = 3] = "Underflow", n$16))(A || {}), O$3 = ((t$12) => (t$12[t$12.Previous = -1] = "Previous", t$12[t$12.Next = 1] = "Next", t$12))(O$3 || {});
function x$2(e$8 = document.body) {
	return e$8 == null ? [] : Array.from(e$8.querySelectorAll(E$6)).sort((r$20, t$12) => Math.sign((r$20.tabIndex || Number.MAX_SAFE_INTEGER) - (t$12.tabIndex || Number.MAX_SAFE_INTEGER)));
}
function h$8(e$8 = document.body) {
	return e$8 == null ? [] : Array.from(e$8.querySelectorAll(S$6)).sort((r$20, t$12) => Math.sign((r$20.tabIndex || Number.MAX_SAFE_INTEGER) - (t$12.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var I$1 = ((t$12) => (t$12[t$12.Strict = 0] = "Strict", t$12[t$12.Loose = 1] = "Loose", t$12))(I$1 || {});
function H$3(e$8, r$20 = 0) {
	var t$12;
	return e$8 === ((t$12 = l$1(e$8)) == null ? void 0 : t$12.body) ? !1 : u$2(r$20, {
		[0]() {
			return e$8.matches(E$6);
		},
		[1]() {
			let l$17 = e$8;
			for (; l$17 !== null;) {
				if (l$17.matches(E$6)) return !0;
				l$17 = l$17.parentElement;
			}
			return !1;
		}
	});
}
function K$1(e$8) {
	o$2().nextFrame(() => {
		let r$20 = e$1(e$8);
		r$20 && i$11(r$20) && !H$3(r$20, 0) && w$7(e$8);
	});
}
var g$5 = ((t$12) => (t$12[t$12.Keyboard = 0] = "Keyboard", t$12[t$12.Mouse = 1] = "Mouse", t$12))(g$5 || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e$8) => {
	e$8.metaKey || e$8.altKey || e$8.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (e$8) => {
	e$8.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e$8.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function w$7(e$8) {
	e$8?.focus({ preventScroll: !0 });
}
var _$7 = ["textarea", "input"].join(",");
function P$4(e$8) {
	var r$20, t$12;
	return (t$12 = (r$20 = e$8 == null ? void 0 : e$8.matches) == null ? void 0 : r$20.call(e$8, _$7)) != null ? t$12 : !1;
}
function G$2(e$8, r$20 = (t$12) => t$12) {
	return e$8.slice().sort((t$12, l$17) => {
		let n$16 = r$20(t$12), a$27 = r$20(l$17);
		if (n$16 === null || a$27 === null) return 0;
		let u$24 = n$16.compareDocumentPosition(a$27);
		return u$24 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : u$24 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
	});
}
function R(e$8, r$20, t$12 = e$8 === null ? document.body : r(e$8)) {
	return v(x$2(t$12), r$20, { relativeTo: e$8 });
}
function v(e$8, r$20, { sorted: t$12 = !0, relativeTo: l$17 = null, skipElements: n$16 = [] } = {}) {
	let a$27 = Array.isArray(e$8) ? e$8.length > 0 ? r(e$8[0]) : document : r(e$8), u$24 = Array.isArray(e$8) ? t$12 ? G$2(e$8) : e$8 : r$20 & 64 ? h$8(e$8) : x$2(e$8);
	n$16.length > 0 && u$24.length > 1 && (u$24 = u$24.filter((i$15) => !n$16.some((d$13) => d$13 != null && "current" in d$13 ? (d$13 == null ? void 0 : d$13.current) === i$15 : d$13 === i$15))), l$17 = l$17 != null ? l$17 : a$27 == null ? void 0 : a$27.activeElement;
	let o$19 = (() => {
		if (r$20 & 5) return 1;
		if (r$20 & 10) return -1;
		throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
	})(), M$11 = (() => {
		if (r$20 & 1) return 0;
		if (r$20 & 2) return Math.max(0, u$24.indexOf(l$17)) - 1;
		if (r$20 & 4) return Math.max(0, u$24.indexOf(l$17)) + 1;
		if (r$20 & 8) return u$24.length - 1;
		throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
	})(), N$3 = r$20 & 32 ? { preventScroll: !0 } : {}, m$9 = 0, c$20 = u$24.length, s$19;
	do {
		if (m$9 >= c$20 || m$9 + c$20 <= 0) return 0;
		let i$15 = M$11 + m$9;
		if (r$20 & 16) i$15 = (i$15 + c$20) % c$20;
		else {
			if (i$15 < 0) return 3;
			if (i$15 >= c$20) return 1;
		}
		s$19 = u$24[i$15], s$19?.focus(N$3), m$9 += o$19;
	} while (s$19 !== e$1(s$19));
	return r$20 & 6 && P$4(s$19) && s$19.select(), 2;
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/platform.js
function t$8() {
	return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$7() {
	return /Android/gi.test(window.navigator.userAgent);
}
function n$5() {
	return t$8() || i$7();
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-document-event.js
function i$6(t$12, e$8, o$19, n$16) {
	let u$24 = s(o$19);
	(0, import_react.useEffect)(() => {
		if (!t$12) return;
		function r$20(m$9) {
			u$24.current(m$9);
		}
		return document.addEventListener(e$8, r$20, n$16), () => document.removeEventListener(e$8, r$20, n$16);
	}, [
		t$12,
		e$8,
		n$16
	]);
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-window-event.js
function s$9(t$12, e$8, o$19, n$16) {
	let i$15 = s(o$19);
	(0, import_react.useEffect)(() => {
		if (!t$12) return;
		function r$20(d$13) {
			i$15.current(d$13);
		}
		return window.addEventListener(e$8, r$20, n$16), () => window.removeEventListener(e$8, r$20, n$16);
	}, [
		t$12,
		e$8,
		n$16
	]);
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-outside-click.js
var C$7 = 30;
function k$1(o$19, f$21, h$14) {
	let m$9 = s(h$14), s$19 = (0, import_react.useCallback)(function(e$8, c$20) {
		if (e$8.defaultPrevented) return;
		let r$20 = c$20(e$8);
		if (r$20 === null || !r$20.getRootNode().contains(r$20) || !r$20.isConnected) return;
		let M$11 = function u$24(n$16) {
			return typeof n$16 == "function" ? u$24(n$16()) : Array.isArray(n$16) || n$16 instanceof Set ? n$16 : [n$16];
		}(f$21);
		for (let u$24 of M$11) if (u$24 !== null && (u$24.contains(r$20) || e$8.composed && e$8.composedPath().includes(u$24))) return;
		return !H$3(r$20, I$1.Loose) && r$20.tabIndex !== -1 && e$8.preventDefault(), m$9.current(e$8, r$20);
	}, [m$9, f$21]), i$15 = (0, import_react.useRef)(null);
	i$6(o$19, "pointerdown", (t$12) => {
		var e$8, c$20;
		n$5() || (i$15.current = ((c$20 = (e$8 = t$12.composedPath) == null ? void 0 : e$8.call(t$12)) == null ? void 0 : c$20[0]) || t$12.target);
	}, !0), i$6(o$19, "pointerup", (t$12) => {
		if (n$5() || !i$15.current) return;
		let e$8 = i$15.current;
		return i$15.current = null, s$19(t$12, () => e$8);
	}, !0);
	let l$17 = (0, import_react.useRef)({
		x: 0,
		y: 0
	});
	i$6(o$19, "touchstart", (t$12) => {
		l$17.current.x = t$12.touches[0].clientX, l$17.current.y = t$12.touches[0].clientY;
	}, !0), i$6(o$19, "touchend", (t$12) => {
		let e$8 = {
			x: t$12.changedTouches[0].clientX,
			y: t$12.changedTouches[0].clientY
		};
		if (!(Math.abs(e$8.x - l$17.current.x) >= C$7 || Math.abs(e$8.y - l$17.current.y) >= C$7)) return s$19(t$12, () => i$11(t$12.target) ? t$12.target : null);
	}, !0), s$9(o$19, "blur", (t$12) => s$19(t$12, () => u$21(window.document.activeElement) ? window.document.activeElement : null), !0);
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-owner.js
function u$4(...e$8) {
	return (0, import_react.useMemo)(() => l$1(...e$8), [...e$8]);
}
function c$1(...e$8) {
	return (0, import_react.useMemo)(() => r(...e$8), [...e$8]);
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-quick-release.js
var H$5 = ((e$8) => (e$8[e$8.Ignore = 0] = "Ignore", e$8[e$8.Select = 1] = "Select", e$8[e$8.Close = 2] = "Close", e$8))(H$5 || {});
var S$2 = {
	Ignore: { kind: 0 },
	Select: (r$20) => ({
		kind: 1,
		target: r$20
	}),
	Close: { kind: 2 }
}, M$9 = 200, f$13 = 5;
function L$2(r$20, { trigger: n$16, action: T$9, close: e$8, select: p$12 }) {
	let l$17 = (0, import_react.useRef)(null), i$15 = (0, import_react.useRef)(null), u$24 = (0, import_react.useRef)(null);
	i$6(r$20 && n$16 !== null, "pointerdown", (t$12) => {
		o$14(t$12 == null ? void 0 : t$12.target) && n$16 != null && n$16.contains(t$12.target) && (i$15.current = t$12.x, u$24.current = t$12.y, l$17.current = t$12.timeStamp);
	}), i$6(r$20 && n$16 !== null, "pointerup", (t$12) => {
		var s$19, m$9;
		let c$20 = l$17.current;
		if (c$20 === null || (l$17.current = null, !i$11(t$12.target)) || Math.abs(t$12.x - ((s$19 = i$15.current) != null ? s$19 : t$12.x)) < f$13 && Math.abs(t$12.y - ((m$9 = u$24.current) != null ? m$9 : t$12.y)) < f$13) return;
		let a$27 = T$9(t$12);
		switch (a$27.kind) {
			case 0: return;
			case 1:
				t$12.timeStamp - c$20 > M$9 && (p$12(a$27.target), e$8());
				break;
			case 2:
				e$8();
				break;
		}
	}, { capture: !0 });
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-event-listener.js
function E$2(n$16, e$8, a$27, t$12) {
	let i$15 = s(a$27);
	(0, import_react.useEffect)(() => {
		n$16 = n$16 != null ? n$16 : window;
		function r$20(o$19) {
			i$15.current(o$19);
		}
		return n$16.addEventListener(e$8, r$20, t$12), () => n$16.removeEventListener(e$8, r$20, t$12);
	}, [
		n$16,
		e$8,
		t$12
	]);
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-refocusable-input.js
function v$3(e$8) {
	let l$17 = (0, import_react.useRef)({
		value: "",
		selectionStart: null,
		selectionEnd: null
	});
	return E$2(e$8, "blur", (n$16) => {
		let t$12 = n$16.target;
		l$15(t$12) && (l$17.current = {
			value: t$12.value,
			selectionStart: t$12.selectionStart,
			selectionEnd: t$12.selectionEnd
		});
	}), o(() => {
		if (!d$1(e$8) && l$15(e$8) && e$8.isConnected) {
			if (e$8.focus({ preventScroll: !0 }), e$8.value !== l$17.current.value) e$8.setSelectionRange(e$8.value.length, e$8.value.length);
			else {
				let { selectionStart: n$16, selectionEnd: t$12 } = l$17.current;
				n$16 !== null && t$12 !== null && e$8.setSelectionRange(n$16, t$12);
			}
			l$17.current = {
				value: "",
				selectionStart: null,
				selectionEnd: null
			};
		}
	});
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
function e(t$12, u$24) {
	return (0, import_react.useMemo)(() => {
		var n$16;
		if (t$12.type) return t$12.type;
		let r$20 = (n$16 = t$12.as) != null ? n$16 : "button";
		if (typeof r$20 == "string" && r$20.toLowerCase() === "button" || (u$24 == null ? void 0 : u$24.tagName) === "BUTTON" && !u$24.hasAttribute("type")) return "button";
	}, [
		t$12.type,
		t$12.as,
		u$24
	]);
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-store.js
function o$9(t$12) {
	return (0, import_react.useSyncExternalStore)(t$12.subscribe, t$12.getSnapshot, t$12.getSnapshot);
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/store.js
function a$14(o$19, r$20) {
	let t$12 = o$19(), n$16 = /* @__PURE__ */ new Set();
	return {
		getSnapshot() {
			return t$12;
		},
		subscribe(e$8) {
			return n$16.add(e$8), () => n$16.delete(e$8);
		},
		dispatch(e$8, ...s$19) {
			let i$15 = r$20[e$8].call(t$12, ...s$19);
			i$15 && (t$12 = i$15, n$16.forEach((c$20) => c$20()));
		}
	};
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/document-overflow/adjust-scrollbar-padding.js
function d$8() {
	let r$20;
	return {
		before({ doc: e$8 }) {
			var l$17;
			let o$19 = e$8.documentElement, t$12 = (l$17 = e$8.defaultView) != null ? l$17 : window;
			r$20 = Math.max(0, t$12.innerWidth - o$19.clientWidth);
		},
		after({ doc: e$8, d: o$19 }) {
			let t$12 = e$8.documentElement, l$17 = Math.max(0, t$12.clientWidth - t$12.offsetWidth), n$16 = Math.max(0, r$20 - l$17);
			o$19.style(t$12, "paddingRight", `${n$16}px`);
		}
	};
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/document-overflow/handle-ios-locking.js
function w$9() {
	return t$8() ? { before({ doc: o$19, d: r$20, meta: m$9 }) {
		function a$27(s$19) {
			for (let l$17 of m$9().containers) for (let c$20 of l$17()) if (c$20.contains(s$19)) return !0;
			return !1;
		}
		r$20.microTask(() => {
			var c$20;
			if (window.getComputedStyle(o$19.documentElement).scrollBehavior !== "auto") {
				let t$12 = o$2();
				t$12.style(o$19.documentElement, "scrollBehavior", "auto"), r$20.add(() => r$20.microTask(() => t$12.dispose()));
			}
			let s$19 = (c$20 = window.scrollY) != null ? c$20 : window.pageYOffset, l$17 = null;
			r$20.addEventListener(o$19, "click", (t$12) => {
				if (i$11(t$12.target)) try {
					let e$8 = t$12.target.closest("a");
					if (!e$8) return;
					let { hash: n$16 } = new URL(e$8.href), f$21 = o$19.querySelector(n$16);
					i$11(f$21) && !a$27(f$21) && (l$17 = f$21);
				} catch {}
			}, !0), r$20.group((t$12) => {
				r$20.addEventListener(o$19, "touchstart", (e$8) => {
					if (t$12.dispose(), i$11(e$8.target) && r$15(e$8.target)) if (a$27(e$8.target)) {
						let n$16 = e$8.target;
						for (; n$16.parentElement && a$27(n$16.parentElement);) n$16 = n$16.parentElement;
						t$12.style(n$16, "overscrollBehavior", "contain");
					} else t$12.style(e$8.target, "touchAction", "none");
				});
			}), r$20.addEventListener(o$19, "touchmove", (t$12) => {
				if (i$11(t$12.target)) {
					if (l$15(t$12.target)) return;
					if (a$27(t$12.target)) {
						let e$8 = t$12.target;
						for (; e$8.parentElement && e$8.dataset.headlessuiPortal !== "" && !(e$8.scrollHeight > e$8.clientHeight || e$8.scrollWidth > e$8.clientWidth);) e$8 = e$8.parentElement;
						e$8.dataset.headlessuiPortal === "" && t$12.preventDefault();
					} else t$12.preventDefault();
				}
			}, { passive: !1 }), r$20.add(() => {
				var e$8;
				let t$12 = (e$8 = window.scrollY) != null ? e$8 : window.pageYOffset;
				s$19 !== t$12 && window.scrollTo(0, s$19), l$17 && l$17.isConnected && (l$17.scrollIntoView({ block: "nearest" }), l$17 = null);
			});
		});
	} } : {};
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/document-overflow/prevent-scroll.js
function r$10() {
	return { before({ doc: e$8, d: o$19 }) {
		o$19.style(e$8.documentElement, "overflow", "hidden");
	} };
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/document-overflow/overflow-store.js
function r$11(e$8) {
	let o$19 = {};
	for (let t$12 of e$8) Object.assign(o$19, t$12(o$19));
	return o$19;
}
var c$14 = a$14(() => /* @__PURE__ */ new Map(), {
	PUSH(e$8, o$19) {
		var n$16;
		let t$12 = (n$16 = this.get(e$8)) != null ? n$16 : {
			doc: e$8,
			count: 0,
			d: o$2(),
			meta: /* @__PURE__ */ new Set(),
			computedMeta: {}
		};
		return t$12.count++, t$12.meta.add(o$19), t$12.computedMeta = r$11(t$12.meta), this.set(e$8, t$12), this;
	},
	POP(e$8, o$19) {
		let t$12 = this.get(e$8);
		return t$12 && (t$12.count--, t$12.meta.delete(o$19), t$12.computedMeta = r$11(t$12.meta)), this;
	},
	SCROLL_PREVENT(e$8) {
		let o$19 = {
			doc: e$8.doc,
			d: e$8.d,
			meta() {
				return e$8.computedMeta;
			}
		}, t$12 = [
			w$9(),
			d$8(),
			r$10()
		];
		t$12.forEach(({ before: n$16 }) => n$16 == null ? void 0 : n$16(o$19)), t$12.forEach(({ after: n$16 }) => n$16 == null ? void 0 : n$16(o$19));
	},
	SCROLL_ALLOW({ d: e$8 }) {
		e$8.dispose();
	},
	TEARDOWN({ doc: e$8 }) {
		this.delete(e$8);
	}
});
c$14.subscribe(() => {
	let e$8 = c$14.getSnapshot(), o$19 = /* @__PURE__ */ new Map();
	for (let [t$12] of e$8) o$19.set(t$12, t$12.documentElement.style.overflow);
	for (let t$12 of e$8.values()) {
		let n$16 = o$19.get(t$12.doc) === "hidden", a$27 = t$12.count !== 0;
		(a$27 && !n$16 || !a$27 && n$16) && c$14.dispatch(t$12.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t$12), t$12.count === 0 && c$14.dispatch("TEARDOWN", t$12);
	}
});

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/document-overflow/use-document-overflow.js
function a$13(r$20, e$8, n$16 = () => ({ containers: [] })) {
	let f$21 = o$9(c$14), o$19 = e$8 ? f$21.get(e$8) : void 0, i$15 = o$19 ? o$19.count > 0 : !1;
	return n$1(() => {
		if (!(!e$8 || !r$20)) return c$14.dispatch("PUSH", e$8, n$16), () => c$14.dispatch("POP", e$8, n$16);
	}, [r$20, e$8]), i$15;
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-scroll-lock.js
function f$3(e$8, c$20, n$16 = () => [document.body]) {
	let r$20 = I$3(e$8, "scroll-lock");
	a$13(r$20, c$20, (t$12) => {
		var o$19;
		return { containers: [...(o$19 = t$12.containers) != null ? o$19 : [], n$16] };
	});
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js
function t$7(e$8) {
	return [e$8.screenX, e$8.screenY];
}
function u$8() {
	let e$8 = (0, import_react.useRef)([-1, -1]);
	return {
		wasMoved(r$20) {
			let n$16 = t$7(r$20);
			return e$8.current[0] === n$16[0] && e$8.current[1] === n$16[1] ? !1 : (e$8.current = n$16, !0);
		},
		update(r$20) {
			e$8.current = t$7(r$20);
		}
	};
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-flags.js
function c$13(u$24 = 0) {
	let [r$20, a$27] = (0, import_react.useState)(u$24), g$8 = (0, import_react.useCallback)((e$8) => a$27(e$8), []), s$19 = (0, import_react.useCallback)((e$8) => a$27((l$17) => l$17 | e$8), []), m$9 = (0, import_react.useCallback)((e$8) => (r$20 & e$8) === e$8, [r$20]), n$16 = (0, import_react.useCallback)((e$8) => a$27((l$17) => l$17 & ~e$8), []), F$6 = (0, import_react.useCallback)((e$8) => a$27((l$17) => l$17 ^ e$8), []);
	return {
		flags: r$20,
		setFlag: g$8,
		addFlag: s$19,
		hasFlag: m$9,
		removeFlag: n$16,
		toggleFlag: F$6
	};
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-transition.js
var T$6, S$5;
typeof process != "undefined" && typeof globalThis != "undefined" && typeof Element != "undefined" && ((T$6 = process == null ? void 0 : process.env) == null ? void 0 : T$6["NODE_ENV"]) === "test" && typeof ((S$5 = Element == null ? void 0 : Element.prototype) == null ? void 0 : S$5.getAnimations) == "undefined" && (Element.prototype.getAnimations = function() {
	return console.warn([
		"Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.",
		"Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.",
		"",
		"Example usage:",
		"```js",
		"import { mockAnimationsApi } from 'jsdom-testing-mocks'",
		"mockAnimationsApi()",
		"```"
	].join(`
`)), [];
});
var A$3 = ((i$15) => (i$15[i$15.None = 0] = "None", i$15[i$15.Closed = 1] = "Closed", i$15[i$15.Enter = 2] = "Enter", i$15[i$15.Leave = 4] = "Leave", i$15))(A$3 || {});
function x$1(e$8) {
	let r$20 = {};
	for (let t$12 in e$8) e$8[t$12] === !0 && (r$20[`data-${t$12}`] = "");
	return r$20;
}
function N$1(e$8, r$20, t$12, n$16) {
	let [i$15, a$27] = (0, import_react.useState)(t$12), { hasFlag: s$19, addFlag: o$19, removeFlag: l$17 } = c$13(e$8 && i$15 ? 3 : 0), u$24 = (0, import_react.useRef)(!1), f$21 = (0, import_react.useRef)(!1), E$13 = p();
	return n$1(() => {
		var d$13;
		if (e$8) {
			if (t$12 && a$27(!0), !r$20) {
				t$12 && o$19(3);
				return;
			}
			return (d$13 = n$16 == null ? void 0 : n$16.start) == null || d$13.call(n$16, t$12), C$6(r$20, {
				inFlight: u$24,
				prepare() {
					f$21.current ? f$21.current = !1 : f$21.current = u$24.current, u$24.current = !0, !f$21.current && (t$12 ? (o$19(3), l$17(4)) : (o$19(4), l$17(2)));
				},
				run() {
					f$21.current ? t$12 ? (l$17(3), o$19(4)) : (l$17(4), o$19(3)) : t$12 ? l$17(1) : o$19(1);
				},
				done() {
					var p$12;
					f$21.current && D$7(r$20) || (u$24.current = !1, l$17(7), t$12 || a$27(!1), (p$12 = n$16 == null ? void 0 : n$16.end) == null || p$12.call(n$16, t$12));
				}
			});
		}
	}, [
		e$8,
		t$12,
		r$20,
		E$13
	]), e$8 ? [i$15, {
		closed: s$19(1),
		enter: s$19(2),
		leave: s$19(4),
		transition: s$19(2) || s$19(4)
	}] : [t$12, {
		closed: void 0,
		enter: void 0,
		leave: void 0,
		transition: void 0
	}];
}
function C$6(e$8, { prepare: r$20, run: t$12, done: n$16, inFlight: i$15 }) {
	let a$27 = o$2();
	return j$5(e$8, {
		prepare: r$20,
		inFlight: i$15
	}), a$27.nextFrame(() => {
		t$12(), a$27.requestAnimationFrame(() => {
			a$27.add(M$8(e$8, n$16));
		});
	}), a$27.dispose;
}
function M$8(e$8, r$20) {
	var a$27, s$19;
	let t$12 = o$2();
	if (!e$8) return t$12.dispose;
	let n$16 = !1;
	t$12.add(() => {
		n$16 = !0;
	});
	let i$15 = (s$19 = (a$27 = e$8.getAnimations) == null ? void 0 : a$27.call(e$8).filter((o$19) => o$19 instanceof CSSTransition)) != null ? s$19 : [];
	return i$15.length === 0 ? (r$20(), t$12.dispose) : (Promise.allSettled(i$15.map((o$19) => o$19.finished)).then(() => {
		n$16 || r$20();
	}), t$12.dispose);
}
function j$5(e$8, { inFlight: r$20, prepare: t$12 }) {
	if (r$20 != null && r$20.current) {
		t$12();
		return;
	}
	let n$16 = e$8.style.transition;
	e$8.style.transition = "none", t$12(), e$8.offsetHeight, e$8.style.transition = n$16;
}
function D$7(e$8) {
	var t$12, n$16;
	return ((n$16 = (t$12 = e$8.getAnimations) == null ? void 0 : t$12.call(e$8)) != null ? n$16 : []).some((i$15) => i$15 instanceof CSSTransition && i$15.playState !== "finished");
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-tree-walker.js
function F(c$20, { container: e$8, accept: t$12, walk: r$20 }) {
	let o$19 = (0, import_react.useRef)(t$12), l$17 = (0, import_react.useRef)(r$20);
	(0, import_react.useEffect)(() => {
		o$19.current = t$12, l$17.current = r$20;
	}, [t$12, r$20]), n$1(() => {
		if (!e$8 || !c$20) return;
		let n$16 = l$1(e$8);
		if (!n$16) return;
		let f$21 = o$19.current, p$12 = l$17.current, i$15 = Object.assign((m$9) => f$21(m$9), { acceptNode: f$21 }), u$24 = n$16.createTreeWalker(e$8, NodeFilter.SHOW_ELEMENT, i$15, !1);
		for (; u$24.nextNode();) p$12(u$24.currentNode);
	}, [
		e$8,
		c$20,
		o$19,
		l$17
	]);
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-watch.js
function m$1(u$24, t$12) {
	let e$8 = (0, import_react.useRef)([]), r$20 = o(u$24);
	(0, import_react.useEffect)(() => {
		let o$19 = [...e$8.current];
		for (let [a$27, l$17] of t$12.entries()) if (e$8.current[a$27] !== l$17) {
			let n$16 = r$20(t$12, o$19);
			return e$8.current = t$12, n$16;
		}
	}, [r$20, ...t$12]);
}

//#endregion
//#region node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
	return typeof window !== "undefined";
}
function getNodeName(node) {
	if (isNode(node)) return (node.nodeName || "").toLowerCase();
	return "#document";
}
function getWindow(node) {
	var _node$ownerDocument;
	return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
	var _ref;
	return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
	if (!hasWindow()) return false;
	return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
	if (!hasWindow()) return false;
	return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
	if (!hasWindow()) return false;
	return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
	if (!hasWindow() || typeof ShadowRoot === "undefined") return false;
	return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
	const { overflow, overflowX, overflowY, display } = getComputedStyle$1(element);
	return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set([
	"table",
	"td",
	"th"
]);
function isTableElement(element) {
	return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
	return topLayerSelectors.some((selector) => {
		try {
			return element.matches(selector);
		} catch (_e$3) {
			return false;
		}
	});
}
var transformProperties = [
	"transform",
	"translate",
	"scale",
	"rotate",
	"perspective"
];
var willChangeValues = [
	"transform",
	"translate",
	"scale",
	"rotate",
	"perspective",
	"filter"
];
var containValues = [
	"paint",
	"layout",
	"strict",
	"content"
];
function isContainingBlock(elementOrCss) {
	const webkit = isWebKit();
	const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
	return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
	let currentNode = getParentNode(element);
	while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
		if (isContainingBlock(currentNode)) return currentNode;
		else if (isTopLayer(currentNode)) return null;
		currentNode = getParentNode(currentNode);
	}
	return null;
}
function isWebKit() {
	if (typeof CSS === "undefined" || !CSS.supports) return false;
	return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set([
	"html",
	"body",
	"#document"
]);
function isLastTraversableNode(node) {
	return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
	return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
	if (isElement(element)) return {
		scrollLeft: element.scrollLeft,
		scrollTop: element.scrollTop
	};
	return {
		scrollLeft: element.scrollX,
		scrollTop: element.scrollY
	};
}
function getParentNode(node) {
	if (getNodeName(node) === "html") return node;
	const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
	return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
	const parentNode = getParentNode(node);
	if (isLastTraversableNode(parentNode)) return node.ownerDocument ? node.ownerDocument.body : node.body;
	if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
	return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
	var _node$ownerDocument2;
	if (list === void 0) list = [];
	if (traverseIframes === void 0) traverseIframes = true;
	const scrollableAncestor = getNearestOverflowAncestor(node);
	const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
	const win = getWindow(scrollableAncestor);
	if (isBody) {
		const frameElement = getFrameElement(win);
		return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
	}
	return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
	return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

//#endregion
//#region node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
function getUserAgent() {
	const uaData = navigator.userAgentData;
	if (uaData && Array.isArray(uaData.brands)) return uaData.brands.map((_ref) => {
		let { brand, version } = _ref;
		return brand + "/" + version;
	}).join(" ");
	return navigator.userAgent;
}

//#endregion
//#region node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v$10) => ({
	x: v$10,
	y: v$10
});
var oppositeSideMap = {
	left: "right",
	right: "left",
	bottom: "top",
	top: "bottom"
};
var oppositeAlignmentMap = {
	start: "end",
	end: "start"
};
function clamp(start, value, end) {
	return max(start, min(value, end));
}
function evaluate(value, param) {
	return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
	return placement.split("-")[0];
}
function getAlignment(placement) {
	return placement.split("-")[1];
}
function getOppositeAxis(axis) {
	return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
	return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
	return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
	return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
	if (rtl === void 0) rtl = false;
	const alignment = getAlignment(placement);
	const alignmentAxis = getAlignmentAxis(placement);
	const length = getAxisLength(alignmentAxis);
	let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
	if (rects.reference[length] > rects.floating[length]) mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
	return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
	const oppositePlacement = getOppositePlacement(placement);
	return [
		getOppositeAlignmentPlacement(placement),
		oppositePlacement,
		getOppositeAlignmentPlacement(oppositePlacement)
	];
}
function getOppositeAlignmentPlacement(placement) {
	return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
	switch (side) {
		case "top":
		case "bottom":
			if (rtl) return isStart ? rlPlacement : lrPlacement;
			return isStart ? lrPlacement : rlPlacement;
		case "left":
		case "right": return isStart ? tbPlacement : btPlacement;
		default: return [];
	}
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
	const alignment = getAlignment(placement);
	let list = getSideList(getSide(placement), direction === "start", rtl);
	if (alignment) {
		list = list.map((side) => side + "-" + alignment);
		if (flipAlignment) list = list.concat(list.map(getOppositeAlignmentPlacement));
	}
	return list;
}
function getOppositePlacement(placement) {
	return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
	return {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0,
		...padding
	};
}
function getPaddingObject(padding) {
	return typeof padding !== "number" ? expandPaddingObject(padding) : {
		top: padding,
		right: padding,
		bottom: padding,
		left: padding
	};
}
function rectToClientRect(rect) {
	const { x: x$9, y: y$9, width, height } = rect;
	return {
		width,
		height,
		top: y$9,
		left: x$9,
		right: x$9 + width,
		bottom: y$9 + height,
		x: x$9,
		y: y$9
	};
}

//#endregion
//#region node_modules/tabbable/dist/index.esm.js
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
	var _element$getRootNode;
	return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
	return element === null || element === void 0 ? void 0 : element.ownerDocument;
};

//#endregion
//#region node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
	let { reference, floating } = _ref;
	const sideAxis = getSideAxis(placement);
	const alignmentAxis = getAlignmentAxis(placement);
	const alignLength = getAxisLength(alignmentAxis);
	const side = getSide(placement);
	const isVertical = sideAxis === "y";
	const commonX = reference.x + reference.width / 2 - floating.width / 2;
	const commonY = reference.y + reference.height / 2 - floating.height / 2;
	const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
	let coords;
	switch (side) {
		case "top":
			coords = {
				x: commonX,
				y: reference.y - floating.height
			};
			break;
		case "bottom":
			coords = {
				x: commonX,
				y: reference.y + reference.height
			};
			break;
		case "right":
			coords = {
				x: reference.x + reference.width,
				y: commonY
			};
			break;
		case "left":
			coords = {
				x: reference.x - floating.width,
				y: commonY
			};
			break;
		default: coords = {
			x: reference.x,
			y: reference.y
		};
	}
	switch (getAlignment(placement)) {
		case "start":
			coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
			break;
		case "end":
			coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
			break;
	}
	return coords;
}
/**
* Computes the `x` and `y` coordinates that will place the floating element
* next to a given reference element.
*
* This export does not have any `platform` interface logic. You will need to
* write one for the platform you are using Floating UI with.
*/
var computePosition$1 = async (reference, floating, config) => {
	const { placement = "bottom", strategy = "absolute", middleware = [], platform: platform$1 } = config;
	const validMiddleware = middleware.filter(Boolean);
	const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(floating));
	let rects = await platform$1.getElementRects({
		reference,
		floating,
		strategy
	});
	let { x: x$9, y: y$9 } = computeCoordsFromPlacement(rects, placement, rtl);
	let statefulPlacement = placement;
	let middlewareData = {};
	let resetCount = 0;
	for (let i$15 = 0; i$15 < validMiddleware.length; i$15++) {
		const { name, fn } = validMiddleware[i$15];
		const { x: nextX, y: nextY, data, reset } = await fn({
			x: x$9,
			y: y$9,
			initialPlacement: placement,
			placement: statefulPlacement,
			strategy,
			middlewareData,
			rects,
			platform: platform$1,
			elements: {
				reference,
				floating
			}
		});
		x$9 = nextX != null ? nextX : x$9;
		y$9 = nextY != null ? nextY : y$9;
		middlewareData = {
			...middlewareData,
			[name]: {
				...middlewareData[name],
				...data
			}
		};
		if (reset && resetCount <= 50) {
			resetCount++;
			if (typeof reset === "object") {
				if (reset.placement) statefulPlacement = reset.placement;
				if (reset.rects) rects = reset.rects === true ? await platform$1.getElementRects({
					reference,
					floating,
					strategy
				}) : reset.rects;
				({x: x$9, y: y$9} = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
			}
			i$15 = -1;
		}
	}
	return {
		x: x$9,
		y: y$9,
		placement: statefulPlacement,
		strategy,
		middlewareData
	};
};
/**
* Resolves with an object of overflow side offsets that determine how much the
* element is overflowing a given clipping boundary on each side.
* - positive = overflowing the boundary by that number of pixels
* - negative = how many pixels left before it will overflow
* - 0 = lies flush with the boundary
* @see https://floating-ui.com/docs/detectOverflow
*/
async function detectOverflow$1(state, options) {
	var _await$platform$isEle;
	if (options === void 0) options = {};
	const { x: x$9, y: y$9, platform: platform$1, rects, elements, strategy } = state;
	const { boundary = "clippingAncestors", rootBoundary = "viewport", elementContext = "floating", altBoundary = false, padding = 0 } = evaluate(options, state);
	const paddingObject = getPaddingObject(padding);
	const element = elements[altBoundary ? elementContext === "floating" ? "reference" : "floating" : elementContext];
	const clippingClientRect = rectToClientRect(await platform$1.getClippingRect({
		element: ((_await$platform$isEle = await (platform$1.isElement == null ? void 0 : platform$1.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform$1.getDocumentElement == null ? void 0 : platform$1.getDocumentElement(elements.floating)),
		boundary,
		rootBoundary,
		strategy
	}));
	const rect = elementContext === "floating" ? {
		x: x$9,
		y: y$9,
		width: rects.floating.width,
		height: rects.floating.height
	} : rects.reference;
	const offsetParent = await (platform$1.getOffsetParent == null ? void 0 : platform$1.getOffsetParent(elements.floating));
	const offsetScale = await (platform$1.isElement == null ? void 0 : platform$1.isElement(offsetParent)) ? await (platform$1.getScale == null ? void 0 : platform$1.getScale(offsetParent)) || {
		x: 1,
		y: 1
	} : {
		x: 1,
		y: 1
	};
	const elementClientRect = rectToClientRect(platform$1.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform$1.convertOffsetParentRelativeRectToViewportRelativeRect({
		elements,
		rect,
		offsetParent,
		strategy
	}) : rect);
	return {
		top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
		bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
		left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
		right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
	};
}
/**
* Optimizes the visibility of the floating element by flipping the `placement`
* in order to keep it in view when the preferred placement(s) will overflow the
* clipping boundary. Alternative to `autoPlacement`.
* @see https://floating-ui.com/docs/flip
*/
var flip$2 = function(options) {
	if (options === void 0) options = {};
	return {
		name: "flip",
		options,
		async fn(state) {
			var _middlewareData$arrow, _middlewareData$flip;
			const { placement, middlewareData, rects, initialPlacement, platform: platform$1, elements } = state;
			const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = "bestFit", fallbackAxisSideDirection = "none", flipAlignment = true,...detectOverflowOptions } = evaluate(options, state);
			if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
			const side = getSide(placement);
			const initialSideAxis = getSideAxis(initialPlacement);
			const isBasePlacement = getSide(initialPlacement) === initialPlacement;
			const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating));
			const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
			const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
			if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
			const placements$1 = [initialPlacement, ...fallbackPlacements];
			const overflow = await detectOverflow$1(state, detectOverflowOptions);
			const overflows = [];
			let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
			if (checkMainAxis) overflows.push(overflow[side]);
			if (checkCrossAxis) {
				const sides$1 = getAlignmentSides(placement, rects, rtl);
				overflows.push(overflow[sides$1[0]], overflow[sides$1[1]]);
			}
			overflowsData = [...overflowsData, {
				placement,
				overflows
			}];
			if (!overflows.every((side$1) => side$1 <= 0)) {
				var _middlewareData$flip2, _overflowsData$filter;
				const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
				const nextPlacement = placements$1[nextIndex];
				if (nextPlacement) {
					if (!(checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false) || overflowsData.every((d$13) => getSideAxis(d$13.placement) === initialSideAxis ? d$13.overflows[0] > 0 : true)) return {
						data: {
							index: nextIndex,
							overflows: overflowsData
						},
						reset: { placement: nextPlacement }
					};
				}
				let resetPlacement = (_overflowsData$filter = overflowsData.filter((d$13) => d$13.overflows[0] <= 0).sort((a$27, b$13) => a$27.overflows[1] - b$13.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
				if (!resetPlacement) switch (fallbackStrategy) {
					case "bestFit": {
						var _overflowsData$filter2;
						const placement$1 = (_overflowsData$filter2 = overflowsData.filter((d$13) => {
							if (hasFallbackAxisSideDirection) {
								const currentSideAxis = getSideAxis(d$13.placement);
								return currentSideAxis === initialSideAxis || currentSideAxis === "y";
							}
							return true;
						}).map((d$13) => [d$13.placement, d$13.overflows.filter((overflow$1) => overflow$1 > 0).reduce((acc, overflow$1) => acc + overflow$1, 0)]).sort((a$27, b$13) => a$27[1] - b$13[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
						if (placement$1) resetPlacement = placement$1;
						break;
					}
					case "initialPlacement":
						resetPlacement = initialPlacement;
						break;
				}
				if (placement !== resetPlacement) return { reset: { placement: resetPlacement } };
			}
			return {};
		}
	};
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
	const { placement, platform: platform$1, elements } = state;
	const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating));
	const side = getSide(placement);
	const alignment = getAlignment(placement);
	const isVertical = getSideAxis(placement) === "y";
	const mainAxisMulti = originSides.has(side) ? -1 : 1;
	const crossAxisMulti = rtl && isVertical ? -1 : 1;
	const rawValue = evaluate(options, state);
	let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === "number" ? {
		mainAxis: rawValue,
		crossAxis: 0,
		alignmentAxis: null
	} : {
		mainAxis: rawValue.mainAxis || 0,
		crossAxis: rawValue.crossAxis || 0,
		alignmentAxis: rawValue.alignmentAxis
	};
	if (alignment && typeof alignmentAxis === "number") crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
	return isVertical ? {
		x: crossAxis * crossAxisMulti,
		y: mainAxis * mainAxisMulti
	} : {
		x: mainAxis * mainAxisMulti,
		y: crossAxis * crossAxisMulti
	};
}
/**
* Modifies the placement by translating the floating element along the
* specified axes.
* A number (shorthand for `mainAxis` or distance), or an axes configuration
* object may be passed.
* @see https://floating-ui.com/docs/offset
*/
var offset$2 = function(options) {
	if (options === void 0) options = 0;
	return {
		name: "offset",
		options,
		async fn(state) {
			var _middlewareData$offse, _middlewareData$arrow;
			const { x: x$9, y: y$9, placement, middlewareData } = state;
			const diffCoords = await convertValueToCoords(state, options);
			if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
			return {
				x: x$9 + diffCoords.x,
				y: y$9 + diffCoords.y,
				data: {
					...diffCoords,
					placement
				}
			};
		}
	};
};
/**
* Optimizes the visibility of the floating element by shifting it in order to
* keep it in view when it will overflow the clipping boundary.
* @see https://floating-ui.com/docs/shift
*/
var shift$2 = function(options) {
	if (options === void 0) options = {};
	return {
		name: "shift",
		options,
		async fn(state) {
			const { x: x$9, y: y$9, placement } = state;
			const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = { fn: (_ref) => {
				let { x: x$10, y: y$10 } = _ref;
				return {
					x: x$10,
					y: y$10
				};
			} },...detectOverflowOptions } = evaluate(options, state);
			const coords = {
				x: x$9,
				y: y$9
			};
			const overflow = await detectOverflow$1(state, detectOverflowOptions);
			const crossAxis = getSideAxis(getSide(placement));
			const mainAxis = getOppositeAxis(crossAxis);
			let mainAxisCoord = coords[mainAxis];
			let crossAxisCoord = coords[crossAxis];
			if (checkMainAxis) {
				const minSide = mainAxis === "y" ? "top" : "left";
				const maxSide = mainAxis === "y" ? "bottom" : "right";
				const min$1 = mainAxisCoord + overflow[minSide];
				const max$1 = mainAxisCoord - overflow[maxSide];
				mainAxisCoord = clamp(min$1, mainAxisCoord, max$1);
			}
			if (checkCrossAxis) {
				const minSide = crossAxis === "y" ? "top" : "left";
				const maxSide = crossAxis === "y" ? "bottom" : "right";
				const min$1 = crossAxisCoord + overflow[minSide];
				const max$1 = crossAxisCoord - overflow[maxSide];
				crossAxisCoord = clamp(min$1, crossAxisCoord, max$1);
			}
			const limitedCoords = limiter.fn({
				...state,
				[mainAxis]: mainAxisCoord,
				[crossAxis]: crossAxisCoord
			});
			return {
				...limitedCoords,
				data: {
					x: limitedCoords.x - x$9,
					y: limitedCoords.y - y$9,
					enabled: {
						[mainAxis]: checkMainAxis,
						[crossAxis]: checkCrossAxis
					}
				}
			};
		}
	};
};
/**
* Provides data that allows you to change the size of the floating element 
* for instance, prevent it from overflowing the clipping boundary or match the
* width of the reference element.
* @see https://floating-ui.com/docs/size
*/
var size$2 = function(options) {
	if (options === void 0) options = {};
	return {
		name: "size",
		options,
		async fn(state) {
			var _state$middlewareData, _state$middlewareData2;
			const { placement, rects, platform: platform$1, elements } = state;
			const { apply = () => {},...detectOverflowOptions } = evaluate(options, state);
			const overflow = await detectOverflow$1(state, detectOverflowOptions);
			const side = getSide(placement);
			const alignment = getAlignment(placement);
			const isYAxis = getSideAxis(placement) === "y";
			const { width, height } = rects.floating;
			let heightSide;
			let widthSide;
			if (side === "top" || side === "bottom") {
				heightSide = side;
				widthSide = alignment === (await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
			} else {
				widthSide = side;
				heightSide = alignment === "end" ? "top" : "bottom";
			}
			const maximumClippingHeight = height - overflow.top - overflow.bottom;
			const maximumClippingWidth = width - overflow.left - overflow.right;
			const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
			const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
			const noShift = !state.middlewareData.shift;
			let availableHeight = overflowAvailableHeight;
			let availableWidth = overflowAvailableWidth;
			if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) availableWidth = maximumClippingWidth;
			if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) availableHeight = maximumClippingHeight;
			if (noShift && !alignment) {
				const xMin = max(overflow.left, 0);
				const xMax = max(overflow.right, 0);
				const yMin = max(overflow.top, 0);
				const yMax = max(overflow.bottom, 0);
				if (isYAxis) availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
				else availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
			}
			await apply({
				...state,
				availableWidth,
				availableHeight
			});
			const nextDimensions = await platform$1.getDimensions(elements.floating);
			if (width !== nextDimensions.width || height !== nextDimensions.height) return { reset: { rects: true } };
			return {};
		}
	};
};

//#endregion
//#region node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
	const css = getComputedStyle$1(element);
	let width = parseFloat(css.width) || 0;
	let height = parseFloat(css.height) || 0;
	const hasOffset = isHTMLElement(element);
	const offsetWidth = hasOffset ? element.offsetWidth : width;
	const offsetHeight = hasOffset ? element.offsetHeight : height;
	const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
	if (shouldFallback) {
		width = offsetWidth;
		height = offsetHeight;
	}
	return {
		width,
		height,
		$: shouldFallback
	};
}
function unwrapElement(element) {
	return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
	const domElement = unwrapElement(element);
	if (!isHTMLElement(domElement)) return createCoords(1);
	const rect = domElement.getBoundingClientRect();
	const { width, height, $: $$5 } = getCssDimensions(domElement);
	let x$9 = ($$5 ? round(rect.width) : rect.width) / width;
	let y$9 = ($$5 ? round(rect.height) : rect.height) / height;
	if (!x$9 || !Number.isFinite(x$9)) x$9 = 1;
	if (!y$9 || !Number.isFinite(y$9)) y$9 = 1;
	return {
		x: x$9,
		y: y$9
	};
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
	const win = getWindow(element);
	if (!isWebKit() || !win.visualViewport) return noOffsets;
	return {
		x: win.visualViewport.offsetLeft,
		y: win.visualViewport.offsetTop
	};
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
	if (isFixed === void 0) isFixed = false;
	if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) return false;
	return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
	if (includeScale === void 0) includeScale = false;
	if (isFixedStrategy === void 0) isFixedStrategy = false;
	const clientRect = element.getBoundingClientRect();
	const domElement = unwrapElement(element);
	let scale = createCoords(1);
	if (includeScale) if (offsetParent) {
		if (isElement(offsetParent)) scale = getScale(offsetParent);
	} else scale = getScale(element);
	const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
	let x$9 = (clientRect.left + visualOffsets.x) / scale.x;
	let y$9 = (clientRect.top + visualOffsets.y) / scale.y;
	let width = clientRect.width / scale.x;
	let height = clientRect.height / scale.y;
	if (domElement) {
		const win = getWindow(domElement);
		const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
		let currentWin = win;
		let currentIFrame = getFrameElement(currentWin);
		while (currentIFrame && offsetParent && offsetWin !== currentWin) {
			const iframeScale = getScale(currentIFrame);
			const iframeRect = currentIFrame.getBoundingClientRect();
			const css = getComputedStyle$1(currentIFrame);
			const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
			const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
			x$9 *= iframeScale.x;
			y$9 *= iframeScale.y;
			width *= iframeScale.x;
			height *= iframeScale.y;
			x$9 += left;
			y$9 += top;
			currentWin = getWindow(currentIFrame);
			currentIFrame = getFrameElement(currentWin);
		}
	}
	return rectToClientRect({
		width,
		height,
		x: x$9,
		y: y$9
	});
}
function getWindowScrollBarX(element, rect) {
	const leftScroll = getNodeScroll(element).scrollLeft;
	if (!rect) return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
	return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
	const htmlRect = documentElement.getBoundingClientRect();
	const x$9 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
	const y$9 = htmlRect.top + scroll.scrollTop;
	return {
		x: x$9,
		y: y$9
	};
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
	let { elements, rect, offsetParent, strategy } = _ref;
	const isFixed = strategy === "fixed";
	const documentElement = getDocumentElement(offsetParent);
	const topLayer = elements ? isTopLayer(elements.floating) : false;
	if (offsetParent === documentElement || topLayer && isFixed) return rect;
	let scroll = {
		scrollLeft: 0,
		scrollTop: 0
	};
	let scale = createCoords(1);
	const offsets = createCoords(0);
	const isOffsetParentAnElement = isHTMLElement(offsetParent);
	if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
		if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) scroll = getNodeScroll(offsetParent);
		if (isHTMLElement(offsetParent)) {
			const offsetRect = getBoundingClientRect(offsetParent);
			scale = getScale(offsetParent);
			offsets.x = offsetRect.x + offsetParent.clientLeft;
			offsets.y = offsetRect.y + offsetParent.clientTop;
		}
	}
	const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
	return {
		width: rect.width * scale.x,
		height: rect.height * scale.y,
		x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
		y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
	};
}
function getClientRects(element) {
	return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
	const html = getDocumentElement(element);
	const scroll = getNodeScroll(element);
	const body = element.ownerDocument.body;
	const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
	const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
	let x$9 = -scroll.scrollLeft + getWindowScrollBarX(element);
	const y$9 = -scroll.scrollTop;
	if (getComputedStyle$1(body).direction === "rtl") x$9 += max(html.clientWidth, body.clientWidth) - width;
	return {
		width,
		height,
		x: x$9,
		y: y$9
	};
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
	const win = getWindow(element);
	const html = getDocumentElement(element);
	const visualViewport = win.visualViewport;
	let width = html.clientWidth;
	let height = html.clientHeight;
	let x$9 = 0;
	let y$9 = 0;
	if (visualViewport) {
		width = visualViewport.width;
		height = visualViewport.height;
		const visualViewportBased = isWebKit();
		if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
			x$9 = visualViewport.offsetLeft;
			y$9 = visualViewport.offsetTop;
		}
	}
	const windowScrollbarX = getWindowScrollBarX(html);
	if (windowScrollbarX <= 0) {
		const doc = html.ownerDocument;
		const body = doc.body;
		const bodyStyles = getComputedStyle(body);
		const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
		const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
		if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) width -= clippingStableScrollbarWidth;
	} else if (windowScrollbarX <= SCROLLBAR_MAX) width += windowScrollbarX;
	return {
		width,
		height,
		x: x$9,
		y: y$9
	};
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
	const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
	const top = clientRect.top + element.clientTop;
	const left = clientRect.left + element.clientLeft;
	const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
	const width = element.clientWidth * scale.x;
	const height = element.clientHeight * scale.y;
	const x$9 = left * scale.x;
	const y$9 = top * scale.y;
	return {
		width,
		height,
		x: x$9,
		y: y$9
	};
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
	let rect;
	if (clippingAncestor === "viewport") rect = getViewportRect(element, strategy);
	else if (clippingAncestor === "document") rect = getDocumentRect(getDocumentElement(element));
	else if (isElement(clippingAncestor)) rect = getInnerBoundingClientRect(clippingAncestor, strategy);
	else {
		const visualOffsets = getVisualOffsets(element);
		rect = {
			x: clippingAncestor.x - visualOffsets.x,
			y: clippingAncestor.y - visualOffsets.y,
			width: clippingAncestor.width,
			height: clippingAncestor.height
		};
	}
	return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
	const parentNode = getParentNode(element);
	if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) return false;
	return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
	const cachedResult = cache.get(element);
	if (cachedResult) return cachedResult;
	let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
	let currentContainingBlockComputedStyle = null;
	const elementIsFixed = getComputedStyle$1(element).position === "fixed";
	let currentNode = elementIsFixed ? getParentNode(element) : element;
	while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
		const computedStyle = getComputedStyle$1(currentNode);
		const currentNodeIsContaining = isContainingBlock(currentNode);
		if (!currentNodeIsContaining && computedStyle.position === "fixed") currentContainingBlockComputedStyle = null;
		if (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) result = result.filter((ancestor) => ancestor !== currentNode);
		else currentContainingBlockComputedStyle = computedStyle;
		currentNode = getParentNode(currentNode);
	}
	cache.set(element, result);
	return result;
}
function getClippingRect(_ref) {
	let { element, boundary, rootBoundary, strategy } = _ref;
	const clippingAncestors = [...boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary), rootBoundary];
	const firstClippingAncestor = clippingAncestors[0];
	const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
		const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
		accRect.top = max(rect.top, accRect.top);
		accRect.right = min(rect.right, accRect.right);
		accRect.bottom = min(rect.bottom, accRect.bottom);
		accRect.left = max(rect.left, accRect.left);
		return accRect;
	}, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
	return {
		width: clippingRect.right - clippingRect.left,
		height: clippingRect.bottom - clippingRect.top,
		x: clippingRect.left,
		y: clippingRect.top
	};
}
function getDimensions(element) {
	const { width, height } = getCssDimensions(element);
	return {
		width,
		height
	};
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
	const isOffsetParentAnElement = isHTMLElement(offsetParent);
	const documentElement = getDocumentElement(offsetParent);
	const isFixed = strategy === "fixed";
	const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
	let scroll = {
		scrollLeft: 0,
		scrollTop: 0
	};
	const offsets = createCoords(0);
	function setLeftRTLScrollbarOffset() {
		offsets.x = getWindowScrollBarX(documentElement);
	}
	if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
		if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) scroll = getNodeScroll(offsetParent);
		if (isOffsetParentAnElement) {
			const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
			offsets.x = offsetRect.x + offsetParent.clientLeft;
			offsets.y = offsetRect.y + offsetParent.clientTop;
		} else if (documentElement) setLeftRTLScrollbarOffset();
	}
	if (isFixed && !isOffsetParentAnElement && documentElement) setLeftRTLScrollbarOffset();
	const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
	const x$9 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
	const y$9 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
	return {
		x: x$9,
		y: y$9,
		width: rect.width,
		height: rect.height
	};
}
function isStaticPositioned(element) {
	return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
	if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") return null;
	if (polyfill) return polyfill(element);
	let rawOffsetParent = element.offsetParent;
	if (getDocumentElement(element) === rawOffsetParent) rawOffsetParent = rawOffsetParent.ownerDocument.body;
	return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
	const win = getWindow(element);
	if (isTopLayer(element)) return win;
	if (!isHTMLElement(element)) {
		let svgOffsetParent = getParentNode(element);
		while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
			if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) return svgOffsetParent;
			svgOffsetParent = getParentNode(svgOffsetParent);
		}
		return win;
	}
	let offsetParent = getTrueOffsetParent(element, polyfill);
	while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) offsetParent = getTrueOffsetParent(offsetParent, polyfill);
	if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) return win;
	return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
	const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
	const getDimensionsFn = this.getDimensions;
	const floatingDimensions = await getDimensionsFn(data.floating);
	return {
		reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
		floating: {
			x: 0,
			y: 0,
			width: floatingDimensions.width,
			height: floatingDimensions.height
		}
	};
};
function isRTL(element) {
	return getComputedStyle$1(element).direction === "rtl";
}
var platform = {
	convertOffsetParentRelativeRectToViewportRelativeRect,
	getDocumentElement,
	getClippingRect,
	getOffsetParent,
	getElementRects,
	getClientRects,
	getDimensions,
	getScale,
	isElement,
	isRTL
};
function rectsAreEqual(a$27, b$13) {
	return a$27.x === b$13.x && a$27.y === b$13.y && a$27.width === b$13.width && a$27.height === b$13.height;
}
function observeMove(element, onMove) {
	let io = null;
	let timeoutId;
	const root = getDocumentElement(element);
	function cleanup() {
		var _io;
		clearTimeout(timeoutId);
		(_io = io) == null || _io.disconnect();
		io = null;
	}
	function refresh(skip, threshold) {
		if (skip === void 0) skip = false;
		if (threshold === void 0) threshold = 1;
		cleanup();
		const elementRectForRootMargin = element.getBoundingClientRect();
		const { left, top, width, height } = elementRectForRootMargin;
		if (!skip) onMove();
		if (!width || !height) return;
		const insetTop = floor(top);
		const insetRight = floor(root.clientWidth - (left + width));
		const insetBottom = floor(root.clientHeight - (top + height));
		const insetLeft = floor(left);
		const options = {
			rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
			threshold: max(0, min(1, threshold)) || 1
		};
		let isFirstUpdate = true;
		function handleObserve(entries) {
			const ratio = entries[0].intersectionRatio;
			if (ratio !== threshold) {
				if (!isFirstUpdate) return refresh();
				if (!ratio) timeoutId = setTimeout(() => {
					refresh(false, 1e-7);
				}, 1e3);
				else refresh(false, ratio);
			}
			if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) refresh();
			isFirstUpdate = false;
		}
		try {
			io = new IntersectionObserver(handleObserve, {
				...options,
				root: root.ownerDocument
			});
		} catch (_e$3) {
			io = new IntersectionObserver(handleObserve, options);
		}
		io.observe(element);
	}
	refresh(true);
	return cleanup;
}
/**
* Automatically updates the position of the floating element when necessary.
* Should only be called when the floating element is mounted on the DOM or
* visible on the screen.
* @returns cleanup function that should be invoked when the floating element is
* removed from the DOM or hidden from the screen.
* @see https://floating-ui.com/docs/autoUpdate
*/
function autoUpdate(reference, floating, update, options) {
	if (options === void 0) options = {};
	const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === "function", layoutShift = typeof IntersectionObserver === "function", animationFrame = false } = options;
	const referenceEl = unwrapElement(reference);
	const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
	ancestors.forEach((ancestor) => {
		ancestorScroll && ancestor.addEventListener("scroll", update, { passive: true });
		ancestorResize && ancestor.addEventListener("resize", update);
	});
	const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
	let reobserveFrame = -1;
	let resizeObserver = null;
	if (elementResize) {
		resizeObserver = new ResizeObserver((_ref) => {
			let [firstEntry] = _ref;
			if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
				resizeObserver.unobserve(floating);
				cancelAnimationFrame(reobserveFrame);
				reobserveFrame = requestAnimationFrame(() => {
					var _resizeObserver;
					(_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
				});
			}
			update();
		});
		if (referenceEl && !animationFrame) resizeObserver.observe(referenceEl);
		resizeObserver.observe(floating);
	}
	let frameId;
	let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
	if (animationFrame) frameLoop();
	function frameLoop() {
		const nextRefRect = getBoundingClientRect(reference);
		if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) update();
		prevRefRect = nextRefRect;
		frameId = requestAnimationFrame(frameLoop);
	}
	update();
	return () => {
		var _resizeObserver2;
		ancestors.forEach((ancestor) => {
			ancestorScroll && ancestor.removeEventListener("scroll", update);
			ancestorResize && ancestor.removeEventListener("resize", update);
		});
		cleanupIo?.();
		(_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
		resizeObserver = null;
		if (animationFrame) cancelAnimationFrame(frameId);
	};
}
/**
* Resolves with an object of overflow side offsets that determine how much the
* element is overflowing a given clipping boundary on each side.
* - positive = overflowing the boundary by that number of pixels
* - negative = how many pixels left before it will overflow
* - 0 = lies flush with the boundary
* @see https://floating-ui.com/docs/detectOverflow
*/
var detectOverflow = detectOverflow$1;
/**
* Modifies the placement by translating the floating element along the
* specified axes.
* A number (shorthand for `mainAxis` or distance), or an axes configuration
* object may be passed.
* @see https://floating-ui.com/docs/offset
*/
var offset$1 = offset$2;
/**
* Optimizes the visibility of the floating element by shifting it in order to
* keep it in view when it will overflow the clipping boundary.
* @see https://floating-ui.com/docs/shift
*/
var shift$1 = shift$2;
/**
* Optimizes the visibility of the floating element by flipping the `placement`
* in order to keep it in view when the preferred placement(s) will overflow the
* clipping boundary. Alternative to `autoPlacement`.
* @see https://floating-ui.com/docs/flip
*/
var flip$1 = flip$2;
/**
* Provides data that allows you to change the size of the floating element 
* for instance, prevent it from overflowing the clipping boundary or match the
* width of the reference element.
* @see https://floating-ui.com/docs/size
*/
var size$1 = size$2;
/**
* Computes the `x` and `y` coordinates that will place the floating element
* next to a given reference element.
*/
var computePosition = (reference, floating, options) => {
	const cache = /* @__PURE__ */ new Map();
	const mergedOptions = {
		platform,
		...options
	};
	const platformWithCache = {
		...mergedOptions.platform,
		_c: cache
	};
	return computePosition$1(reference, floating, {
		...mergedOptions,
		platform: platformWithCache
	});
};

//#endregion
//#region node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var import_react_dom$5 = /* @__PURE__ */ __toESM(require_react_dom(), 1);
var index$1 = typeof document !== "undefined" ? import_react.useLayoutEffect : function noop() {};
function deepEqual(a$27, b$13) {
	if (a$27 === b$13) return true;
	if (typeof a$27 !== typeof b$13) return false;
	if (typeof a$27 === "function" && a$27.toString() === b$13.toString()) return true;
	let length;
	let i$15;
	let keys;
	if (a$27 && b$13 && typeof a$27 === "object") {
		if (Array.isArray(a$27)) {
			length = a$27.length;
			if (length !== b$13.length) return false;
			for (i$15 = length; i$15-- !== 0;) if (!deepEqual(a$27[i$15], b$13[i$15])) return false;
			return true;
		}
		keys = Object.keys(a$27);
		length = keys.length;
		if (length !== Object.keys(b$13).length) return false;
		for (i$15 = length; i$15-- !== 0;) if (!{}.hasOwnProperty.call(b$13, keys[i$15])) return false;
		for (i$15 = length; i$15-- !== 0;) {
			const key = keys[i$15];
			if (key === "_owner" && a$27.$$typeof) continue;
			if (!deepEqual(a$27[key], b$13[key])) return false;
		}
		return true;
	}
	return a$27 !== a$27 && b$13 !== b$13;
}
function getDPR(element) {
	if (typeof window === "undefined") return 1;
	return (element.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(element, value) {
	const dpr = getDPR(element);
	return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
	const ref = import_react.useRef(value);
	index$1(() => {
		ref.current = value;
	});
	return ref;
}
/**
* Provides data to position a floating element.
* @see https://floating-ui.com/docs/useFloating
*/
function useFloating$1(options) {
	if (options === void 0) options = {};
	const { placement = "bottom", strategy = "absolute", middleware = [], platform: platform$1, elements: { reference: externalReference, floating: externalFloating } = {}, transform = true, whileElementsMounted, open } = options;
	const [data, setData] = import_react.useState({
		x: 0,
		y: 0,
		strategy,
		placement,
		middlewareData: {},
		isPositioned: false
	});
	const [latestMiddleware, setLatestMiddleware] = import_react.useState(middleware);
	if (!deepEqual(latestMiddleware, middleware)) setLatestMiddleware(middleware);
	const [_reference, _setReference] = import_react.useState(null);
	const [_floating, _setFloating] = import_react.useState(null);
	const setReference = import_react.useCallback((node) => {
		if (node !== referenceRef.current) {
			referenceRef.current = node;
			_setReference(node);
		}
	}, []);
	const setFloating = import_react.useCallback((node) => {
		if (node !== floatingRef.current) {
			floatingRef.current = node;
			_setFloating(node);
		}
	}, []);
	const referenceEl = externalReference || _reference;
	const floatingEl = externalFloating || _floating;
	const referenceRef = import_react.useRef(null);
	const floatingRef = import_react.useRef(null);
	const dataRef = import_react.useRef(data);
	const hasWhileElementsMounted = whileElementsMounted != null;
	const whileElementsMountedRef = useLatestRef(whileElementsMounted);
	const platformRef = useLatestRef(platform$1);
	const openRef = useLatestRef(open);
	const update = import_react.useCallback(() => {
		if (!referenceRef.current || !floatingRef.current) return;
		const config = {
			placement,
			strategy,
			middleware: latestMiddleware
		};
		if (platformRef.current) config.platform = platformRef.current;
		computePosition(referenceRef.current, floatingRef.current, config).then((data$1) => {
			const fullData = {
				...data$1,
				isPositioned: openRef.current !== false
			};
			if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
				dataRef.current = fullData;
				import_react_dom$5.flushSync(() => {
					setData(fullData);
				});
			}
		});
	}, [
		latestMiddleware,
		placement,
		strategy,
		platformRef,
		openRef
	]);
	index$1(() => {
		if (open === false && dataRef.current.isPositioned) {
			dataRef.current.isPositioned = false;
			setData((data$1) => ({
				...data$1,
				isPositioned: false
			}));
		}
	}, [open]);
	const isMountedRef = import_react.useRef(false);
	index$1(() => {
		isMountedRef.current = true;
		return () => {
			isMountedRef.current = false;
		};
	}, []);
	index$1(() => {
		if (referenceEl) referenceRef.current = referenceEl;
		if (floatingEl) floatingRef.current = floatingEl;
		if (referenceEl && floatingEl) {
			if (whileElementsMountedRef.current) return whileElementsMountedRef.current(referenceEl, floatingEl, update);
			update();
		}
	}, [
		referenceEl,
		floatingEl,
		update,
		whileElementsMountedRef,
		hasWhileElementsMounted
	]);
	const refs = import_react.useMemo(() => ({
		reference: referenceRef,
		floating: floatingRef,
		setReference,
		setFloating
	}), [setReference, setFloating]);
	const elements = import_react.useMemo(() => ({
		reference: referenceEl,
		floating: floatingEl
	}), [referenceEl, floatingEl]);
	const floatingStyles = import_react.useMemo(() => {
		const initialStyles = {
			position: strategy,
			left: 0,
			top: 0
		};
		if (!elements.floating) return initialStyles;
		const x$9 = roundByDPR(elements.floating, data.x);
		const y$9 = roundByDPR(elements.floating, data.y);
		if (transform) return {
			...initialStyles,
			transform: "translate(" + x$9 + "px, " + y$9 + "px)",
			...getDPR(elements.floating) >= 1.5 && { willChange: "transform" }
		};
		return {
			position: strategy,
			left: x$9,
			top: y$9
		};
	}, [
		strategy,
		transform,
		elements.floating,
		data.x,
		data.y
	]);
	return import_react.useMemo(() => ({
		...data,
		update,
		refs,
		elements,
		floatingStyles
	}), [
		data,
		update,
		refs,
		elements,
		floatingStyles
	]);
}
/**
* Modifies the placement by translating the floating element along the
* specified axes.
* A number (shorthand for `mainAxis` or distance), or an axes configuration
* object may be passed.
* @see https://floating-ui.com/docs/offset
*/
var offset = (options, deps) => ({
	...offset$1(options),
	options: [options, deps]
});
/**
* Optimizes the visibility of the floating element by shifting it in order to
* keep it in view when it will overflow the clipping boundary.
* @see https://floating-ui.com/docs/shift
*/
var shift = (options, deps) => ({
	...shift$1(options),
	options: [options, deps]
});
/**
* Optimizes the visibility of the floating element by flipping the `placement`
* in order to keep it in view when the preferred placement(s) will overflow the
* clipping boundary. Alternative to `autoPlacement`.
* @see https://floating-ui.com/docs/flip
*/
var flip = (options, deps) => ({
	...flip$1(options),
	options: [options, deps]
});
/**
* Provides data that allows you to change the size of the floating element 
* for instance, prevent it from overflowing the clipping boundary or match the
* width of the reference element.
* @see https://floating-ui.com/docs/size
*/
var size = (options, deps) => ({
	...size$1(options),
	options: [options, deps]
});

//#endregion
//#region node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var import_react_dom$4 = /* @__PURE__ */ __toESM(require_react_dom(), 1);
var SafeReact = { ...import_react };
var useSafeInsertionEffect = SafeReact.useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
	const ref = import_react.useRef(() => {
		throw new Error("Cannot call an event handler while rendering.");
	});
	useSafeInsertionEffect(() => {
		ref.current = callback;
	});
	return import_react.useCallback(function() {
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		return ref.current == null ? void 0 : ref.current(...args);
	}, []);
}
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var index = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
var horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
var verticalKeys = [ARROW_UP, ARROW_DOWN];
var allKeys = [...horizontalKeys, ...verticalKeys];
var serverHandoffComplete = false;
var count = 0;
var genId = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++;
function useFloatingId() {
	const [id, setId] = import_react.useState(() => serverHandoffComplete ? genId() : void 0);
	index(() => {
		if (id == null) setId(genId());
	}, []);
	import_react.useEffect(() => {
		serverHandoffComplete = true;
	}, []);
	return id;
}
/**
* Uses React 18's built-in `useId()` when available, or falls back to a
* slightly less performant (requiring a double render) implementation for
* earlier React versions.
* @see https://floating-ui.com/docs/react-utils#useid
*/
var useId = SafeReact.useId || useFloatingId;
var devMessageSet;
devMessageSet = /* @__PURE__ */ new Set();
function warn() {
	var _devMessageSet;
	for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) messages[_key] = arguments[_key];
	const message = "Floating UI: " + messages.join(" ");
	if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
		var _devMessageSet2;
		(_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
		console.warn(message);
	}
}
function error() {
	var _devMessageSet3;
	for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) messages[_key2] = arguments[_key2];
	const message = "Floating UI: " + messages.join(" ");
	if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
		var _devMessageSet4;
		(_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
		console.error(message);
	}
}
function createPubSub() {
	const map = /* @__PURE__ */ new Map();
	return {
		emit(event, data) {
			var _map$get;
			(_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
		},
		on(event, listener) {
			map.set(event, [...map.get(event) || [], listener]);
		},
		off(event, listener) {
			var _map$get2;
			map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l$17) => l$17 !== listener)) || []);
		}
	};
}
var FloatingNodeContext = /* @__PURE__ */ import_react.createContext(null);
var FloatingTreeContext = /* @__PURE__ */ import_react.createContext(null);
/**
* Returns the parent node id for nested floating elements, if available.
* Returns `null` for top-level floating elements.
*/
var useFloatingParentNodeId = () => {
	var _React$useContext;
	return ((_React$useContext = import_react.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
/**
* Returns the nearest floating tree context, if available.
*/
var useFloatingTree = () => import_react.useContext(FloatingTreeContext);
var FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function useFloatingRootContext(options) {
	const { open = false, onOpenChange: onOpenChangeProp, elements: elementsProp } = options;
	const floatingId = useId();
	const dataRef = import_react.useRef({});
	const [events] = import_react.useState(() => createPubSub());
	const nested = useFloatingParentNodeId() != null;
	{
		const optionDomReference = elementsProp.reference;
		if (optionDomReference && !isElement(optionDomReference)) error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
	}
	const [positionReference, setPositionReference] = import_react.useState(elementsProp.reference);
	const onOpenChange = useEffectEvent((open$1, event, reason) => {
		dataRef.current.openEvent = open$1 ? event : void 0;
		events.emit("openchange", {
			open: open$1,
			event,
			reason,
			nested
		});
		onOpenChangeProp?.(open$1, event, reason);
	});
	const refs = import_react.useMemo(() => ({ setPositionReference }), []);
	const elements = import_react.useMemo(() => ({
		reference: positionReference || elementsProp.reference || null,
		floating: elementsProp.floating || null,
		domReference: elementsProp.reference
	}), [
		positionReference,
		elementsProp.reference,
		elementsProp.floating
	]);
	return import_react.useMemo(() => ({
		dataRef,
		open,
		onOpenChange,
		elements,
		events,
		floatingId,
		refs
	}), [
		open,
		onOpenChange,
		elements,
		events,
		floatingId,
		refs
	]);
}
/**
* Provides data to position a floating element and context to add interactions.
* @see https://floating-ui.com/docs/useFloating
*/
function useFloating(options) {
	if (options === void 0) options = {};
	const { nodeId } = options;
	const internalRootContext = useFloatingRootContext({
		...options,
		elements: {
			reference: null,
			floating: null,
			...options.elements
		}
	});
	const rootContext = options.rootContext || internalRootContext;
	const computedElements = rootContext.elements;
	const [_domReference, setDomReference] = import_react.useState(null);
	const [positionReference, _setPositionReference] = import_react.useState(null);
	const domReference = (computedElements == null ? void 0 : computedElements.domReference) || _domReference;
	const domReferenceRef = import_react.useRef(null);
	const tree = useFloatingTree();
	index(() => {
		if (domReference) domReferenceRef.current = domReference;
	}, [domReference]);
	const position = useFloating$1({
		...options,
		elements: {
			...computedElements,
			...positionReference && { reference: positionReference }
		}
	});
	const setPositionReference = import_react.useCallback((node) => {
		const computedPositionReference = isElement(node) ? {
			getBoundingClientRect: () => node.getBoundingClientRect(),
			contextElement: node
		} : node;
		_setPositionReference(computedPositionReference);
		position.refs.setReference(computedPositionReference);
	}, [position.refs]);
	const setReference = import_react.useCallback((node) => {
		if (isElement(node) || node === null) {
			domReferenceRef.current = node;
			setDomReference(node);
		}
		if (isElement(position.refs.reference.current) || position.refs.reference.current === null || node !== null && !isElement(node)) position.refs.setReference(node);
	}, [position.refs]);
	const refs = import_react.useMemo(() => ({
		...position.refs,
		setReference,
		setPositionReference,
		domReference: domReferenceRef
	}), [
		position.refs,
		setReference,
		setPositionReference
	]);
	const elements = import_react.useMemo(() => ({
		...position.elements,
		domReference
	}), [position.elements, domReference]);
	const context = import_react.useMemo(() => ({
		...position,
		...rootContext,
		refs,
		elements,
		nodeId
	}), [
		position,
		refs,
		elements,
		nodeId,
		rootContext
	]);
	index(() => {
		rootContext.dataRef.current.floatingContext = context;
		const node = tree == null ? void 0 : tree.nodesRef.current.find((node$1) => node$1.id === nodeId);
		if (node) node.context = context;
	});
	return import_react.useMemo(() => ({
		...position,
		context,
		refs,
		elements
	}), [
		position,
		refs,
		elements,
		context
	]);
}
var ACTIVE_KEY = "active";
var SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
	const map = /* @__PURE__ */ new Map();
	const isItem = elementKey === "item";
	let domUserProps = userProps;
	if (isItem && userProps) {
		const { [ACTIVE_KEY]: _$10, [SELECTED_KEY]: __,...validProps } = userProps;
		domUserProps = validProps;
	}
	return {
		...elementKey === "floating" && {
			tabIndex: -1,
			[FOCUSABLE_ATTRIBUTE]: ""
		},
		...domUserProps,
		...propsList.map((value) => {
			const propsOrGetProps = value ? value[elementKey] : null;
			if (typeof propsOrGetProps === "function") return userProps ? propsOrGetProps(userProps) : null;
			return propsOrGetProps;
		}).concat(userProps).reduce((acc, props) => {
			if (!props) return acc;
			Object.entries(props).forEach((_ref) => {
				let [key, value] = _ref;
				if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) return;
				if (key.indexOf("on") === 0) {
					if (!map.has(key)) map.set(key, []);
					if (typeof value === "function") {
						var _map$get;
						(_map$get = map.get(key)) == null || _map$get.push(value);
						acc[key] = function() {
							var _map$get2;
							for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
							return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
						};
					}
				} else acc[key] = value;
			});
			return acc;
		}, {})
	};
}
/**
* Merges an array of interaction hooks' props into prop getters, allowing
* event handler functions to be composed together without overwriting one
* another.
* @see https://floating-ui.com/docs/useInteractions
*/
function useInteractions(propsList) {
	if (propsList === void 0) propsList = [];
	const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
	const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
	const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
	const getReferenceProps = import_react.useCallback((userProps) => mergeProps(userProps, propsList, "reference"), referenceDeps);
	const getFloatingProps = import_react.useCallback((userProps) => mergeProps(userProps, propsList, "floating"), floatingDeps);
	const getItemProps = import_react.useCallback((userProps) => mergeProps(userProps, propsList, "item"), itemDeps);
	return import_react.useMemo(() => ({
		getReferenceProps,
		getFloatingProps,
		getItemProps
	}), [
		getReferenceProps,
		getFloatingProps,
		getItemProps
	]);
}
function getArgsWithCustomFloatingHeight(state, height) {
	return {
		...state,
		rects: {
			...state.rects,
			floating: {
				...state.rects.floating,
				height
			}
		}
	};
}
/**
* Positions the floating element such that an inner element inside of it is
* anchored to the reference element.
* @see https://floating-ui.com/docs/inner
*/
var inner = (props) => ({
	name: "inner",
	options: props,
	async fn(state) {
		const { listRef, overflowRef, onFallbackChange, offset: innerOffset = 0, index: index$2 = 0, minItemsVisible = 4, referenceOverflowThreshold = 0, scrollRef,...detectOverflowOptions } = evaluate(props, state);
		const { rects, elements: { floating } } = state;
		const item = listRef.current[index$2];
		const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;
		const clientTop = floating.clientTop || scrollEl.clientTop;
		const floatingIsBordered = floating.clientTop !== 0;
		const scrollElIsBordered = scrollEl.clientTop !== 0;
		const floatingIsScrollEl = floating === scrollEl;
		if (!state.placement.startsWith("bottom")) warn("`placement` side must be \"bottom\" when using the `inner`", "middleware.");
		if (!item) return {};
		const nextArgs = {
			...state,
			...await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)
		};
		const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);
		const refOverflow = await detectOverflow(nextArgs, {
			...detectOverflowOptions,
			elementContext: "reference"
		});
		const diffY = max(0, overflow.top);
		const nextY = nextArgs.y + diffY;
		const maxHeight = (scrollEl.scrollHeight > scrollEl.clientHeight ? (v$10) => v$10 : round)(max(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - max(0, overflow.bottom)));
		scrollEl.style.maxHeight = maxHeight + "px";
		scrollEl.scrollTop = diffY;
		if (onFallbackChange) {
			const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * min(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;
			import_react_dom$4.flushSync(() => onFallbackChange(shouldFallback));
		}
		if (overflowRef) overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({
			...nextArgs,
			y: nextY
		}, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);
		return { y: nextY };
	}
});
/**
* Changes the `inner` middleware's `offset` upon a `wheel` event to
* expand the floating element's height, revealing more list items.
* @see https://floating-ui.com/docs/inner
*/
function useInnerOffset(context, props) {
	const { open, elements } = context;
	const { enabled = true, overflowRef, scrollRef, onChange: unstable_onChange } = props;
	const onChange = useEffectEvent(unstable_onChange);
	const controlledScrollingRef = import_react.useRef(false);
	const prevScrollTopRef = import_react.useRef(null);
	const initialOverflowRef = import_react.useRef(null);
	import_react.useEffect(() => {
		if (!enabled) return;
		function onWheel(e$8) {
			if (e$8.ctrlKey || !el || overflowRef.current == null) return;
			const dY = e$8.deltaY;
			const isAtTop = overflowRef.current.top >= -.5;
			const isAtBottom = overflowRef.current.bottom >= -.5;
			const remainingScroll = el.scrollHeight - el.clientHeight;
			const sign = dY < 0 ? -1 : 1;
			const method = dY < 0 ? "max" : "min";
			if (el.scrollHeight <= el.clientHeight) return;
			if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {
				e$8.preventDefault();
				import_react_dom$4.flushSync(() => {
					onChange((d$13) => d$13 + Math[method](dY, remainingScroll * sign));
				});
			} else if (/firefox/i.test(getUserAgent())) el.scrollTop += dY;
		}
		const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
		if (open && el) {
			el.addEventListener("wheel", onWheel);
			requestAnimationFrame(() => {
				prevScrollTopRef.current = el.scrollTop;
				if (overflowRef.current != null) initialOverflowRef.current = { ...overflowRef.current };
			});
			return () => {
				prevScrollTopRef.current = null;
				initialOverflowRef.current = null;
				el.removeEventListener("wheel", onWheel);
			};
		}
	}, [
		enabled,
		open,
		elements.floating,
		overflowRef,
		scrollRef,
		onChange
	]);
	const floating = import_react.useMemo(() => ({
		onKeyDown() {
			controlledScrollingRef.current = true;
		},
		onWheel() {
			controlledScrollingRef.current = false;
		},
		onPointerMove() {
			controlledScrollingRef.current = false;
		},
		onScroll() {
			const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
			if (!overflowRef.current || !el || !controlledScrollingRef.current) return;
			if (prevScrollTopRef.current !== null) {
				const scrollDiff = el.scrollTop - prevScrollTopRef.current;
				if (overflowRef.current.bottom < -.5 && scrollDiff < -1 || overflowRef.current.top < -.5 && scrollDiff > 1) import_react_dom$4.flushSync(() => onChange((d$13) => d$13 + scrollDiff));
			}
			requestAnimationFrame(() => {
				prevScrollTopRef.current = el.scrollTop;
			});
		}
	}), [
		elements.floating,
		onChange,
		overflowRef,
		scrollRef
	]);
	return import_react.useMemo(() => enabled ? { floating } : {}, [enabled, floating]);
}

//#endregion
//#region node_modules/@headlessui/react/dist/internal/floating.js
var y$7 = (0, import_react.createContext)({
	styles: void 0,
	setReference: () => {},
	setFloating: () => {},
	getReferenceProps: () => ({}),
	getFloatingProps: () => ({}),
	slot: {}
});
y$7.displayName = "FloatingContext";
var $$3 = (0, import_react.createContext)(null);
$$3.displayName = "PlacementContext";
function ye(e$8) {
	return (0, import_react.useMemo)(() => e$8 ? typeof e$8 == "string" ? { to: e$8 } : e$8 : null, [e$8]);
}
function Fe$3() {
	return (0, import_react.useContext)(y$7).setReference;
}
function be() {
	return (0, import_react.useContext)(y$7).getReferenceProps;
}
function Te() {
	let { getFloatingProps: e$8, slot: t$12 } = (0, import_react.useContext)(y$7);
	return (0, import_react.useCallback)((...n$16) => Object.assign({}, e$8(...n$16), { "data-anchor": t$12.anchor }), [e$8, t$12]);
}
function Re$1(e$8 = null) {
	e$8 === !1 && (e$8 = null), typeof e$8 == "string" && (e$8 = { to: e$8 });
	let t$12 = (0, import_react.useContext)($$3), n$16 = (0, import_react.useMemo)(() => e$8, [JSON.stringify(e$8, (l$17, o$19) => {
		var u$24;
		return (u$24 = o$19 == null ? void 0 : o$19.outerHTML) != null ? u$24 : o$19;
	})]);
	n$1(() => {
		t$12?.(n$16 != null ? n$16 : null);
	}, [t$12, n$16]);
	let r$20 = (0, import_react.useContext)(y$7);
	return (0, import_react.useMemo)(() => [r$20.setFloating, e$8 ? r$20.styles : {}], [
		r$20.setFloating,
		e$8,
		r$20.styles
	]);
}
var D$6 = 4;
function Ae$1({ children: e$8, enabled: t$12 = !0 }) {
	let [n$16, r$20] = (0, import_react.useState)(null), [l$17, o$19] = (0, import_react.useState)(0), u$24 = (0, import_react.useRef)(null), [f$21, s$19] = (0, import_react.useState)(null);
	ce$1(f$21);
	let i$15 = t$12 && n$16 !== null && f$21 !== null, { to: F$6 = "bottom", gap: E$13 = 0, offset: A$4 = 0, padding: c$20 = 0, inner: h$14 } = ge$5(n$16, f$21), [a$27, p$12 = "center"] = F$6.split(" ");
	n$1(() => {
		i$15 && o$19(0);
	}, [i$15]);
	let { refs: b$13, floatingStyles: S$9, context: g$8 } = useFloating({
		open: i$15,
		placement: a$27 === "selection" ? p$12 === "center" ? "bottom" : `bottom-${p$12}` : p$12 === "center" ? `${a$27}` : `${a$27}-${p$12}`,
		strategy: "absolute",
		transform: !1,
		middleware: [
			offset({
				mainAxis: a$27 === "selection" ? 0 : E$13,
				crossAxis: A$4
			}),
			shift({ padding: c$20 }),
			a$27 !== "selection" && flip({ padding: c$20 }),
			a$27 === "selection" && h$14 ? inner({
				...h$14,
				padding: c$20,
				overflowRef: u$24,
				offset: l$17,
				minItemsVisible: D$6,
				referenceOverflowThreshold: c$20,
				onFallbackChange(P$7) {
					var L$6, N$3;
					if (!P$7) return;
					let d$13 = g$8.elements.floating;
					if (!d$13) return;
					let M$11 = parseFloat(getComputedStyle(d$13).scrollPaddingBottom) || 0, I$9 = Math.min(D$6, d$13.childElementCount), W$4 = 0, B$3 = 0;
					for (let m$9 of (N$3 = (L$6 = g$8.elements.floating) == null ? void 0 : L$6.childNodes) != null ? N$3 : []) if (n$13(m$9)) {
						let x$9 = m$9.offsetTop, k$13 = x$9 + m$9.clientHeight + M$11, H$8 = d$13.scrollTop, U$2 = H$8 + d$13.clientHeight;
						if (x$9 >= H$8 && k$13 <= U$2) I$9--;
						else {
							B$3 = Math.max(0, Math.min(k$13, U$2) - Math.max(x$9, H$8)), W$4 = m$9.clientHeight;
							break;
						}
					}
					I$9 >= 1 && o$19((m$9) => {
						let x$9 = W$4 * I$9 - B$3 + M$11;
						return m$9 >= x$9 ? m$9 : x$9;
					});
				}
			}) : null,
			size({
				padding: c$20,
				apply({ availableWidth: P$7, availableHeight: d$13, elements: M$11 }) {
					Object.assign(M$11.floating.style, {
						overflow: "auto",
						maxWidth: `${P$7}px`,
						maxHeight: `min(var(--anchor-max-height, 100vh), ${d$13}px)`
					});
				}
			})
		].filter(Boolean),
		whileElementsMounted: autoUpdate
	}), [w$12 = a$27, V$5 = p$12] = g$8.placement.split("-");
	a$27 === "selection" && (w$12 = "selection");
	let G$5 = (0, import_react.useMemo)(() => ({ anchor: [w$12, V$5].filter(Boolean).join(" ") }), [w$12, V$5]), K$3 = useInnerOffset(g$8, {
		overflowRef: u$24,
		onChange: o$19
	}), { getReferenceProps: Q$7, getFloatingProps: X$4 } = useInteractions([K$3]), Y$4 = o((P$7) => {
		s$19(P$7), b$13.setFloating(P$7);
	});
	return import_react.createElement($$3.Provider, { value: r$20 }, import_react.createElement(y$7.Provider, { value: {
		setFloating: Y$4,
		setReference: b$13.setReference,
		styles: S$9,
		getReferenceProps: Q$7,
		getFloatingProps: X$4,
		slot: G$5
	} }, e$8));
}
function ce$1(e$8) {
	n$1(() => {
		if (!e$8) return;
		let t$12 = new MutationObserver(() => {
			let n$16 = window.getComputedStyle(e$8).maxHeight, r$20 = parseFloat(n$16);
			if (isNaN(r$20)) return;
			let l$17 = parseInt(n$16);
			isNaN(l$17) || r$20 !== l$17 && (e$8.style.maxHeight = `${Math.ceil(r$20)}px`);
		});
		return t$12.observe(e$8, {
			attributes: !0,
			attributeFilter: ["style"]
		}), () => {
			t$12.disconnect();
		};
	}, [e$8]);
}
function ge$5(e$8, t$12) {
	var o$19, u$24, f$21;
	let n$16 = O$2((o$19 = e$8 == null ? void 0 : e$8.gap) != null ? o$19 : "var(--anchor-gap, 0)", t$12), r$20 = O$2((u$24 = e$8 == null ? void 0 : e$8.offset) != null ? u$24 : "var(--anchor-offset, 0)", t$12), l$17 = O$2((f$21 = e$8 == null ? void 0 : e$8.padding) != null ? f$21 : "var(--anchor-padding, 0)", t$12);
	return {
		...e$8,
		gap: n$16,
		offset: r$20,
		padding: l$17
	};
}
function O$2(e$8, t$12, n$16 = void 0) {
	let r$20 = p(), l$17 = o((s$19, i$15) => {
		if (s$19 == null) return [n$16, null];
		if (typeof s$19 == "number") return [s$19, null];
		if (typeof s$19 == "string") {
			if (!i$15) return [n$16, null];
			let F$6 = J$1(s$19, i$15);
			return [F$6, (E$13) => {
				let A$4 = q$3(s$19);
				{
					let c$20 = A$4.map((h$14) => window.getComputedStyle(i$15).getPropertyValue(h$14));
					r$20.requestAnimationFrame(function h$14() {
						r$20.nextFrame(h$14);
						let a$27 = !1;
						for (let [b$13, S$9] of A$4.entries()) {
							let g$8 = window.getComputedStyle(i$15).getPropertyValue(S$9);
							if (c$20[b$13] !== g$8) {
								c$20[b$13] = g$8, a$27 = !0;
								break;
							}
						}
						if (!a$27) return;
						let p$12 = J$1(s$19, i$15);
						F$6 !== p$12 && (E$13(p$12), F$6 = p$12);
					});
				}
				return r$20.dispose;
			}];
		}
		return [n$16, null];
	}), o$19 = (0, import_react.useMemo)(() => l$17(e$8, t$12)[0], [e$8, t$12]), [u$24 = o$19, f$21] = (0, import_react.useState)();
	return n$1(() => {
		let [s$19, i$15] = l$17(e$8, t$12);
		if (f$21(s$19), !!i$15) return i$15(f$21);
	}, [e$8, t$12]), u$24;
}
function q$3(e$8) {
	let t$12 = /var\((.*)\)/.exec(e$8);
	if (t$12) {
		let n$16 = t$12[1].indexOf(",");
		if (n$16 === -1) return [t$12[1]];
		let r$20 = t$12[1].slice(0, n$16).trim(), l$17 = t$12[1].slice(n$16 + 1).trim();
		return l$17 ? [r$20, ...q$3(l$17)] : [r$20];
	}
	return [];
}
function J$1(e$8, t$12) {
	let n$16 = document.createElement("div");
	t$12.appendChild(n$16), n$16.style.setProperty("margin-top", "0px", "important"), n$16.style.setProperty("margin-top", e$8, "important");
	let r$20 = parseFloat(window.getComputedStyle(n$16).marginTop) || 0;
	return t$12.removeChild(n$16), r$20;
}

//#endregion
//#region node_modules/@headlessui/react/dist/internal/frozen.js
function f$11({ children: t$12, freeze: e$8 }, o$19) {
	let n$16 = u$10(e$8, t$12);
	return (0, import_react.isValidElement)(n$16) ? (0, import_react.cloneElement)(n$16, { ref: o$19 }) : import_react.createElement(import_react.Fragment, null, n$16);
}
var s$13 = import_react.forwardRef(f$11);
function u$10(t$12, e$8) {
	let [o$19, n$16] = (0, import_react.useState)(e$8);
	return !t$12 && o$19 !== e$8 && n$16(e$8), t$12 ? o$19 : e$8;
}

//#endregion
//#region node_modules/@headlessui/react/dist/internal/open-closed.js
var n$7 = (0, import_react.createContext)(null);
n$7.displayName = "OpenClosedContext";
var i$1 = ((e$8) => (e$8[e$8.Open = 1] = "Open", e$8[e$8.Closed = 2] = "Closed", e$8[e$8.Closing = 4] = "Closing", e$8[e$8.Opening = 8] = "Opening", e$8))(i$1 || {});
function u$6() {
	return (0, import_react.useContext)(n$7);
}
function c$2({ value: o$19, children: t$12 }) {
	return import_react.createElement(n$7.Provider, { value: o$19 }, t$12);
}
function s$5({ children: o$19 }) {
	return import_react.createElement(n$7.Provider, { value: null }, o$19);
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/document-ready.js
function t$5(n$16) {
	function e$8() {
		document.readyState !== "loading" && (n$16(), document.removeEventListener("DOMContentLoaded", e$8));
	}
	typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("DOMContentLoaded", e$8), e$8());
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/active-element-history.js
var n$4 = [];
t$5(() => {
	function e$8(t$12) {
		if (!i$11(t$12.target) || t$12.target === document.body || n$4[0] === t$12.target) return;
		let r$20 = t$12.target;
		r$20 = r$20.closest(E$6), n$4.unshift(r$20 != null ? r$20 : t$12.target), n$4 = n$4.filter((o$19) => o$19 != null && o$19.isConnected), n$4.splice(10);
	}
	window.addEventListener("click", e$8, { capture: !0 }), window.addEventListener("mousedown", e$8, { capture: !0 }), window.addEventListener("focus", e$8, { capture: !0 }), document.body.addEventListener("click", e$8, { capture: !0 }), document.body.addEventListener("mousedown", e$8, { capture: !0 }), document.body.addEventListener("focus", e$8, { capture: !0 });
});

//#endregion
//#region node_modules/@headlessui/react/dist/utils/calculate-active-index.js
function u$14(l$17) {
	throw new Error("Unexpected object: " + l$17);
}
var c$4 = ((i$15) => (i$15[i$15.First = 0] = "First", i$15[i$15.Previous = 1] = "Previous", i$15[i$15.Next = 2] = "Next", i$15[i$15.Last = 3] = "Last", i$15[i$15.Specific = 4] = "Specific", i$15[i$15.Nothing = 5] = "Nothing", i$15))(c$4 || {});
function f$6(l$17, n$16) {
	let t$12 = n$16.resolveItems();
	if (t$12.length <= 0) return null;
	let r$20 = n$16.resolveActiveIndex(), s$19 = r$20 != null ? r$20 : -1;
	switch (l$17.focus) {
		case 0:
			for (let e$8 = 0; e$8 < t$12.length; ++e$8) if (!n$16.resolveDisabled(t$12[e$8], e$8, t$12)) return e$8;
			return r$20;
		case 1:
			s$19 === -1 && (s$19 = t$12.length);
			for (let e$8 = s$19 - 1; e$8 >= 0; --e$8) if (!n$16.resolveDisabled(t$12[e$8], e$8, t$12)) return e$8;
			return r$20;
		case 2:
			for (let e$8 = s$19 + 1; e$8 < t$12.length; ++e$8) if (!n$16.resolveDisabled(t$12[e$8], e$8, t$12)) return e$8;
			return r$20;
		case 3:
			for (let e$8 = t$12.length - 1; e$8 >= 0; --e$8) if (!n$16.resolveDisabled(t$12[e$8], e$8, t$12)) return e$8;
			return r$20;
		case 4:
			for (let e$8 = 0; e$8 < t$12.length; ++e$8) if (n$16.resolveId(t$12[e$8], e$8, t$12) === l$17.id) return e$8;
			return r$20;
		case 5: return null;
		default: u$14(l$17);
	}
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-on-unmount.js
function c$3(t$12) {
	let r$20 = o(t$12), e$8 = (0, import_react.useRef)(!1);
	(0, import_react.useEffect)(() => (e$8.current = !1, () => {
		e$8.current = !0, t(() => {
			e$8.current && r$20();
		});
	}), [r$20]);
}

//#endregion
//#region node_modules/@headlessui/react/dist/internal/portal-force-root.js
var e$3 = (0, import_react.createContext)(!1);
function a$11() {
	return (0, import_react.useContext)(e$3);
}
function l$6(o$19) {
	return import_react.createElement(e$3.Provider, { value: o$19.force }, o$19.children);
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/portal/portal.js
var import_react_dom$3 = /* @__PURE__ */ __toESM(require_react_dom(), 1);
function W$3(e$8) {
	let o$19 = a$11(), l$17 = (0, import_react.useContext)(c$9), [r$20, p$12] = (0, import_react.useState)(() => {
		var s$19;
		if (!o$19 && l$17 !== null) return (s$19 = l$17.current) != null ? s$19 : null;
		if (s$10.isServer) return null;
		let t$12 = e$8 == null ? void 0 : e$8.getElementById("headlessui-portal-root");
		if (t$12) return t$12;
		if (e$8 === null) return null;
		let n$16 = e$8.createElement("div");
		return n$16.setAttribute("id", "headlessui-portal-root"), e$8.body.appendChild(n$16);
	});
	return (0, import_react.useEffect)(() => {
		r$20 !== null && (e$8 != null && e$8.body.contains(r$20) || e$8 == null || e$8.body.appendChild(r$20));
	}, [r$20, e$8]), (0, import_react.useEffect)(() => {
		o$19 || l$17 !== null && p$12(l$17.current);
	}, [
		l$17,
		p$12,
		o$19
	]), r$20;
}
var _$5 = import_react.Fragment, j$4 = Y(function(o$19, l$17) {
	let { ownerDocument: r$20 = null,...p$12 } = o$19, t$12 = (0, import_react.useRef)(null), n$16 = y$1(T$1((a$27) => {
		t$12.current = a$27;
	}), l$17), s$19 = u$4(t$12.current), u$24 = W$3(r$20 != null ? r$20 : s$19), y$9 = (0, import_react.useContext)(m$3), g$8 = p(), v$10 = K();
	return c$3(() => {
		var a$27;
		u$24 && u$24.childNodes.length <= 0 && ((a$27 = u$24.parentElement) == null || a$27.removeChild(u$24));
	}), u$24 ? (0, import_react_dom$3.createPortal)(import_react.createElement("div", {
		"data-headlessui-portal": "",
		ref: (a$27) => {
			g$8.dispose(), y$9 && a$27 && g$8.add(y$9.register(a$27));
		}
	}, v$10({
		ourProps: { ref: n$16 },
		theirProps: p$12,
		slot: {},
		defaultTag: _$5,
		name: "Portal"
	})), u$24) : null;
});
function S$4(e$8, o$19) {
	let l$17 = y$1(o$19), { enabled: r$20 = !0, ownerDocument: p$12,...t$12 } = e$8, n$16 = K();
	return r$20 ? import_react.createElement(j$4, {
		...t$12,
		ownerDocument: p$12,
		ref: l$17
	}) : n$16({
		ourProps: { ref: l$17 },
		theirProps: t$12,
		slot: {},
		defaultTag: _$5,
		name: "Portal"
	});
}
var I$6 = import_react.Fragment, c$9 = (0, import_react.createContext)(null);
function D$5(e$8, o$19) {
	let { target: l$17,...r$20 } = e$8, t$12 = { ref: y$1(o$19) }, n$16 = K();
	return import_react.createElement(c$9.Provider, { value: l$17 }, n$16({
		ourProps: t$12,
		theirProps: r$20,
		defaultTag: I$6,
		name: "Popover.Group"
	}));
}
var m$3 = (0, import_react.createContext)(null);
function ee$2() {
	let e$8 = (0, import_react.useContext)(m$3), o$19 = (0, import_react.useRef)([]), l$17 = o((t$12) => (o$19.current.push(t$12), e$8 && e$8.register(t$12), () => r$20(t$12))), r$20 = o((t$12) => {
		let n$16 = o$19.current.indexOf(t$12);
		n$16 !== -1 && o$19.current.splice(n$16, 1), e$8 && e$8.unregister(t$12);
	}), p$12 = (0, import_react.useMemo)(() => ({
		register: l$17,
		unregister: r$20,
		portals: o$19
	}), [
		l$17,
		r$20,
		o$19
	]);
	return [o$19, (0, import_react.useMemo)(() => function({ children: n$16 }) {
		return import_react.createElement(m$3.Provider, { value: p$12 }, n$16);
	}, [p$12])];
}
var J = Y(S$4), X$2 = Y(D$5), te = Object.assign(J, { Group: X$2 });

//#endregion
//#region node_modules/@headlessui/react/dist/utils/element-movement.js
var c$5 = {
	Idle: { kind: "Idle" },
	Tracked: (e$8) => ({
		kind: "Tracked",
		position: e$8
	}),
	Moved: { kind: "Moved" }
};
function a$5(e$8) {
	let t$12 = e$8.getBoundingClientRect();
	return `${t$12.x},${t$12.y}`;
}
function p$4(e$8, t$12, i$15) {
	let n$16 = o$2();
	if (t$12.kind === "Tracked") {
		let o$19 = function() {
			d$13 !== a$5(e$8) && (n$16.dispose(), i$15());
		};
		let { position: d$13 } = t$12, s$19 = new ResizeObserver(o$19);
		s$19.observe(e$8), n$16.add(() => s$19.disconnect()), n$16.addEventListener(window, "scroll", o$19, { passive: !0 }), n$16.addEventListener(window, "resize", o$19);
	}
	return () => n$16.dispose();
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/combobox/combobox-machine.js
var I$5 = Object.defineProperty;
var h$7 = (t$12, i$15, e$8) => i$15 in t$12 ? I$5(t$12, i$15, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e$8
}) : t$12[i$15] = e$8;
var f$10 = (t$12, i$15, e$8) => (h$7(t$12, typeof i$15 != "symbol" ? i$15 + "" : i$15, e$8), e$8);
var P$2 = ((e$8) => (e$8[e$8.Open = 0] = "Open", e$8[e$8.Closed = 1] = "Closed", e$8))(P$2 || {}), k$10 = ((e$8) => (e$8[e$8.Single = 0] = "Single", e$8[e$8.Multi = 1] = "Multi", e$8))(k$10 || {}), _$4 = ((n$16) => (n$16[n$16.Pointer = 0] = "Pointer", n$16[n$16.Focus = 1] = "Focus", n$16[n$16.Other = 2] = "Other", n$16))(_$4 || {}), D$4 = ((l$17) => (l$17[l$17.OpenCombobox = 0] = "OpenCombobox", l$17[l$17.CloseCombobox = 1] = "CloseCombobox", l$17[l$17.GoToOption = 2] = "GoToOption", l$17[l$17.SetTyping = 3] = "SetTyping", l$17[l$17.RegisterOption = 4] = "RegisterOption", l$17[l$17.UnregisterOption = 5] = "UnregisterOption", l$17[l$17.DefaultToFirstOption = 6] = "DefaultToFirstOption", l$17[l$17.SetActivationTrigger = 7] = "SetActivationTrigger", l$17[l$17.UpdateVirtualConfiguration = 8] = "UpdateVirtualConfiguration", l$17[l$17.SetInputElement = 9] = "SetInputElement", l$17[l$17.SetButtonElement = 10] = "SetButtonElement", l$17[l$17.SetOptionsElement = 11] = "SetOptionsElement", l$17[l$17.MarkInputAsMoved = 12] = "MarkInputAsMoved", l$17))(D$4 || {});
function v$4(t$12, i$15 = (e$9) => e$9) {
	let e$8 = t$12.activeOptionIndex !== null ? t$12.options[t$12.activeOptionIndex] : null, n$16 = i$15(t$12.options.slice()), o$19 = n$16.length > 0 && n$16[0].dataRef.current.order !== null ? n$16.sort((u$24, a$27) => u$24.dataRef.current.order - a$27.dataRef.current.order) : G$2(n$16, (u$24) => u$24.dataRef.current.domRef.current), r$20 = e$8 ? o$19.indexOf(e$8) : null;
	return r$20 === -1 && (r$20 = null), {
		options: o$19,
		activeOptionIndex: r$20
	};
}
var j$3 = {
	[1](t$12) {
		var e$8;
		if ((e$8 = t$12.dataRef.current) != null && e$8.disabled || t$12.comboboxState === 1) return t$12;
		let i$15 = t$12.inputElement ? c$5.Tracked(a$5(t$12.inputElement)) : t$12.inputPositionState;
		return {
			...t$12,
			activeOptionIndex: null,
			comboboxState: 1,
			isTyping: !1,
			activationTrigger: 2,
			inputPositionState: i$15,
			__demoMode: !1
		};
	},
	[0](t$12) {
		var i$15, e$8;
		if ((i$15 = t$12.dataRef.current) != null && i$15.disabled || t$12.comboboxState === 0) return t$12;
		if ((e$8 = t$12.dataRef.current) != null && e$8.value) {
			let n$16 = t$12.dataRef.current.calculateIndex(t$12.dataRef.current.value);
			if (n$16 !== -1) return {
				...t$12,
				activeOptionIndex: n$16,
				comboboxState: 0,
				__demoMode: !1,
				inputPositionState: c$5.Idle
			};
		}
		return {
			...t$12,
			comboboxState: 0,
			inputPositionState: c$5.Idle,
			__demoMode: !1
		};
	},
	[3](t$12, i$15) {
		return t$12.isTyping === i$15.isTyping ? t$12 : {
			...t$12,
			isTyping: i$15.isTyping
		};
	},
	[2](t$12, i$15) {
		var r$20, u$24, a$27, s$19;
		if ((r$20 = t$12.dataRef.current) != null && r$20.disabled || t$12.optionsElement && !((u$24 = t$12.dataRef.current) != null && u$24.optionsPropsRef.current.static) && t$12.comboboxState === 1) return t$12;
		if (t$12.virtual) {
			let { options: p$12, disabled: c$20 } = t$12.virtual, m$9 = i$15.focus === c$4.Specific ? i$15.idx : f$6(i$15, {
				resolveItems: () => p$12,
				resolveActiveIndex: () => {
					var l$17, x$9;
					return (x$9 = (l$17 = t$12.activeOptionIndex) != null ? l$17 : p$12.findIndex((S$9) => !c$20(S$9))) != null ? x$9 : null;
				},
				resolveDisabled: c$20,
				resolveId() {
					throw new Error("Function not implemented.");
				}
			}), b$13 = (a$27 = i$15.trigger) != null ? a$27 : 2;
			return t$12.activeOptionIndex === m$9 && t$12.activationTrigger === b$13 ? t$12 : {
				...t$12,
				activeOptionIndex: m$9,
				activationTrigger: b$13,
				isTyping: !1,
				__demoMode: !1
			};
		}
		let e$8 = v$4(t$12);
		if (e$8.activeOptionIndex === null) {
			let p$12 = e$8.options.findIndex((c$20) => !c$20.dataRef.current.disabled);
			p$12 !== -1 && (e$8.activeOptionIndex = p$12);
		}
		let n$16 = i$15.focus === c$4.Specific ? i$15.idx : f$6(i$15, {
			resolveItems: () => e$8.options,
			resolveActiveIndex: () => e$8.activeOptionIndex,
			resolveId: (p$12) => p$12.id,
			resolveDisabled: (p$12) => p$12.dataRef.current.disabled
		}), o$19 = (s$19 = i$15.trigger) != null ? s$19 : 2;
		return t$12.activeOptionIndex === n$16 && t$12.activationTrigger === o$19 ? t$12 : {
			...t$12,
			...e$8,
			isTyping: !1,
			activeOptionIndex: n$16,
			activationTrigger: o$19,
			__demoMode: !1
		};
	},
	[4]: (t$12, i$15) => {
		var r$20, u$24, a$27, s$19;
		if ((r$20 = t$12.dataRef.current) != null && r$20.virtual) return {
			...t$12,
			options: [...t$12.options, i$15.payload]
		};
		let e$8 = i$15.payload, n$16 = v$4(t$12, (p$12) => (p$12.push(e$8), p$12));
		t$12.activeOptionIndex === null && (a$27 = (u$24 = t$12.dataRef.current).isSelected) != null && a$27.call(u$24, i$15.payload.dataRef.current.value) && (n$16.activeOptionIndex = n$16.options.indexOf(e$8));
		let o$19 = {
			...t$12,
			...n$16,
			activationTrigger: 2
		};
		return (s$19 = t$12.dataRef.current) != null && s$19.__demoMode && t$12.dataRef.current.value === void 0 && (o$19.activeOptionIndex = 0), o$19;
	},
	[5]: (t$12, i$15) => {
		var n$16;
		if ((n$16 = t$12.dataRef.current) != null && n$16.virtual) return {
			...t$12,
			options: t$12.options.filter((o$19) => o$19.id !== i$15.id)
		};
		let e$8 = v$4(t$12, (o$19) => {
			let r$20 = o$19.findIndex((u$24) => u$24.id === i$15.id);
			return r$20 !== -1 && o$19.splice(r$20, 1), o$19;
		});
		return {
			...t$12,
			...e$8,
			activationTrigger: 2
		};
	},
	[6]: (t$12, i$15) => t$12.defaultToFirstOption === i$15.value ? t$12 : {
		...t$12,
		defaultToFirstOption: i$15.value
	},
	[7]: (t$12, i$15) => t$12.activationTrigger === i$15.trigger ? t$12 : {
		...t$12,
		activationTrigger: i$15.trigger
	},
	[8]: (t$12, i$15) => {
		var n$16, o$19;
		if (t$12.virtual === null) return {
			...t$12,
			virtual: {
				options: i$15.options,
				disabled: (n$16 = i$15.disabled) != null ? n$16 : () => !1
			}
		};
		if (t$12.virtual.options === i$15.options && t$12.virtual.disabled === i$15.disabled) return t$12;
		let e$8 = t$12.activeOptionIndex;
		if (t$12.activeOptionIndex !== null) {
			let r$20 = i$15.options.indexOf(t$12.virtual.options[t$12.activeOptionIndex]);
			r$20 !== -1 ? e$8 = r$20 : e$8 = null;
		}
		return {
			...t$12,
			activeOptionIndex: e$8,
			virtual: {
				options: i$15.options,
				disabled: (o$19 = i$15.disabled) != null ? o$19 : () => !1
			}
		};
	},
	[9]: (t$12, i$15) => t$12.inputElement === i$15.element ? t$12 : {
		...t$12,
		inputElement: i$15.element
	},
	[10]: (t$12, i$15) => t$12.buttonElement === i$15.element ? t$12 : {
		...t$12,
		buttonElement: i$15.element
	},
	[11]: (t$12, i$15) => t$12.optionsElement === i$15.element ? t$12 : {
		...t$12,
		optionsElement: i$15.element
	},
	[12](t$12) {
		return t$12.inputPositionState.kind !== "Tracked" ? t$12 : {
			...t$12,
			inputPositionState: c$5.Moved
		};
	}
};
var y$6 = class y$6 extends T$2 {
	constructor(e$8) {
		super(e$8);
		f$10(this, "actions", {
			onChange: (e$9) => {
				let { onChange: n$16, compare: o$19, mode: r$20, value: u$24 } = this.state.dataRef.current;
				return u$2(r$20, {
					[0]: () => n$16 == null ? void 0 : n$16(e$9),
					[1]: () => {
						let a$27 = u$24.slice(), s$19 = a$27.findIndex((p$12) => o$19(p$12, e$9));
						return s$19 === -1 ? a$27.push(e$9) : a$27.splice(s$19, 1), n$16 == null ? void 0 : n$16(a$27);
					}
				});
			},
			registerOption: (e$9, n$16) => (this.send({
				type: 4,
				payload: {
					id: e$9,
					dataRef: n$16
				}
			}), () => {
				this.state.activeOptionIndex === this.state.dataRef.current.calculateIndex(n$16.current.value) && this.send({
					type: 6,
					value: !0
				}), this.send({
					type: 5,
					id: e$9
				});
			}),
			goToOption: (e$9, n$16) => (this.send({
				type: 6,
				value: !1
			}), this.send({
				type: 2,
				...e$9,
				trigger: n$16
			})),
			setIsTyping: (e$9) => {
				this.send({
					type: 3,
					isTyping: e$9
				});
			},
			closeCombobox: () => {
				var e$9, n$16;
				this.send({ type: 1 }), this.send({
					type: 6,
					value: !1
				}), (n$16 = (e$9 = this.state.dataRef.current).onClose) == null || n$16.call(e$9);
			},
			openCombobox: () => {
				this.send({ type: 0 }), this.send({
					type: 6,
					value: !0
				});
			},
			setActivationTrigger: (e$9) => {
				this.send({
					type: 7,
					trigger: e$9
				});
			},
			selectActiveOption: () => {
				let e$9 = this.selectors.activeOptionIndex(this.state);
				if (e$9 !== null) {
					if (this.actions.setIsTyping(!1), this.state.virtual) this.actions.onChange(this.state.virtual.options[e$9]);
					else {
						let { dataRef: n$16 } = this.state.options[e$9];
						this.actions.onChange(n$16.current.value);
					}
					this.actions.goToOption({
						focus: c$4.Specific,
						idx: e$9
					});
				}
			},
			setInputElement: (e$9) => {
				this.send({
					type: 9,
					element: e$9
				});
			},
			setButtonElement: (e$9) => {
				this.send({
					type: 10,
					element: e$9
				});
			},
			setOptionsElement: (e$9) => {
				this.send({
					type: 11,
					element: e$9
				});
			}
		});
		f$10(this, "selectors", {
			activeDescendantId: (e$9) => {
				var o$19, r$20;
				let n$16 = this.selectors.activeOptionIndex(e$9);
				if (n$16 !== null) return e$9.virtual ? (r$20 = e$9.options.find((u$24) => !u$24.dataRef.current.disabled && e$9.dataRef.current.compare(u$24.dataRef.current.value, e$9.virtual.options[n$16]))) == null ? void 0 : r$20.id : (o$19 = e$9.options[n$16]) == null ? void 0 : o$19.id;
			},
			activeOptionIndex: (e$9) => {
				if (e$9.defaultToFirstOption && e$9.activeOptionIndex === null && (e$9.virtual ? e$9.virtual.options.length > 0 : e$9.options.length > 0)) {
					if (e$9.virtual) {
						let { options: o$19, disabled: r$20 } = e$9.virtual, u$24 = o$19.findIndex((a$27) => {
							var s$19;
							return !((s$19 = r$20 == null ? void 0 : r$20(a$27)) != null && s$19);
						});
						if (u$24 !== -1) return u$24;
					}
					let n$16 = e$9.options.findIndex((o$19) => !o$19.dataRef.current.disabled);
					if (n$16 !== -1) return n$16;
				}
				return e$9.activeOptionIndex;
			},
			activeOption: (e$9) => {
				var o$19, r$20;
				let n$16 = this.selectors.activeOptionIndex(e$9);
				return n$16 === null ? null : e$9.virtual ? e$9.virtual.options[n$16 != null ? n$16 : 0] : (r$20 = (o$19 = e$9.options[n$16]) == null ? void 0 : o$19.dataRef.current.value) != null ? r$20 : null;
			},
			isActive: (e$9, n$16, o$19) => {
				var u$24;
				let r$20 = this.selectors.activeOptionIndex(e$9);
				return r$20 === null ? !1 : e$9.virtual ? r$20 === e$9.dataRef.current.calculateIndex(n$16) : ((u$24 = e$9.options[r$20]) == null ? void 0 : u$24.id) === o$19;
			},
			shouldScrollIntoView: (e$9, n$16, o$19) => !(e$9.virtual || e$9.__demoMode || e$9.comboboxState !== 0 || e$9.activationTrigger === 0 || !this.selectors.isActive(e$9, n$16, o$19)),
			didInputMove(e$9) {
				return e$9.inputPositionState.kind === "Moved";
			}
		});
		{
			let n$16 = this.state.id, o$19 = x$3.get(null);
			this.disposables.add(o$19.on(k$4.Push, (r$20) => {
				!o$19.selectors.isTop(r$20, n$16) && this.state.comboboxState === 0 && this.actions.closeCombobox();
			})), this.on(0, () => o$19.actions.push(n$16)), this.on(1, () => o$19.actions.pop(n$16));
		}
		this.disposables.group((n$16) => {
			this.on(1, (o$19) => {
				o$19.inputElement && (n$16.dispose(), n$16.add(p$4(o$19.inputElement, o$19.inputPositionState, () => {
					this.send({ type: 12 });
				})));
			});
		});
	}
	static new({ id: e$8, virtual: n$16 = null, __demoMode: o$19 = !1 }) {
		var r$20;
		return new y$6({
			id: e$8,
			dataRef: { current: {} },
			comboboxState: o$19 ? 0 : 1,
			isTyping: !1,
			options: [],
			virtual: n$16 ? {
				options: n$16.options,
				disabled: (r$20 = n$16.disabled) != null ? r$20 : () => !1
			} : null,
			activeOptionIndex: null,
			activationTrigger: 2,
			inputElement: null,
			buttonElement: null,
			optionsElement: null,
			__demoMode: o$19,
			inputPositionState: c$5.Idle
		});
	}
	reduce(e$8, n$16) {
		return u$2(n$16.type, j$3, e$8, n$16);
	}
};

//#endregion
//#region node_modules/@headlessui/react/dist/components/combobox/combobox-machine-glue.js
var u$12 = (0, import_react.createContext)(null);
function p$8(n$16) {
	let o$19 = (0, import_react.useContext)(u$12);
	if (o$19 === null) {
		let e$8 = /* @__PURE__ */ new Error(`<${n$16} /> is missing a parent <Combobox /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(e$8, b$8), e$8;
	}
	return o$19;
}
function b$8({ id: n$16, virtual: o$19 = null, __demoMode: e$8 = !1 }) {
	let t$12 = (0, import_react.useMemo)(() => y$6.new({
		id: n$16,
		virtual: o$19,
		__demoMode: e$8
	}), []);
	return c$3(() => t$12.dispose()), t$12;
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/combobox/combobox.js
var import_react_dom$2 = /* @__PURE__ */ __toESM(require_react_dom(), 1);
var de$3 = (0, import_react.createContext)(null);
de$3.displayName = "ComboboxDataContext";
function te$5(T$9) {
	let O$4 = (0, import_react.useContext)(de$3);
	if (O$4 === null) {
		let e$8 = /* @__PURE__ */ new Error(`<${T$9} /> is missing a parent <Combobox /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(e$8, te$5), e$8;
	}
	return O$4;
}
var Le$4 = (0, import_react.createContext)(null);
function Eo(T$9) {
	let O$4 = p$8("VirtualProvider"), { options: o$19 } = te$5("VirtualProvider").virtual, E$13 = S$1(O$4, (a$27) => a$27.optionsElement), [R$6, y$9] = (0, import_react.useMemo)(() => {
		let a$27 = E$13;
		if (!a$27) return [0, 0];
		let u$24 = window.getComputedStyle(a$27);
		return [parseFloat(u$24.paddingBlockStart || u$24.paddingTop), parseFloat(u$24.paddingBlockEnd || u$24.paddingBottom)];
	}, [E$13]), b$13 = useVirtualizer({
		enabled: o$19.length !== 0,
		scrollPaddingStart: R$6,
		scrollPaddingEnd: y$9,
		count: o$19.length,
		estimateSize() {
			return 40;
		},
		getScrollElement() {
			return O$4.state.optionsElement;
		},
		overscan: 12
	}), [h$14, p$12] = (0, import_react.useState)(0);
	n$1(() => {
		p$12((a$27) => a$27 + 1);
	}, [o$19]);
	let f$21 = b$13.getVirtualItems(), n$16 = S$1(O$4, (a$27) => a$27.activationTrigger === _$4.Pointer), m$9 = S$1(O$4, O$4.selectors.activeOptionIndex);
	return f$21.length === 0 ? null : import_react.createElement(Le$4.Provider, { value: b$13 }, import_react.createElement("div", {
		style: {
			position: "relative",
			width: "100%",
			height: `${b$13.getTotalSize()}px`
		},
		ref: (a$27) => {
			a$27 && (n$16 || m$9 !== null && o$19.length > m$9 && b$13.scrollToIndex(m$9));
		}
	}, f$21.map((a$27) => {
		var u$24;
		return import_react.createElement(import_react.Fragment, { key: a$27.key }, import_react.cloneElement((u$24 = T$9.children) == null ? void 0 : u$24.call(T$9, {
			...T$9.slot,
			option: o$19[a$27.index]
		}), {
			key: `${h$14}-${a$27.key}`,
			"data-index": a$27.index,
			"aria-setsize": o$19.length,
			"aria-posinset": a$27.index + 1,
			style: {
				position: "absolute",
				top: 0,
				left: 0,
				transform: `translateY(${a$27.start}px)`,
				overflowAnchor: "none"
			}
		}));
	})));
}
var ho = import_react.Fragment;
function Ao(T$9, O$4) {
	let e$8 = (0, import_react.useId)(), o$19 = a(), { value: E$13, defaultValue: R$6, onChange: y$9, form: b$13, name: h$14, by: p$12, invalid: f$21 = !1, disabled: n$16 = o$19 || !1, onClose: m$9, __demoMode: a$27 = !1, multiple: u$24 = !1, immediate: A$4 = !1, virtual: d$13 = null, nullable: X$4,...G$5 } = T$9, C$10 = l(R$6), [x$9 = u$24 ? [] : void 0, v$10] = b$2(E$13, y$9, C$10), c$20 = b$8({
		id: e$8,
		virtual: d$13,
		__demoMode: a$27
	}), z$3 = (0, import_react.useRef)({
		static: !1,
		hold: !1
	}), D$11 = u$3(p$12), K$3 = o((i$15) => d$13 ? p$12 === null ? d$13.options.indexOf(i$15) : d$13.options.findIndex((M$11) => D$11(M$11, i$15)) : c$20.state.options.findIndex((M$11) => D$11(M$11.dataRef.current.value, i$15))), W$4 = (0, import_react.useCallback)((i$15) => u$2(l$17.mode, {
		[k$10.Multi]: () => x$9.some((M$11) => D$11(M$11, i$15)),
		[k$10.Single]: () => D$11(x$9, i$15)
	}), [x$9]), S$9 = S$1(c$20, (i$15) => i$15.virtual), j$9 = o(() => m$9 == null ? void 0 : m$9()), l$17 = (0, import_react.useMemo)(() => ({
		__demoMode: a$27,
		immediate: A$4,
		optionsPropsRef: z$3,
		value: x$9,
		defaultValue: C$10,
		disabled: n$16,
		invalid: f$21,
		mode: u$24 ? k$10.Multi : k$10.Single,
		virtual: d$13 ? S$9 : null,
		onChange: v$10,
		isSelected: W$4,
		calculateIndex: K$3,
		compare: D$11,
		onClose: j$9
	}), [
		a$27,
		A$4,
		z$3,
		x$9,
		C$10,
		n$16,
		f$21,
		u$24,
		d$13,
		S$9,
		v$10,
		W$4,
		K$3,
		D$11,
		j$9
	]);
	n$1(() => {
		var i$15;
		d$13 && c$20.send({
			type: D$4.UpdateVirtualConfiguration,
			options: d$13.options,
			disabled: (i$15 = d$13.disabled) != null ? i$15 : null
		});
	}, [
		d$13,
		d$13 == null ? void 0 : d$13.options,
		d$13 == null ? void 0 : d$13.disabled
	]), n$1(() => {
		c$20.state.dataRef.current = l$17;
	}, [l$17]);
	let [k$13, Y$4, s$19, U$2] = S$1(c$20, (i$15) => [
		i$15.comboboxState,
		i$15.buttonElement,
		i$15.inputElement,
		i$15.optionsElement
	]), $$5 = x$3.get(null), ne$3 = S$1($$5, (0, import_react.useCallback)((i$15) => $$5.selectors.isTop(i$15, e$8), [$$5, e$8]));
	k$1(ne$3, [
		Y$4,
		s$19,
		U$2
	], () => c$20.actions.closeCombobox());
	let be$2 = S$1(c$20, c$20.selectors.activeOptionIndex), ee$6 = S$1(c$20, c$20.selectors.activeOption), q$4 = n({
		open: k$13 === P$2.Open,
		disabled: n$16,
		invalid: f$21,
		activeIndex: be$2,
		activeOption: ee$6,
		value: x$9
	}), [t$12, V$5] = V$2(), P$7 = O$4 === null ? {} : { ref: O$4 }, N$3 = (0, import_react.useCallback)(() => {
		if (C$10 !== void 0) return v$10 == null ? void 0 : v$10(C$10);
	}, [v$10, C$10]), g$8 = K();
	return import_react.createElement(V$5, {
		value: t$12,
		props: { htmlFor: s$19 == null ? void 0 : s$19.id },
		slot: {
			open: k$13 === P$2.Open,
			disabled: n$16
		}
	}, import_react.createElement(Ae$1, null, import_react.createElement(de$3.Provider, { value: l$17 }, import_react.createElement(u$12.Provider, { value: c$20 }, import_react.createElement(c$2, { value: u$2(k$13, {
		[P$2.Open]: i$1.Open,
		[P$2.Closed]: i$1.Closed
	}) }, h$14 != null && import_react.createElement(j, {
		disabled: n$16,
		data: x$9 != null ? { [h$14]: x$9 } : {},
		form: b$13,
		onReset: N$3
	}), g$8({
		ourProps: P$7,
		theirProps: G$5,
		slot: q$4,
		defaultTag: ho,
		name: "Combobox"
	}))))));
}
var Io = "input";
function Ro(T$9, O$4) {
	var ee$6, q$4;
	let e$8 = p$8("Combobox.Input"), o$19 = te$5("Combobox.Input"), E$13 = (0, import_react.useId)(), R$6 = u$1(), { id: y$9 = R$6 || `headlessui-combobox-input-${E$13}`, onChange: b$13, displayValue: h$14, disabled: p$12 = o$19.disabled || !1, autoFocus: f$21 = !1, type: n$16 = "text",...m$9 } = T$9, a$27 = (0, import_react.useRef)(null), u$24 = y$1(a$27, O$4, Fe$3(), e$8.actions.setInputElement), [A$4, d$13] = S$1(e$8, (t$12) => [t$12.comboboxState, t$12.isTyping]), X$4 = p(), G$5 = o(() => {
		e$8.actions.onChange(null), e$8.state.optionsElement && (e$8.state.optionsElement.scrollTop = 0), e$8.actions.goToOption({ focus: c$4.Nothing });
	}), C$10 = (0, import_react.useMemo)(() => {
		var t$12;
		return typeof h$14 == "function" && o$19.value !== void 0 ? (t$12 = h$14(o$19.value)) != null ? t$12 : "" : typeof o$19.value == "string" ? o$19.value : "";
	}, [o$19.value, h$14]);
	m$1(([t$12, V$5], [P$7, N$3]) => {
		if (e$8.state.isTyping) return;
		let g$8 = a$27.current;
		g$8 && ((N$3 === P$2.Open && V$5 === P$2.Closed || t$12 !== P$7) && (g$8.value = t$12), requestAnimationFrame(() => {
			if (e$8.state.isTyping || !g$8 || d$1(g$8)) return;
			let { selectionStart: i$15, selectionEnd: M$11 } = g$8;
			Math.abs((M$11 != null ? M$11 : 0) - (i$15 != null ? i$15 : 0)) === 0 && i$15 === 0 && g$8.setSelectionRange(g$8.value.length, g$8.value.length);
		}));
	}, [
		C$10,
		A$4,
		d$13
	]), m$1(([t$12], [V$5]) => {
		if (t$12 === P$2.Open && V$5 === P$2.Closed) {
			if (e$8.state.isTyping) return;
			let P$7 = a$27.current;
			if (!P$7) return;
			let N$3 = P$7.value, { selectionStart: g$8, selectionEnd: i$15, selectionDirection: M$11 } = P$7;
			P$7.value = "", P$7.value = N$3, M$11 !== null ? P$7.setSelectionRange(g$8, i$15, M$11) : P$7.setSelectionRange(g$8, i$15);
		}
	}, [A$4]);
	let x$9 = (0, import_react.useRef)(!1), v$10 = o(() => {
		x$9.current = !0;
	}), c$20 = o(() => {
		X$4.nextFrame(() => {
			x$9.current = !1;
		});
	}), z$3 = o((t$12) => {
		switch (e$8.actions.setIsTyping(!0), t$12.key) {
			case o$1.Enter:
				if (e$8.state.comboboxState !== P$2.Open || x$9.current) return;
				if (t$12.preventDefault(), t$12.stopPropagation(), e$8.selectors.activeOptionIndex(e$8.state) === null) {
					e$8.actions.closeCombobox();
					return;
				}
				e$8.actions.selectActiveOption(), o$19.mode === k$10.Single && e$8.actions.closeCombobox();
				break;
			case o$1.ArrowDown: return t$12.preventDefault(), t$12.stopPropagation(), u$2(e$8.state.comboboxState, {
				[P$2.Open]: () => e$8.actions.goToOption({ focus: c$4.Next }),
				[P$2.Closed]: () => e$8.actions.openCombobox()
			});
			case o$1.ArrowUp: return t$12.preventDefault(), t$12.stopPropagation(), u$2(e$8.state.comboboxState, {
				[P$2.Open]: () => e$8.actions.goToOption({ focus: c$4.Previous }),
				[P$2.Closed]: () => {
					(0, import_react_dom$2.flushSync)(() => e$8.actions.openCombobox()), o$19.value || e$8.actions.goToOption({ focus: c$4.Last });
				}
			});
			case o$1.Home:
				if (e$8.state.comboboxState === P$2.Closed || t$12.shiftKey) break;
				return t$12.preventDefault(), t$12.stopPropagation(), e$8.actions.goToOption({ focus: c$4.First });
			case o$1.PageUp: return t$12.preventDefault(), t$12.stopPropagation(), e$8.actions.goToOption({ focus: c$4.First });
			case o$1.End:
				if (e$8.state.comboboxState === P$2.Closed || t$12.shiftKey) break;
				return t$12.preventDefault(), t$12.stopPropagation(), e$8.actions.goToOption({ focus: c$4.Last });
			case o$1.PageDown: return t$12.preventDefault(), t$12.stopPropagation(), e$8.actions.goToOption({ focus: c$4.Last });
			case o$1.Escape: return e$8.state.comboboxState !== P$2.Open ? void 0 : (t$12.preventDefault(), e$8.state.optionsElement && !o$19.optionsPropsRef.current.static && t$12.stopPropagation(), o$19.mode === k$10.Single && o$19.value === null && G$5(), e$8.actions.closeCombobox());
			case o$1.Tab:
				if (e$8.actions.setIsTyping(!1), e$8.state.comboboxState !== P$2.Open) return;
				o$19.mode === k$10.Single && e$8.state.activationTrigger !== _$4.Focus && e$8.actions.selectActiveOption(), e$8.actions.closeCombobox();
				break;
		}
	}), D$11 = o((t$12) => {
		b$13?.(t$12), o$19.mode === k$10.Single && t$12.target.value === "" && G$5(), e$8.actions.openCombobox();
	}), K$3 = o((t$12) => {
		var P$7, N$3, g$8;
		let V$5 = (P$7 = t$12.relatedTarget) != null ? P$7 : n$4.find((i$15) => i$15 !== t$12.currentTarget);
		if (!((N$3 = e$8.state.optionsElement) != null && N$3.contains(V$5)) && !((g$8 = e$8.state.buttonElement) != null && g$8.contains(V$5)) && e$8.state.comboboxState === P$2.Open) return t$12.preventDefault(), o$19.mode === k$10.Single && o$19.value === null && G$5(), e$8.actions.closeCombobox();
	}), W$4 = o((t$12) => {
		var P$7, N$3, g$8;
		let V$5 = (P$7 = t$12.relatedTarget) != null ? P$7 : n$4.find((i$15) => i$15 !== t$12.currentTarget);
		(N$3 = e$8.state.buttonElement) != null && N$3.contains(V$5) || (g$8 = e$8.state.optionsElement) != null && g$8.contains(V$5) || o$19.disabled || o$19.immediate && e$8.state.comboboxState !== P$2.Open && X$4.microTask(() => {
			(0, import_react_dom$2.flushSync)(() => e$8.actions.openCombobox()), e$8.actions.setActivationTrigger(_$4.Focus);
		});
	}), S$9 = N(), j$9 = w(), { isFocused: l$17, focusProps: k$13 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: f$21 }), { isHovered: Y$4, hoverProps: s$19 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: p$12 }), U$2 = S$1(e$8, (t$12) => t$12.optionsElement), $$5 = n({
		open: A$4 === P$2.Open,
		disabled: p$12,
		invalid: o$19.invalid,
		hover: Y$4,
		focus: l$17,
		autofocus: f$21
	}), ne$3 = V({
		ref: u$24,
		id: y$9,
		role: "combobox",
		type: n$16,
		"aria-controls": U$2 == null ? void 0 : U$2.id,
		"aria-expanded": A$4 === P$2.Open,
		"aria-activedescendant": S$1(e$8, e$8.selectors.activeDescendantId),
		"aria-labelledby": S$9,
		"aria-describedby": j$9,
		"aria-autocomplete": "list",
		defaultValue: (q$4 = (ee$6 = T$9.defaultValue) != null ? ee$6 : o$19.defaultValue !== void 0 ? h$14 == null ? void 0 : h$14(o$19.defaultValue) : null) != null ? q$4 : o$19.defaultValue,
		disabled: p$12 || void 0,
		autoFocus: f$21,
		onCompositionStart: v$10,
		onCompositionEnd: c$20,
		onKeyDown: z$3,
		onChange: D$11,
		onFocus: W$4,
		onBlur: K$3
	}, k$13, s$19);
	return K()({
		ourProps: ne$3,
		theirProps: m$9,
		slot: $$5,
		defaultTag: Io,
		name: "Combobox.Input"
	});
}
var _o = "button";
function Fo(T$9, O$4) {
	let e$8 = p$8("Combobox.Button"), o$19 = te$5("Combobox.Button"), [E$13, R$6] = (0, import_react.useState)(null), y$9 = y$1(O$4, R$6, e$8.actions.setButtonElement), b$13 = (0, import_react.useId)(), { id: h$14 = `headlessui-combobox-button-${b$13}`, disabled: p$12 = o$19.disabled || !1, autoFocus: f$21 = !1,...n$16 } = T$9, [m$9, a$27, u$24] = S$1(e$8, (l$17) => [
		l$17.comboboxState,
		l$17.inputElement,
		l$17.optionsElement
	]), A$4 = v$3(a$27), d$13 = m$9 === P$2.Open;
	L$2(d$13, {
		trigger: E$13,
		action: (0, import_react.useCallback)((l$17) => {
			if (E$13 != null && E$13.contains(l$17.target)) return S$2.Ignore;
			if (a$27 != null && a$27.contains(l$17.target)) return S$2.Ignore;
			let k$13 = l$17.target.closest("[role=\"option\"]:not([data-disabled])");
			return n$13(k$13) ? S$2.Select(k$13) : u$24 != null && u$24.contains(l$17.target) ? S$2.Ignore : S$2.Close;
		}, [
			E$13,
			a$27,
			u$24
		]),
		close: e$8.actions.closeCombobox,
		select: e$8.actions.selectActiveOption
	});
	let X$4 = o((l$17) => {
		switch (l$17.key) {
			case o$1.Space:
			case o$1.Enter:
				l$17.preventDefault(), l$17.stopPropagation(), e$8.state.comboboxState === P$2.Closed && (0, import_react_dom$2.flushSync)(() => e$8.actions.openCombobox()), A$4();
				return;
			case o$1.ArrowDown:
				l$17.preventDefault(), l$17.stopPropagation(), e$8.state.comboboxState === P$2.Closed && ((0, import_react_dom$2.flushSync)(() => e$8.actions.openCombobox()), e$8.state.dataRef.current.value || e$8.actions.goToOption({ focus: c$4.First })), A$4();
				return;
			case o$1.ArrowUp:
				l$17.preventDefault(), l$17.stopPropagation(), e$8.state.comboboxState === P$2.Closed && ((0, import_react_dom$2.flushSync)(() => e$8.actions.openCombobox()), e$8.state.dataRef.current.value || e$8.actions.goToOption({ focus: c$4.Last })), A$4();
				return;
			case o$1.Escape:
				if (e$8.state.comboboxState !== P$2.Open) return;
				l$17.preventDefault(), e$8.state.optionsElement && !o$19.optionsPropsRef.current.static && l$17.stopPropagation(), (0, import_react_dom$2.flushSync)(() => e$8.actions.closeCombobox()), A$4();
				return;
			default: return;
		}
	}), G$5 = s$6(() => {
		e$8.state.comboboxState === P$2.Open ? e$8.actions.closeCombobox() : e$8.actions.openCombobox(), A$4();
	}), C$10 = N([h$14]), { isFocusVisible: x$9, focusProps: v$10 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: f$21 }), { isHovered: c$20, hoverProps: z$3 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: p$12 }), { pressed: D$11, pressProps: K$3 } = w$1({ disabled: p$12 }), W$4 = n({
		open: m$9 === P$2.Open,
		active: D$11 || m$9 === P$2.Open,
		disabled: p$12,
		invalid: o$19.invalid,
		value: o$19.value,
		hover: c$20,
		focus: x$9
	}), S$9 = V({
		ref: y$9,
		id: h$14,
		type: e(T$9, E$13),
		tabIndex: -1,
		"aria-haspopup": "listbox",
		"aria-controls": u$24 == null ? void 0 : u$24.id,
		"aria-expanded": m$9 === P$2.Open,
		"aria-labelledby": C$10,
		disabled: p$12 || void 0,
		autoFocus: f$21,
		onKeyDown: X$4
	}, G$5, v$10, z$3, K$3);
	return K()({
		ourProps: S$9,
		theirProps: n$16,
		slot: W$4,
		defaultTag: _o,
		name: "Combobox.Button"
	});
}
var Do = "div", So = A$1.RenderStrategy | A$1.Static;
function Mo$1(T$9, O$4) {
	var M$11, Ce$4, ve$2;
	let e$8 = (0, import_react.useId)(), { id: o$19 = `headlessui-combobox-options-${e$8}`, hold: E$13 = !1, anchor: R$6, portal: y$9 = !1, modal: b$13 = !0, transition: h$14 = !1,...p$12 } = T$9, f$21 = p$8("Combobox.Options"), n$16 = te$5("Combobox.Options"), m$9 = ye(R$6);
	m$9 && (y$9 = !0);
	let [a$27, u$24] = Re$1(m$9), [A$4, d$13] = (0, import_react.useState)(null), X$4 = Te(), G$5 = y$1(O$4, m$9 ? a$27 : null, f$21.actions.setOptionsElement, d$13), [C$10, x$9, v$10, c$20, z$3] = S$1(f$21, (_$10) => [
		_$10.comboboxState,
		_$10.inputElement,
		_$10.buttonElement,
		_$10.optionsElement,
		_$10.activationTrigger
	]), D$11 = u$4(x$9 || v$10), K$3 = u$4(c$20), W$4 = u$6(), [S$9, j$9] = N$1(h$14, A$4, W$4 !== null ? (W$4 & i$1.Open) === i$1.Open : C$10 === P$2.Open);
	p$1(S$9, x$9, f$21.actions.closeCombobox);
	let l$17 = n$16.__demoMode ? !1 : b$13 && C$10 === P$2.Open;
	f$3(l$17, K$3);
	let k$13 = n$16.__demoMode ? !1 : b$13 && C$10 === P$2.Open;
	y$2(k$13, { allowed: (0, import_react.useCallback)(() => [
		x$9,
		v$10,
		c$20
	], [
		x$9,
		v$10,
		c$20
	]) });
	let s$19 = S$1(f$21, f$21.selectors.didInputMove) ? !1 : S$9;
	n$1(() => {
		var _$10;
		n$16.optionsPropsRef.current.static = (_$10 = T$9.static) != null ? _$10 : !1;
	}, [n$16.optionsPropsRef, T$9.static]), n$1(() => {
		n$16.optionsPropsRef.current.hold = E$13;
	}, [n$16.optionsPropsRef, E$13]), F(C$10 === P$2.Open, {
		container: c$20,
		accept(_$10) {
			return _$10.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : _$10.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
		},
		walk(_$10) {
			_$10.setAttribute("role", "none");
		}
	});
	let U$2 = N([v$10 == null ? void 0 : v$10.id]), $$5 = n({
		open: C$10 === P$2.Open,
		option: void 0
	}), ne$3 = o(() => {
		f$21.actions.setActivationTrigger(_$4.Pointer);
	}), be$2 = o((_$10) => {
		_$10.preventDefault(), f$21.actions.setActivationTrigger(_$4.Pointer);
	}), ee$6 = V(m$9 ? X$4() : {}, {
		"aria-labelledby": U$2,
		role: "listbox",
		"aria-multiselectable": n$16.mode === k$10.Multi ? !0 : void 0,
		id: o$19,
		ref: G$5,
		style: {
			...p$12.style,
			...u$24,
			"--input-width": w$3(S$9, x$9, !0).width,
			"--button-width": w$3(S$9, v$10, !0).width
		},
		onWheel: z$3 === _$4.Pointer ? void 0 : ne$3,
		onMouseDown: be$2,
		...x$1(j$9)
	}), q$4 = S$9 && C$10 === P$2.Closed && !T$9.static, t$12 = u$10(q$4, (M$11 = n$16.virtual) == null ? void 0 : M$11.options), V$5 = u$10(q$4, n$16.value), P$7 = (0, import_react.useCallback)((_$10) => n$16.compare(V$5, _$10), [n$16.compare, V$5]), N$3 = (0, import_react.useMemo)(() => {
		if (!n$16.virtual) return n$16;
		if (t$12 === void 0) throw new Error("Missing `options` in virtual mode");
		return t$12 !== n$16.virtual.options ? {
			...n$16,
			virtual: {
				...n$16.virtual,
				options: t$12
			}
		} : n$16;
	}, [
		n$16,
		t$12,
		(Ce$4 = n$16.virtual) == null ? void 0 : Ce$4.options
	]);
	n$16.virtual && Object.assign(p$12, { children: import_react.createElement(de$3.Provider, { value: N$3 }, import_react.createElement(Eo, { slot: $$5 }, p$12.children)) });
	let g$8 = K(), i$15 = (0, import_react.useMemo)(() => n$16.mode === k$10.Multi ? n$16 : {
		...n$16,
		isSelected: P$7
	}, [n$16, P$7]);
	return import_react.createElement(te, {
		enabled: y$9 ? T$9.static || S$9 : !1,
		ownerDocument: D$11
	}, import_react.createElement(de$3.Provider, { value: i$15 }, g$8({
		ourProps: ee$6,
		theirProps: {
			...p$12,
			children: import_react.createElement(s$13, { freeze: q$4 }, typeof p$12.children == "function" ? (ve$2 = p$12.children) == null ? void 0 : ve$2.call(p$12, $$5) : p$12.children)
		},
		slot: $$5,
		defaultTag: Do,
		features: So,
		visible: s$19,
		name: "Combobox.Options"
	})));
}
var Lo = "div";
function Vo(T$9, O$4) {
	var l$17, k$13, Y$4;
	let e$8 = te$5("Combobox.Option"), o$19 = p$8("Combobox.Option"), E$13 = (0, import_react.useId)(), { id: R$6 = `headlessui-combobox-option-${E$13}`, value: y$9, disabled: b$13 = (Y$4 = (k$13 = (l$17 = e$8.virtual) == null ? void 0 : l$17.disabled) == null ? void 0 : k$13.call(l$17, y$9)) != null ? Y$4 : !1, order: h$14 = null,...p$12 } = T$9, [f$21] = S$1(o$19, (s$19) => [s$19.inputElement]), n$16 = v$3(f$21), m$9 = S$1(o$19, (0, import_react.useCallback)((s$19) => o$19.selectors.isActive(s$19, y$9, R$6), [y$9, R$6])), a$27 = e$8.isSelected(y$9), u$24 = (0, import_react.useRef)(null), A$4 = s({
		disabled: b$13,
		value: y$9,
		domRef: u$24,
		order: h$14
	}), d$13 = (0, import_react.useContext)(Le$4), X$4 = y$1(O$4, u$24, d$13 ? d$13.measureElement : null), G$5 = o(() => {
		o$19.actions.setIsTyping(!1), o$19.actions.onChange(y$9);
	});
	n$1(() => o$19.actions.registerOption(R$6, A$4), [A$4, R$6]);
	let C$10 = S$1(o$19, (0, import_react.useCallback)((s$19) => o$19.selectors.shouldScrollIntoView(s$19, y$9, R$6), [y$9, R$6]));
	n$1(() => {
		if (C$10) return o$2().requestAnimationFrame(() => {
			var s$19, U$2;
			(U$2 = (s$19 = u$24.current) == null ? void 0 : s$19.scrollIntoView) == null || U$2.call(s$19, { block: "nearest" });
		});
	}, [C$10, u$24]);
	let x$9 = o((s$19) => {
		s$19.preventDefault(), s$19.button === g$4.Left && (b$13 || (G$5(), n$5() || requestAnimationFrame(() => n$16()), e$8.mode === k$10.Single && o$19.actions.closeCombobox()));
	}), v$10 = o(() => {
		if (b$13) return o$19.actions.goToOption({ focus: c$4.Nothing });
		let s$19 = e$8.calculateIndex(y$9);
		o$19.actions.goToOption({
			focus: c$4.Specific,
			idx: s$19
		});
	}), c$20 = u$8(), z$3 = o((s$19) => c$20.update(s$19)), D$11 = o((s$19) => {
		if (!c$20.wasMoved(s$19) || b$13 || m$9 && o$19.state.activationTrigger === _$4.Pointer) return;
		let U$2 = e$8.calculateIndex(y$9);
		o$19.actions.goToOption({
			focus: c$4.Specific,
			idx: U$2
		}, _$4.Pointer);
	}), K$3 = o((s$19) => {
		c$20.wasMoved(s$19) && (b$13 || m$9 && (e$8.optionsPropsRef.current.hold || o$19.state.activationTrigger === _$4.Pointer && o$19.actions.goToOption({ focus: c$4.Nothing })));
	}), W$4 = n({
		active: m$9,
		focus: m$9,
		selected: a$27,
		disabled: b$13
	}), S$9 = {
		id: R$6,
		ref: X$4,
		role: "option",
		tabIndex: b$13 === !0 ? void 0 : -1,
		"aria-disabled": b$13 === !0 ? !0 : void 0,
		"aria-selected": a$27,
		disabled: void 0,
		onMouseDown: x$9,
		onFocus: v$10,
		onPointerEnter: z$3,
		onMouseEnter: z$3,
		onPointerMove: D$11,
		onMouseMove: D$11,
		onPointerLeave: K$3,
		onMouseLeave: K$3
	};
	return K()({
		ourProps: S$9,
		theirProps: p$12,
		slot: W$4,
		defaultTag: Lo,
		name: "Combobox.Option"
	});
}
var wo = Y(Ao), Bo = Y(Fo), ko = Y(Ro), No = Z, Uo = Y(Mo$1), Ho = Y(Vo), Ht = Object.assign(wo, {
	Input: ko,
	Button: Bo,
	Label: No,
	Options: Uo,
	Option: Ho
});

//#endregion
//#region node_modules/@headlessui/react/dist/components/data-interactive/data-interactive.js
var E$4 = import_react.Fragment;
function d$6(t$12, r$20) {
	let { ...a$27 } = t$12, e$8 = !1, { isFocusVisible: o$19, focusProps: n$16 } = $f7dceffc5ad7768b$export$4e328f61c538687f(), { isHovered: p$12, hoverProps: s$19 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e$8 }), { pressed: i$15, pressProps: T$9 } = w$1({ disabled: e$8 }), l$17 = V({ ref: r$20 }, n$16, s$19, T$9), m$9 = n({
		hover: p$12,
		focus: o$19,
		active: i$15
	});
	return K()({
		ourProps: l$17,
		theirProps: a$27,
		slot: m$9,
		defaultTag: E$4,
		name: "DataInteractive"
	});
}
var b = Y(d$6);

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-escape.js
function a$9(o$19, r$20 = typeof document != "undefined" ? document.defaultView : null, t$12) {
	let n$16 = I$3(o$19, "escape");
	E$2(r$20, "keydown", (e$8) => {
		n$16 && (e$8.defaultPrevented || e$8.key === o$1.Escape && t$12(e$8));
	});
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-is-touch-device.js
function f$9() {
	var t$12;
	let [e$8] = (0, import_react.useState)(() => typeof window != "undefined" && typeof window.matchMedia == "function" ? window.matchMedia("(pointer: coarse)") : null), [o$19, c$20] = (0, import_react.useState)((t$12 = e$8 == null ? void 0 : e$8.matches) != null ? t$12 : !1);
	return n$1(() => {
		if (!e$8) return;
		function n$16(r$20) {
			c$20(r$20.matches);
		}
		return e$8.addEventListener("change", n$16), () => e$8.removeEventListener("change", n$16);
	}, [e$8]), o$19;
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-root-containers.js
function S({ defaultContainers: l$17 = [], portals: n$16, mainTreeNode: o$19 } = {}) {
	let c$20 = o(() => {
		var r$20, u$24;
		let i$15 = l$1(o$19), t$12 = [];
		for (let e$8 of l$17) e$8 !== null && (t$9(e$8) ? t$12.push(e$8) : "current" in e$8 && t$9(e$8.current) && t$12.push(e$8.current));
		if (n$16 != null && n$16.current) for (let e$8 of n$16.current) t$12.push(e$8);
		for (let e$8 of (r$20 = i$15 == null ? void 0 : i$15.querySelectorAll("html > *, body > *")) != null ? r$20 : []) e$8 !== document.body && e$8 !== document.head && t$9(e$8) && e$8.id !== "headlessui-portal-root" && (o$19 && (e$8.contains(o$19) || e$8.contains((u$24 = o$19 == null ? void 0 : o$19.getRootNode()) == null ? void 0 : u$24.host)) || t$12.some((E$13) => e$8.contains(E$13)) || t$12.push(e$8));
		return t$12;
	});
	return {
		resolveContainers: c$20,
		contains: o((i$15) => c$20().some((t$12) => t$12.contains(i$15)))
	};
}
var d$5 = (0, import_react.createContext)(null);
function j$1({ children: l$17, node: n$16 }) {
	let [o$19, c$20] = (0, import_react.useState)(null), i$15 = x(n$16 != null ? n$16 : o$19);
	return import_react.createElement(d$5.Provider, { value: i$15 }, l$17, i$15 === null && import_react.createElement(f, {
		features: s$3.Hidden,
		ref: (t$12) => {
			var r$20, u$24;
			if (t$12) {
				for (let e$8 of (u$24 = (r$20 = l$1(t$12)) == null ? void 0 : r$20.querySelectorAll("html > *, body > *")) != null ? u$24 : []) if (e$8 !== document.body && e$8 !== document.head && t$9(e$8) && e$8 != null && e$8.contains(t$12)) {
					c$20(e$8);
					break;
				}
			}
		}
	}));
}
function x(l$17 = null) {
	var n$16;
	return (n$16 = (0, import_react.useContext)(d$5)) != null ? n$16 : l$17;
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-server-handoff-complete.js
function s$11() {
	let r$20 = typeof document == "undefined";
	return "useSyncExternalStore" in import_react ? ((o$19) => o$19.useSyncExternalStore)(import_react)(() => () => {}, () => !1, () => !r$20) : !1;
}
function l$5() {
	let r$20 = s$11(), [e$8, n$16] = import_react.useState(s$10.isHandoffComplete);
	return e$8 && s$10.isHandoffComplete === !1 && n$16(!1), import_react.useEffect(() => {
		e$8 !== !0 && n$16(!0);
	}, [e$8]), import_react.useEffect(() => s$10.handoff(), []), r$20 ? !1 : e$8;
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-is-mounted.js
function f$2() {
	let e$8 = (0, import_react.useRef)(!1);
	return n$1(() => (e$8.current = !0, () => {
		e$8.current = !1;
	}), []), e$8;
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-tab-direction.js
var a$2 = ((r$20) => (r$20[r$20.Forwards = 0] = "Forwards", r$20[r$20.Backwards = 1] = "Backwards", r$20))(a$2 || {});
function u$5() {
	let e$8 = (0, import_react.useRef)(0);
	return s$9(!0, "keydown", (r$20) => {
		r$20.key === "Tab" && (e$8.current = r$20.shiftKey ? 1 : 0);
	}, !0), e$8;
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/focus-trap/focus-trap.js
function x$6(o$19) {
	if (!o$19) return /* @__PURE__ */ new Set();
	if (typeof o$19 == "function") return new Set(o$19());
	let t$12 = /* @__PURE__ */ new Set();
	for (let e$8 of o$19.current) t$9(e$8.current) && t$12.add(e$8.current);
	return t$12;
}
var $$2 = "div";
var G = ((n$16) => (n$16[n$16.None = 0] = "None", n$16[n$16.InitialFocus = 1] = "InitialFocus", n$16[n$16.TabLock = 2] = "TabLock", n$16[n$16.FocusLock = 4] = "FocusLock", n$16[n$16.RestoreFocus = 8] = "RestoreFocus", n$16[n$16.AutoFocus = 16] = "AutoFocus", n$16))(G || {});
function w$8(o$19, t$12) {
	let e$8 = (0, import_react.useRef)(null), r$20 = y$1(e$8, t$12), { initialFocus: u$24, initialFocusFallback: a$27, containers: n$16, features: s$19 = 15,...f$21 } = o$19;
	l$5() || (s$19 = 0);
	let l$17 = u$4(e$8.current);
	re$2(s$19, { ownerDocument: l$17 });
	let T$9 = ne$2(s$19, {
		ownerDocument: l$17,
		container: e$8,
		initialFocus: u$24,
		initialFocusFallback: a$27
	});
	oe$3(s$19, {
		ownerDocument: l$17,
		container: e$8,
		containers: n$16,
		previousActiveElement: T$9
	});
	let g$8 = u$5(), A$4 = o((c$20) => {
		if (!n$13(e$8.current)) return;
		let E$13 = e$8.current;
		((V$5) => V$5())(() => {
			u$2(g$8.current, {
				[a$2.Forwards]: () => {
					v(E$13, T.First, { skipElements: [c$20.relatedTarget, a$27] });
				},
				[a$2.Backwards]: () => {
					v(E$13, T.Last, { skipElements: [c$20.relatedTarget, a$27] });
				}
			});
		});
	}), v$10 = I$3(!!(s$19 & 2), "focus-trap#tab-lock"), N$3 = p(), b$13 = (0, import_react.useRef)(!1), k$13 = {
		ref: r$20,
		onKeyDown(c$20) {
			c$20.key == "Tab" && (b$13.current = !0, N$3.requestAnimationFrame(() => {
				b$13.current = !1;
			}));
		},
		onBlur(c$20) {
			if (!(s$19 & 4)) return;
			let E$13 = x$6(n$16);
			n$13(e$8.current) && E$13.add(e$8.current);
			let L$6 = c$20.relatedTarget;
			i$11(L$6) && L$6.dataset.headlessuiFocusGuard !== "true" && (I$4(E$13, L$6) || (b$13.current ? v(e$8.current, u$2(g$8.current, {
				[a$2.Forwards]: () => T.Next,
				[a$2.Backwards]: () => T.Previous
			}) | T.WrapAround, { relativeTo: c$20.target }) : i$11(c$20.target) && w$7(c$20.target)));
		}
	}, B$3 = K();
	return import_react.createElement(import_react.Fragment, null, v$10 && import_react.createElement(f, {
		as: "button",
		type: "button",
		"data-headlessui-focus-guard": !0,
		onFocus: A$4,
		features: s$3.Focusable
	}), B$3({
		ourProps: k$13,
		theirProps: f$21,
		defaultTag: $$2,
		name: "FocusTrap"
	}), v$10 && import_react.createElement(f, {
		as: "button",
		type: "button",
		"data-headlessui-focus-guard": !0,
		onFocus: A$4,
		features: s$3.Focusable
	}));
}
var ee$5 = Y(w$8), ge = Object.assign(ee$5, { features: G });
function te$4(o$19 = !0) {
	let t$12 = (0, import_react.useRef)(n$4.slice());
	return m$1(([e$8], [r$20]) => {
		r$20 === !0 && e$8 === !1 && t(() => {
			t$12.current.splice(0);
		}), r$20 === !1 && e$8 === !0 && (t$12.current = n$4.slice());
	}, [
		o$19,
		n$4,
		t$12
	]), o(() => {
		var e$8;
		return (e$8 = t$12.current.find((r$20) => r$20 != null && r$20.isConnected)) != null ? e$8 : null;
	});
}
function re$2(o$19, { ownerDocument: t$12 }) {
	let e$8 = !!(o$19 & 8), r$20 = te$4(e$8);
	m$1(() => {
		e$8 || d$1(t$12 == null ? void 0 : t$12.body) && w$7(r$20());
	}, [e$8]), c$3(() => {
		e$8 && w$7(r$20());
	});
}
function ne$2(o$19, { ownerDocument: t$12, container: e$8, initialFocus: r$20, initialFocusFallback: u$24 }) {
	let a$27 = (0, import_react.useRef)(null), n$16 = I$3(!!(o$19 & 1), "focus-trap#initial-focus"), s$19 = f$2();
	return m$1(() => {
		if (o$19 === 0) return;
		if (!n$16) {
			u$24 != null && u$24.current && w$7(u$24.current);
			return;
		}
		let f$21 = e$8.current;
		f$21 && t(() => {
			if (!s$19.current) return;
			let l$17 = t$12 == null ? void 0 : t$12.activeElement;
			if (r$20 != null && r$20.current) {
				if ((r$20 == null ? void 0 : r$20.current) === l$17) {
					a$27.current = l$17;
					return;
				}
			} else if (f$21.contains(l$17)) {
				a$27.current = l$17;
				return;
			}
			if (r$20 != null && r$20.current) w$7(r$20.current);
			else {
				if (o$19 & 16) {
					if (v(f$21, T.First | T.AutoFocus) !== A.Error) return;
				} else if (v(f$21, T.First) !== A.Error) return;
				if (u$24 != null && u$24.current && (w$7(u$24.current), (t$12 == null ? void 0 : t$12.activeElement) === u$24.current)) return;
				console.warn("There are no focusable elements inside the <FocusTrap />");
			}
			a$27.current = t$12 == null ? void 0 : t$12.activeElement;
		});
	}, [
		u$24,
		n$16,
		o$19
	]), a$27;
}
function oe$3(o$19, { ownerDocument: t$12, container: e$8, containers: r$20, previousActiveElement: u$24 }) {
	let a$27 = f$2(), n$16 = !!(o$19 & 4);
	E$2(t$12 == null ? void 0 : t$12.defaultView, "focus", (s$19) => {
		if (!n$16 || !a$27.current) return;
		let f$21 = x$6(r$20);
		n$13(e$8.current) && f$21.add(e$8.current);
		let l$17 = u$24.current;
		if (!l$17) return;
		let T$9 = s$19.target;
		n$13(T$9) ? I$4(f$21, T$9) ? (u$24.current = T$9, w$7(T$9)) : (s$19.preventDefault(), s$19.stopPropagation(), w$7(l$17)) : w$7(u$24.current);
	}, !0);
}
function I$4(o$19, t$12) {
	for (let e$8 of o$19) if (e$8.contains(t$12)) return !0;
	return !1;
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/transition/transition.js
function ue$2(e$8) {
	var t$12;
	return !!(e$8.enter || e$8.enterFrom || e$8.enterTo || e$8.leave || e$8.leaveFrom || e$8.leaveTo) || !b$5((t$12 = e$8.as) != null ? t$12 : de$2) || import_react.Children.count(e$8.children) === 1;
}
var V$4 = (0, import_react.createContext)(null);
V$4.displayName = "TransitionContext";
var De$3 = ((n$16) => (n$16.Visible = "visible", n$16.Hidden = "hidden", n$16))(De$3 || {});
function He$3() {
	let e$8 = (0, import_react.useContext)(V$4);
	if (e$8 === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
	return e$8;
}
function Ae$4() {
	let e$8 = (0, import_react.useContext)(w$6);
	if (e$8 === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
	return e$8;
}
var w$6 = (0, import_react.createContext)(null);
w$6.displayName = "NestingContext";
function M$5(e$8) {
	return "children" in e$8 ? M$5(e$8.children) : e$8.current.filter(({ el: t$12 }) => t$12.current !== null).filter(({ state: t$12 }) => t$12 === "visible").length > 0;
}
function Te$3(e$8, t$12) {
	let n$16 = s(e$8), l$17 = (0, import_react.useRef)([]), S$9 = f$2(), R$6 = p(), d$13 = o((o$19, i$15 = C$5.Hidden) => {
		let a$27 = l$17.current.findIndex(({ el: s$19 }) => s$19 === o$19);
		a$27 !== -1 && (u$2(i$15, {
			[C$5.Unmount]() {
				l$17.current.splice(a$27, 1);
			},
			[C$5.Hidden]() {
				l$17.current[a$27].state = "hidden";
			}
		}), R$6.microTask(() => {
			var s$19;
			!M$5(l$17) && S$9.current && ((s$19 = n$16.current) == null || s$19.call(n$16));
		}));
	}), y$9 = o((o$19) => {
		let i$15 = l$17.current.find(({ el: a$27 }) => a$27 === o$19);
		return i$15 ? i$15.state !== "visible" && (i$15.state = "visible") : l$17.current.push({
			el: o$19,
			state: "visible"
		}), () => d$13(o$19, C$5.Unmount);
	}), C$10 = (0, import_react.useRef)([]), p$12 = (0, import_react.useRef)(Promise.resolve()), h$14 = (0, import_react.useRef)({
		enter: [],
		leave: []
	}), g$8 = o((o$19, i$15, a$27) => {
		C$10.current.splice(0), t$12 && (t$12.chains.current[i$15] = t$12.chains.current[i$15].filter(([s$19]) => s$19 !== o$19)), t$12?.chains.current[i$15].push([o$19, new Promise((s$19) => {
			C$10.current.push(s$19);
		})]), t$12?.chains.current[i$15].push([o$19, new Promise((s$19) => {
			Promise.all(h$14.current[i$15].map(([r$20, f$21]) => f$21)).then(() => s$19());
		})]), i$15 === "enter" ? p$12.current = p$12.current.then(() => t$12 == null ? void 0 : t$12.wait.current).then(() => a$27(i$15)) : a$27(i$15);
	}), v$10 = o((o$19, i$15, a$27) => {
		Promise.all(h$14.current[i$15].splice(0).map(([s$19, r$20]) => r$20)).then(() => {
			var s$19;
			(s$19 = C$10.current.shift()) == null || s$19();
		}).then(() => a$27(i$15));
	});
	return (0, import_react.useMemo)(() => ({
		children: l$17,
		register: y$9,
		unregister: d$13,
		onStart: g$8,
		onStop: v$10,
		wait: p$12,
		chains: h$14
	}), [
		y$9,
		d$13,
		l$17,
		g$8,
		v$10,
		h$14,
		p$12
	]);
}
var de$2 = import_react.Fragment, fe$5 = A$1.RenderStrategy;
function Fe$5(e$8, t$12) {
	var ee$6, te$6;
	let { transition: n$16 = !0, beforeEnter: l$17, afterEnter: S$9, beforeLeave: R$6, afterLeave: d$13, enter: y$9, enterFrom: C$10, enterTo: p$12, entered: h$14, leave: g$8, leaveFrom: v$10, leaveTo: o$19,...i$15 } = e$8, [a$27, s$19] = (0, import_react.useState)(null), r$20 = (0, import_react.useRef)(null), f$21 = ue$2(e$8), U$2 = y$1(...f$21 ? [
		r$20,
		t$12,
		s$19
	] : t$12 === null ? [] : [t$12]), H$8 = (ee$6 = i$15.unmount) == null || ee$6 ? C$5.Unmount : C$5.Hidden, { show: u$24, appear: z$3, initial: K$3 } = He$3(), [m$9, j$9] = (0, import_react.useState)(u$24 ? "visible" : "hidden"), Q$7 = Ae$4(), { register: A$4, unregister: F$6 } = Q$7;
	n$1(() => A$4(r$20), [A$4, r$20]), n$1(() => {
		if (H$8 === C$5.Hidden && r$20.current) {
			if (u$24 && m$9 !== "visible") {
				j$9("visible");
				return;
			}
			return u$2(m$9, {
				["hidden"]: () => F$6(r$20),
				["visible"]: () => A$4(r$20)
			});
		}
	}, [
		m$9,
		r$20,
		A$4,
		F$6,
		u$24,
		H$8
	]);
	let G$5 = l$5();
	n$1(() => {
		if (f$21 && G$5 && m$9 === "visible" && r$20.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
	}, [
		r$20,
		m$9,
		G$5,
		f$21
	]);
	let ce$2 = K$3 && !z$3, Y$4 = z$3 && u$24 && K$3, B$3 = (0, import_react.useRef)(!1), I$9 = Te$3(() => {
		B$3.current || (j$9("hidden"), F$6(r$20));
	}, Q$7), Z$3 = o((W$4) => {
		B$3.current = !0;
		let L$6 = W$4 ? "enter" : "leave";
		I$9.onStart(r$20, L$6, (_$10) => {
			_$10 === "enter" ? l$17?.() : _$10 === "leave" && R$6?.();
		});
	}), $$5 = o((W$4) => {
		let L$6 = W$4 ? "enter" : "leave";
		B$3.current = !1, I$9.onStop(r$20, L$6, (_$10) => {
			_$10 === "enter" ? S$9?.() : _$10 === "leave" && d$13?.();
		}), L$6 === "leave" && !M$5(I$9) && (j$9("hidden"), F$6(r$20));
	});
	(0, import_react.useEffect)(() => {
		f$21 && n$16 || (Z$3(u$24), $$5(u$24));
	}, [
		u$24,
		f$21,
		n$16
	]);
	let pe$3 = (() => !(!n$16 || !f$21 || !G$5 || ce$2))(), [, T$9] = N$1(pe$3, a$27, u$24, {
		start: Z$3,
		end: $$5
	}), Ce$4 = m({
		ref: U$2,
		className: ((te$6 = t$3(i$15.className, Y$4 && y$9, Y$4 && C$10, T$9.enter && y$9, T$9.enter && T$9.closed && C$10, T$9.enter && !T$9.closed && p$12, T$9.leave && g$8, T$9.leave && !T$9.closed && v$10, T$9.leave && T$9.closed && o$19, !T$9.transition && u$24 && h$14)) == null ? void 0 : te$6.trim()) || void 0,
		...x$1(T$9)
	}), N$3 = 0;
	m$9 === "visible" && (N$3 |= i$1.Open), m$9 === "hidden" && (N$3 |= i$1.Closed), u$24 && m$9 === "hidden" && (N$3 |= i$1.Opening), !u$24 && m$9 === "visible" && (N$3 |= i$1.Closing);
	let he$2 = K();
	return import_react.createElement(w$6.Provider, { value: I$9 }, import_react.createElement(c$2, { value: N$3 }, he$2({
		ourProps: Ce$4,
		theirProps: i$15,
		defaultTag: de$2,
		features: fe$5,
		visible: m$9 === "visible",
		name: "Transition.Child"
	})));
}
function Ie$3(e$8, t$12) {
	let { show: n$16, appear: l$17 = !1, unmount: S$9 = !0,...R$6 } = e$8, d$13 = (0, import_react.useRef)(null), y$9 = ue$2(e$8), C$10 = y$1(...y$9 ? [d$13, t$12] : t$12 === null ? [] : [t$12]);
	l$5();
	let p$12 = u$6();
	if (n$16 === void 0 && p$12 !== null && (n$16 = (p$12 & i$1.Open) === i$1.Open), n$16 === void 0) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
	let [h$14, g$8] = (0, import_react.useState)(n$16 ? "visible" : "hidden"), v$10 = Te$3(() => {
		n$16 || g$8("hidden");
	}), [o$19, i$15] = (0, import_react.useState)(!0), a$27 = (0, import_react.useRef)([n$16]);
	n$1(() => {
		o$19 !== !1 && a$27.current[a$27.current.length - 1] !== n$16 && (a$27.current.push(n$16), i$15(!1));
	}, [a$27, n$16]);
	let s$19 = (0, import_react.useMemo)(() => ({
		show: n$16,
		appear: l$17,
		initial: o$19
	}), [
		n$16,
		l$17,
		o$19
	]);
	n$1(() => {
		n$16 ? g$8("visible") : !M$5(v$10) && d$13.current !== null && g$8("hidden");
	}, [n$16, v$10]);
	let r$20 = { unmount: S$9 }, f$21 = o(() => {
		var u$24;
		o$19 && i$15(!1), (u$24 = e$8.beforeEnter) == null || u$24.call(e$8);
	}), U$2 = o(() => {
		var u$24;
		o$19 && i$15(!1), (u$24 = e$8.beforeLeave) == null || u$24.call(e$8);
	}), H$8 = K();
	return import_react.createElement(w$6.Provider, { value: v$10 }, import_react.createElement(V$4.Provider, { value: s$19 }, H$8({
		ourProps: {
			...r$20,
			as: import_react.Fragment,
			children: import_react.createElement(me$2, {
				ref: C$10,
				...r$20,
				...R$6,
				beforeEnter: f$21,
				beforeLeave: U$2
			})
		},
		theirProps: {},
		defaultTag: import_react.Fragment,
		features: fe$5,
		visible: h$14 === "visible",
		name: "Transition"
	})));
}
function Le$3(e$8, t$12) {
	let n$16 = (0, import_react.useContext)(V$4) !== null, l$17 = u$6() !== null;
	return import_react.createElement(import_react.Fragment, null, !n$16 && l$17 ? import_react.createElement(X$3, {
		ref: t$12,
		...e$8
	}) : import_react.createElement(me$2, {
		ref: t$12,
		...e$8
	}));
}
var X$3 = Y(Ie$3), me$2 = Y(Fe$5), Oe = Y(Le$3), Ke$3 = Object.assign(X$3, {
	Child: Oe,
	Root: X$3
});

//#endregion
//#region node_modules/@headlessui/react/dist/components/dialog/dialog.js
var we$3 = ((o$19) => (o$19[o$19.Open = 0] = "Open", o$19[o$19.Closed = 1] = "Closed", o$19))(we$3 || {}), Be$2 = ((t$12) => (t$12[t$12.SetTitleId = 0] = "SetTitleId", t$12))(Be$2 || {});
var Ue$2 = { [0](e$8, t$12) {
	return e$8.titleId === t$12.id ? e$8 : {
		...e$8,
		titleId: t$12.id
	};
} }, w$5 = (0, import_react.createContext)(null);
w$5.displayName = "DialogContext";
function O(e$8) {
	let t$12 = (0, import_react.useContext)(w$5);
	if (t$12 === null) {
		let o$19 = /* @__PURE__ */ new Error(`<${e$8} /> is missing a parent <Dialog /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(o$19, O), o$19;
	}
	return t$12;
}
function He$2(e$8, t$12) {
	return u$2(t$12.type, Ue$2, e$8, t$12);
}
var z$2 = Y(function(t$12, o$19) {
	let a$27 = (0, import_react.useId)(), { id: n$16 = `headlessui-dialog-${a$27}`, open: i$15, onClose: p$12, initialFocus: d$13, role: s$19 = "dialog", autoFocus: f$21 = !0, __demoMode: u$24 = !1, unmount: y$9 = !1,...S$9 } = t$12, R$6 = (0, import_react.useRef)(!1);
	s$19 = function() {
		return s$19 === "dialog" || s$19 === "alertdialog" ? s$19 : (R$6.current || (R$6.current = !0, console.warn(`Invalid role [${s$19}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
	}();
	let g$8 = u$6();
	i$15 === void 0 && g$8 !== null && (i$15 = (g$8 & i$1.Open) === i$1.Open);
	let T$9 = (0, import_react.useRef)(null), I$9 = y$1(T$9, o$19), F$6 = u$4(T$9.current), c$20 = i$15 ? 0 : 1, [b$13, Q$7] = (0, import_react.useReducer)(He$2, {
		titleId: null,
		descriptionId: null,
		panelRef: (0, import_react.createRef)()
	}), m$9 = o(() => p$12(!1)), B$3 = o((r$20) => Q$7({
		type: 0,
		id: r$20
	})), D$11 = l$5() ? c$20 === 0 : !1, [Z$3, ee$6] = ee$2(), te$6 = { get current() {
		var r$20;
		return (r$20 = b$13.panelRef.current) != null ? r$20 : T$9.current;
	} }, v$10 = x(), { resolveContainers: M$11 } = S({
		mainTreeNode: v$10,
		portals: Z$3,
		defaultContainers: [te$6]
	}), U$2 = g$8 !== null ? (g$8 & i$1.Closing) === i$1.Closing : !1;
	y$2(u$24 || U$2 ? !1 : D$11, {
		allowed: o(() => {
			var r$20, W$4;
			return [(W$4 = (r$20 = T$9.current) == null ? void 0 : r$20.closest("[data-headlessui-portal]")) != null ? W$4 : null];
		}),
		disallowed: o(() => {
			var r$20;
			return [(r$20 = v$10 == null ? void 0 : v$10.closest("body > *:not(#headlessui-portal-root)")) != null ? r$20 : null];
		})
	});
	let P$7 = x$3.get(null);
	n$1(() => {
		if (D$11) return P$7.actions.push(n$16), () => P$7.actions.pop(n$16);
	}, [
		P$7,
		n$16,
		D$11
	]);
	let H$8 = S$1(P$7, (0, import_react.useCallback)((r$20) => P$7.selectors.isTop(r$20, n$16), [P$7, n$16]));
	k$1(H$8, M$11, (r$20) => {
		r$20.preventDefault(), m$9();
	}), a$9(H$8, F$6 == null ? void 0 : F$6.defaultView, (r$20) => {
		r$20.preventDefault(), r$20.stopPropagation(), document.activeElement && "blur" in document.activeElement && typeof document.activeElement.blur == "function" && document.activeElement.blur(), m$9();
	}), f$3(u$24 || U$2 ? !1 : D$11, F$6, M$11), p$1(D$11, T$9, m$9);
	let [oe$5, ne$3] = H$1(), re$4 = (0, import_react.useMemo)(() => [{
		dialogState: c$20,
		close: m$9,
		setTitleId: B$3,
		unmount: y$9
	}, b$13], [
		c$20,
		m$9,
		B$3,
		y$9,
		b$13
	]), N$3 = n({ open: c$20 === 0 }), le$1 = {
		ref: I$9,
		id: n$16,
		role: s$19,
		tabIndex: -1,
		"aria-modal": u$24 ? void 0 : c$20 === 0 ? !0 : void 0,
		"aria-labelledby": b$13.titleId,
		"aria-describedby": oe$5,
		unmount: y$9
	}, ae$4 = !f$9(), E$13 = G.None;
	D$11 && !u$24 && (E$13 |= G.RestoreFocus, E$13 |= G.TabLock, f$21 && (E$13 |= G.AutoFocus), ae$4 && (E$13 |= G.InitialFocus));
	let ie$3 = K();
	return import_react.createElement(s$5, null, import_react.createElement(l$6, { force: !0 }, import_react.createElement(te, null, import_react.createElement(w$5.Provider, { value: re$4 }, import_react.createElement(X$2, { target: T$9 }, import_react.createElement(l$6, { force: !1 }, import_react.createElement(ne$3, { slot: N$3 }, import_react.createElement(ee$6, null, import_react.createElement(ge, {
		initialFocus: d$13,
		initialFocusFallback: T$9,
		containers: M$11,
		features: E$13
	}, import_react.createElement(C$1, { value: m$9 }, ie$3({
		ourProps: le$1,
		theirProps: S$9,
		slot: N$3,
		defaultTag: Ne$3,
		features: We$2,
		visible: c$20 === 0,
		name: "Dialog"
	})))))))))));
}), Ne$3 = "div", We$2 = A$1.RenderStrategy | A$1.Static;
function $e$1(e$8, t$12) {
	let { transition: o$19 = !1, open: a$27,...n$16 } = e$8, i$15 = u$6(), p$12 = e$8.hasOwnProperty("open") || i$15 !== null, d$13 = e$8.hasOwnProperty("onClose");
	if (!p$12 && !d$13) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
	if (!p$12) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
	if (!d$13) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
	if (!i$15 && typeof e$8.open != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${e$8.open}`);
	if (typeof e$8.onClose != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${e$8.onClose}`);
	return (a$27 !== void 0 || o$19) && !n$16.static ? import_react.createElement(j$1, null, import_react.createElement(Ke$3, {
		show: a$27,
		transition: o$19,
		unmount: n$16.unmount
	}, import_react.createElement(z$2, {
		ref: t$12,
		...n$16
	}))) : import_react.createElement(j$1, null, import_react.createElement(z$2, {
		ref: t$12,
		open: a$27,
		...n$16
	}));
}
var je$2 = "div";
function Ye(e$8, t$12) {
	let o$19 = (0, import_react.useId)(), { id: a$27 = `headlessui-dialog-panel-${o$19}`, transition: n$16 = !1,...i$15 } = e$8, [{ dialogState: p$12, unmount: d$13 }, s$19] = O("Dialog.Panel"), f$21 = y$1(t$12, s$19.panelRef), u$24 = n({ open: p$12 === 0 }), y$9 = o((I$9) => {
		I$9.stopPropagation();
	}), S$9 = {
		ref: f$21,
		id: a$27,
		onClick: y$9
	}, R$6 = n$16 ? Oe : import_react.Fragment, g$8 = n$16 ? { unmount: d$13 } : {}, T$9 = K();
	return import_react.createElement(R$6, { ...g$8 }, T$9({
		ourProps: S$9,
		theirProps: i$15,
		slot: u$24,
		defaultTag: je$2,
		name: "Dialog.Panel"
	}));
}
var Je = "div";
function Ke$4(e$8, t$12) {
	let { transition: o$19 = !1,...a$27 } = e$8, [{ dialogState: n$16, unmount: i$15 }] = O("Dialog.Backdrop"), p$12 = n({ open: n$16 === 0 }), d$13 = {
		ref: t$12,
		"aria-hidden": !0
	}, s$19 = o$19 ? Oe : import_react.Fragment, f$21 = o$19 ? { unmount: i$15 } : {}, u$24 = K();
	return import_react.createElement(s$19, { ...f$21 }, u$24({
		ourProps: d$13,
		theirProps: a$27,
		slot: p$12,
		defaultTag: Je,
		name: "Dialog.Backdrop"
	}));
}
var Xe$1 = "h2";
function Ve$1(e$8, t$12) {
	let o$19 = (0, import_react.useId)(), { id: a$27 = `headlessui-dialog-title-${o$19}`,...n$16 } = e$8, [{ dialogState: i$15, setTitleId: p$12 }] = O("Dialog.Title"), d$13 = y$1(t$12);
	(0, import_react.useEffect)(() => (p$12(a$27), () => p$12(null)), [a$27, p$12]);
	let s$19 = n({ open: i$15 === 0 }), f$21 = {
		ref: d$13,
		id: a$27
	};
	return K()({
		ourProps: f$21,
		theirProps: n$16,
		slot: s$19,
		defaultTag: Xe$1,
		name: "Dialog.Title"
	});
}
var qe = Y($e$1), ze = Y(Ye), Lt = Y(Ke$4), Qe = Y(Ve$1), xt = M, ht = Object.assign(qe, {
	Panel: ze,
	Title: Qe,
	Description: M
});

//#endregion
//#region node_modules/@headlessui/react/dist/utils/start-transition.js
var t$2;
var a$8 = (t$2 = import_react.startTransition) != null ? t$2 : function(i$15) {
	i$15();
};

//#endregion
//#region node_modules/@headlessui/react/dist/components/disclosure/disclosure.js
var me$1 = ((l$17) => (l$17[l$17.Open = 0] = "Open", l$17[l$17.Closed = 1] = "Closed", l$17))(me$1 || {}), fe$3 = ((n$16) => (n$16[n$16.ToggleDisclosure = 0] = "ToggleDisclosure", n$16[n$16.CloseDisclosure = 1] = "CloseDisclosure", n$16[n$16.SetButtonId = 2] = "SetButtonId", n$16[n$16.SetPanelId = 3] = "SetPanelId", n$16[n$16.SetButtonElement = 4] = "SetButtonElement", n$16[n$16.SetPanelElement = 5] = "SetPanelElement", n$16))(fe$3 || {});
var De$2 = {
	[0]: (e$8) => ({
		...e$8,
		disclosureState: u$2(e$8.disclosureState, {
			[0]: 1,
			[1]: 0
		})
	}),
	[1]: (e$8) => e$8.disclosureState === 1 ? e$8 : {
		...e$8,
		disclosureState: 1
	},
	[2](e$8, t$12) {
		return e$8.buttonId === t$12.buttonId ? e$8 : {
			...e$8,
			buttonId: t$12.buttonId
		};
	},
	[3](e$8, t$12) {
		return e$8.panelId === t$12.panelId ? e$8 : {
			...e$8,
			panelId: t$12.panelId
		};
	},
	[4](e$8, t$12) {
		return e$8.buttonElement === t$12.element ? e$8 : {
			...e$8,
			buttonElement: t$12.element
		};
	},
	[5](e$8, t$12) {
		return e$8.panelElement === t$12.element ? e$8 : {
			...e$8,
			panelElement: t$12.element
		};
	}
}, _$3 = (0, import_react.createContext)(null);
_$3.displayName = "DisclosureContext";
function M$4(e$8) {
	let t$12 = (0, import_react.useContext)(_$3);
	if (t$12 === null) {
		let l$17 = /* @__PURE__ */ new Error(`<${e$8} /> is missing a parent <Disclosure /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(l$17, M$4), l$17;
	}
	return t$12;
}
var F$3 = (0, import_react.createContext)(null);
F$3.displayName = "DisclosureAPIContext";
function V$3(e$8) {
	let t$12 = (0, import_react.useContext)(F$3);
	if (t$12 === null) {
		let l$17 = /* @__PURE__ */ new Error(`<${e$8} /> is missing a parent <Disclosure /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(l$17, V$3), l$17;
	}
	return t$12;
}
var H$4 = (0, import_react.createContext)(null);
H$4.displayName = "DisclosurePanelContext";
function ye$2() {
	return (0, import_react.useContext)(H$4);
}
function Pe(e$8, t$12) {
	return u$2(t$12.type, De$2, e$8, t$12);
}
var Ee = import_react.Fragment;
function Se$3(e$8, t$12) {
	let { defaultOpen: l$17 = !1,...p$12 } = e$8, a$27 = (0, import_react.useRef)(null), c$20 = y$1(t$12, T$1((u$24) => {
		a$27.current = u$24;
	}, e$8.as === void 0 || b$5(e$8.as))), n$16 = (0, import_react.useReducer)(Pe, {
		disclosureState: l$17 ? 0 : 1,
		buttonElement: null,
		panelElement: null,
		buttonId: null,
		panelId: null
	}), [{ disclosureState: o$19, buttonId: r$20 }, f$21] = n$16, s$19 = o((u$24) => {
		f$21({ type: 1 });
		let m$9 = l$1(a$27.current);
		if (!m$9 || !r$20) return;
		(() => u$24 ? i$11(u$24) ? u$24 : "current" in u$24 && i$11(u$24.current) ? u$24.current : m$9.getElementById(r$20) : m$9.getElementById(r$20))()?.focus();
	}), E$13 = (0, import_react.useMemo)(() => ({ close: s$19 }), [s$19]), T$9 = n({
		open: o$19 === 0,
		close: s$19
	}), D$11 = { ref: c$20 }, S$9 = K();
	return import_react.createElement(_$3.Provider, { value: n$16 }, import_react.createElement(F$3.Provider, { value: E$13 }, import_react.createElement(C$1, { value: s$19 }, import_react.createElement(c$2, { value: u$2(o$19, {
		[0]: i$1.Open,
		[1]: i$1.Closed
	}) }, S$9({
		ourProps: D$11,
		theirProps: p$12,
		slot: T$9,
		defaultTag: Ee,
		name: "Disclosure"
	})))));
}
var ge$2 = "button";
function Ae$3(e$8, t$12) {
	let l$17 = (0, import_react.useId)(), { id: p$12 = `headlessui-disclosure-button-${l$17}`, disabled: a$27 = !1, autoFocus: c$20 = !1,...n$16 } = e$8, [o$19, r$20] = M$4("Disclosure.Button"), f$21 = ye$2(), s$19 = f$21 === null ? !1 : f$21 === o$19.panelId, E$13 = (0, import_react.useRef)(null), T$9 = y$1(E$13, t$12, o((i$15) => {
		if (!s$19) return r$20({
			type: 4,
			element: i$15
		});
	}));
	(0, import_react.useEffect)(() => {
		if (!s$19) return r$20({
			type: 2,
			buttonId: p$12
		}), () => {
			r$20({
				type: 2,
				buttonId: null
			});
		};
	}, [
		p$12,
		r$20,
		s$19
	]);
	let D$11 = o((i$15) => {
		var g$8;
		if (s$19) {
			if (o$19.disclosureState === 1) return;
			switch (i$15.key) {
				case o$1.Space:
				case o$1.Enter:
					i$15.preventDefault(), i$15.stopPropagation(), r$20({ type: 0 }), (g$8 = o$19.buttonElement) == null || g$8.focus();
					break;
			}
		} else switch (i$15.key) {
			case o$1.Space:
			case o$1.Enter:
				i$15.preventDefault(), i$15.stopPropagation(), r$20({ type: 0 });
				break;
		}
	}), S$9 = o((i$15) => {
		switch (i$15.key) {
			case o$1.Space:
				i$15.preventDefault();
				break;
		}
	}), u$24 = o((i$15) => {
		var g$8;
		s$4(i$15.currentTarget) || a$27 || (s$19 ? (r$20({ type: 0 }), (g$8 = o$19.buttonElement) == null || g$8.focus()) : r$20({ type: 0 }));
	}), { isFocusVisible: m$9, focusProps: d$13 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: c$20 }), { isHovered: C$10, hoverProps: h$14 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: a$27 }), { pressed: $$5, pressProps: U$2 } = w$1({ disabled: a$27 }), J$3 = n({
		open: o$19.disclosureState === 0,
		hover: C$10,
		active: $$5,
		disabled: a$27,
		focus: m$9,
		autofocus: c$20
	}), G$5 = e(e$8, o$19.buttonElement), X$4 = s$19 ? V({
		ref: T$9,
		type: G$5,
		disabled: a$27 || void 0,
		autoFocus: c$20,
		onKeyDown: D$11,
		onClick: u$24
	}, d$13, h$14, U$2) : V({
		ref: T$9,
		id: p$12,
		type: G$5,
		"aria-expanded": o$19.disclosureState === 0,
		"aria-controls": o$19.panelElement ? o$19.panelId : void 0,
		disabled: a$27 || void 0,
		autoFocus: c$20,
		onKeyDown: D$11,
		onKeyUp: S$9,
		onClick: u$24
	}, d$13, h$14, U$2);
	return K()({
		ourProps: X$4,
		theirProps: n$16,
		slot: J$3,
		defaultTag: ge$2,
		name: "Disclosure.Button"
	});
}
var be$1 = "div", Ce$3 = A$1.RenderStrategy | A$1.Static;
function Re$2(e$8, t$12) {
	let l$17 = (0, import_react.useId)(), { id: p$12 = `headlessui-disclosure-panel-${l$17}`, transition: a$27 = !1,...c$20 } = e$8, [n$16, o$19] = M$4("Disclosure.Panel"), { close: r$20 } = V$3("Disclosure.Panel"), [f$21, s$19] = (0, import_react.useState)(null), E$13 = y$1(t$12, o((C$10) => {
		a$8(() => o$19({
			type: 5,
			element: C$10
		}));
	}), s$19);
	(0, import_react.useEffect)(() => (o$19({
		type: 3,
		panelId: p$12
	}), () => {
		o$19({
			type: 3,
			panelId: null
		});
	}), [p$12, o$19]);
	let T$9 = u$6(), [D$11, S$9] = N$1(a$27, f$21, T$9 !== null ? (T$9 & i$1.Open) === i$1.Open : n$16.disclosureState === 0), u$24 = n({
		open: n$16.disclosureState === 0,
		close: r$20
	}), m$9 = {
		ref: E$13,
		id: p$12,
		...x$1(S$9)
	}, d$13 = K();
	return import_react.createElement(s$5, null, import_react.createElement(H$4.Provider, { value: n$16.panelId }, d$13({
		ourProps: m$9,
		theirProps: c$20,
		slot: u$24,
		defaultTag: be$1,
		features: Ce$3,
		visible: D$11,
		name: "Disclosure.Panel"
	})));
}
var Ie$2 = Y(Se$3), xe = Y(Ae$3), Le = Y(Re$2), Xe = Object.assign(Ie$2, {
	Button: xe,
	Panel: Le
});

//#endregion
//#region node_modules/@headlessui/react/dist/components/field/field.js
var _$2 = "div";
function c$7(d$13, l$17) {
	let t$12 = `headlessui-control-${(0, import_react.useId)()}`, [p$12, s$19] = V$2(), [n$16, a$27] = H$1(), m$9 = a(), { disabled: r$20 = m$9 || !1,...o$19 } = d$13, i$15 = n({ disabled: r$20 }), F$6 = {
		ref: l$17,
		disabled: r$20 || void 0,
		"aria-disabled": r$20 || void 0
	}, T$9 = K();
	return import_react.createElement(l$3, { value: r$20 }, import_react.createElement(s$19, { value: p$12 }, import_react.createElement(a$27, { value: n$16 }, import_react.createElement(f$8, { id: t$12 }, T$9({
		ourProps: F$6,
		theirProps: {
			...o$19,
			children: import_react.createElement(W$2, null, typeof o$19.children == "function" ? o$19.children(i$15) : o$19.children)
		},
		slot: i$15,
		defaultTag: _$2,
		name: "Field"
	})))));
}
var W = Y(c$7);

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-resolved-tag.js
function d$3(t$12) {
	let e$8 = typeof t$12 == "string" ? t$12 : void 0, [s$19, o$19] = (0, import_react.useState)(e$8);
	return [e$8 != null ? e$8 : s$19, (0, import_react.useCallback)((n$16) => {
		e$8 || n$13(n$16) && o$19(n$16.tagName.toLowerCase());
	}, [e$8])];
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/fieldset/fieldset.js
var d$4 = "fieldset";
function _$1(t$12, a$27) {
	var s$19;
	let i$15 = a(), { disabled: e$8 = i$15 || !1,...p$12 } = t$12, [n$16, T$9] = d$3((s$19 = t$12.as) != null ? s$19 : d$4), l$17 = y$1(a$27, T$9), [r$20, f$21] = V$2(), m$9 = n({ disabled: e$8 }), y$9 = n$16 === "fieldset" ? {
		ref: l$17,
		"aria-labelledby": r$20,
		disabled: e$8 || void 0
	} : {
		ref: l$17,
		role: "group",
		"aria-labelledby": r$20,
		"aria-disabled": e$8 || void 0
	}, F$6 = K();
	return import_react.createElement(l$3, { value: e$8 }, import_react.createElement(f$21, null, F$6({
		ourProps: y$9,
		theirProps: p$12,
		slot: m$9,
		defaultTag: d$4,
		name: "Fieldset"
	})));
}
var I = Y(_$1);

//#endregion
//#region node_modules/@headlessui/react/dist/components/input/input.js
var x$5 = "input";
function h$5(r$20, p$12) {
	let n$16 = (0, import_react.useId)(), s$19 = u$1(), a$27 = a(), { id: l$17 = s$19 || `headlessui-input-${n$16}`, disabled: e$8 = a$27 || !1, autoFocus: o$19 = !1, invalid: t$12 = !1,...i$15 } = r$20, d$13 = N(), u$24 = w(), { isFocused: f$21, focusProps: m$9 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: o$19 }), { isHovered: T$9, hoverProps: b$13 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e$8 }), y$9 = V({
		ref: p$12,
		id: l$17,
		"aria-labelledby": d$13,
		"aria-describedby": u$24,
		"aria-invalid": t$12 ? "true" : void 0,
		disabled: e$8 || void 0,
		autoFocus: o$19
	}, m$9, b$13), I$9 = n({
		disabled: e$8,
		invalid: t$12,
		hover: T$9,
		focus: f$21,
		autofocus: o$19
	});
	return K()({
		ourProps: y$9,
		theirProps: i$15,
		slot: I$9,
		defaultTag: x$5,
		name: "Input"
	});
}
var X = Y(h$5);

//#endregion
//#region node_modules/@headlessui/react/dist/components/legend/legend.js
function o$5(t$12, n$16) {
	return import_react.createElement(Z, {
		as: "div",
		ref: n$16,
		...t$12
	});
}
var d = Y(o$5);

//#endregion
//#region node_modules/@headlessui/react/dist/utils/get-text-value.js
var a$6 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$4(e$8) {
	var l$17, n$16;
	let i$15 = (l$17 = e$8.innerText) != null ? l$17 : "", t$12 = e$8.cloneNode(!0);
	if (!n$13(t$12)) return i$15;
	let u$24 = !1;
	for (let f$21 of t$12.querySelectorAll("[hidden],[aria-hidden],[role=\"img\"]")) f$21.remove(), u$24 = !0;
	let r$20 = u$24 ? (n$16 = t$12.innerText) != null ? n$16 : "" : i$15;
	return a$6.test(r$20) && (r$20 = r$20.replace(a$6, "")), r$20;
}
function F$2(e$8) {
	let i$15 = e$8.getAttribute("aria-label");
	if (typeof i$15 == "string") return i$15.trim();
	let t$12 = e$8.getAttribute("aria-labelledby");
	if (t$12) {
		let u$24 = t$12.split(" ").map((r$20) => {
			let l$17 = document.getElementById(r$20);
			if (l$17) {
				let n$16 = l$17.getAttribute("aria-label");
				return typeof n$16 == "string" ? n$16.trim() : o$4(l$17).trim();
			}
			return null;
		}).filter(Boolean);
		if (u$24.length > 0) return u$24.join(", ");
	}
	return o$4(e$8).trim();
}

//#endregion
//#region node_modules/@headlessui/react/dist/hooks/use-text-value.js
function s$7(c$20) {
	let t$12 = (0, import_react.useRef)(""), r$20 = (0, import_react.useRef)("");
	return o(() => {
		let e$8 = c$20.current;
		if (!e$8) return "";
		let u$24 = e$8.innerText;
		if (t$12.current === u$24) return r$20.current;
		let n$16 = F$2(e$8).trim().toLowerCase();
		return t$12.current = u$24, r$20.current = n$16, n$16;
	});
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/listbox/listbox-machine.js
var T$3 = Object.defineProperty;
var y$4 = (e$8, o$19, t$12) => o$19 in e$8 ? T$3(e$8, o$19, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t$12
}) : e$8[o$19] = t$12;
var b$4 = (e$8, o$19, t$12) => (y$4(e$8, typeof o$19 != "symbol" ? o$19 + "" : o$19, t$12), t$12);
var F$1 = ((t$12) => (t$12[t$12.Open = 0] = "Open", t$12[t$12.Closed = 1] = "Closed", t$12))(F$1 || {}), P$1 = ((t$12) => (t$12[t$12.Single = 0] = "Single", t$12[t$12.Multi = 1] = "Multi", t$12))(P$1 || {}), C$4 = ((t$12) => (t$12[t$12.Pointer = 0] = "Pointer", t$12[t$12.Other = 1] = "Other", t$12))(C$4 || {}), k$6 = ((r$20) => (r$20[r$20.OpenListbox = 0] = "OpenListbox", r$20[r$20.CloseListbox = 1] = "CloseListbox", r$20[r$20.GoToOption = 2] = "GoToOption", r$20[r$20.Search = 3] = "Search", r$20[r$20.ClearSearch = 4] = "ClearSearch", r$20[r$20.SelectOption = 5] = "SelectOption", r$20[r$20.RegisterOptions = 6] = "RegisterOptions", r$20[r$20.UnregisterOptions = 7] = "UnregisterOptions", r$20[r$20.SetButtonElement = 8] = "SetButtonElement", r$20[r$20.SetOptionsElement = 9] = "SetOptionsElement", r$20[r$20.SortOptions = 10] = "SortOptions", r$20[r$20.MarkButtonAsMoved = 11] = "MarkButtonAsMoved", r$20))(k$6 || {});
function g$2(e$8, o$19 = (t$13) => t$13) {
	let t$12 = e$8.activeOptionIndex !== null ? e$8.options[e$8.activeOptionIndex] : null, n$16 = G$2(o$19(e$8.options.slice()), (s$19) => s$19.dataRef.current.domRef.current), i$15 = t$12 ? n$16.indexOf(t$12) : null;
	return i$15 === -1 && (i$15 = null), {
		options: n$16,
		activeOptionIndex: i$15
	};
}
var D$2 = {
	[1](e$8) {
		if (e$8.dataRef.current.disabled || e$8.listboxState === 1) return e$8;
		let o$19 = e$8.buttonElement ? c$5.Tracked(a$5(e$8.buttonElement)) : e$8.buttonPositionState;
		return {
			...e$8,
			activeOptionIndex: null,
			pendingFocus: { focus: c$4.Nothing },
			listboxState: 1,
			__demoMode: !1,
			buttonPositionState: o$19
		};
	},
	[0](e$8, o$19) {
		if (e$8.dataRef.current.disabled || e$8.listboxState === 0) return e$8;
		let t$12 = e$8.activeOptionIndex, { isSelected: n$16 } = e$8.dataRef.current, i$15 = e$8.options.findIndex((s$19) => n$16(s$19.dataRef.current.value));
		return i$15 !== -1 && (t$12 = i$15), {
			...e$8,
			frozenValue: !1,
			pendingFocus: o$19.focus,
			listboxState: 0,
			activeOptionIndex: t$12,
			__demoMode: !1,
			buttonPositionState: c$5.Idle
		};
	},
	[2](e$8, o$19) {
		var s$19, l$17, c$20, p$12, f$21;
		if (e$8.dataRef.current.disabled || e$8.listboxState === 1) return e$8;
		let t$12 = {
			...e$8,
			searchQuery: "",
			activationTrigger: (s$19 = o$19.trigger) != null ? s$19 : 1,
			__demoMode: !1
		};
		if (o$19.focus === c$4.Nothing) return {
			...t$12,
			activeOptionIndex: null
		};
		if (o$19.focus === c$4.Specific) return {
			...t$12,
			activeOptionIndex: e$8.options.findIndex((d$13) => d$13.id === o$19.id)
		};
		if (o$19.focus === c$4.Previous) {
			let d$13 = e$8.activeOptionIndex;
			if (d$13 !== null) {
				let O$4 = e$8.options[d$13].dataRef.current.domRef, r$20 = f$6(o$19, {
					resolveItems: () => e$8.options,
					resolveActiveIndex: () => e$8.activeOptionIndex,
					resolveId: (u$24) => u$24.id,
					resolveDisabled: (u$24) => u$24.dataRef.current.disabled
				});
				if (r$20 !== null) {
					let u$24 = e$8.options[r$20].dataRef.current.domRef;
					if (((l$17 = O$4.current) == null ? void 0 : l$17.previousElementSibling) === u$24.current || ((c$20 = u$24.current) == null ? void 0 : c$20.previousElementSibling) === null) return {
						...t$12,
						activeOptionIndex: r$20
					};
				}
			}
		} else if (o$19.focus === c$4.Next) {
			let d$13 = e$8.activeOptionIndex;
			if (d$13 !== null) {
				let O$4 = e$8.options[d$13].dataRef.current.domRef, r$20 = f$6(o$19, {
					resolveItems: () => e$8.options,
					resolveActiveIndex: () => e$8.activeOptionIndex,
					resolveId: (u$24) => u$24.id,
					resolveDisabled: (u$24) => u$24.dataRef.current.disabled
				});
				if (r$20 !== null) {
					let u$24 = e$8.options[r$20].dataRef.current.domRef;
					if (((p$12 = O$4.current) == null ? void 0 : p$12.nextElementSibling) === u$24.current || ((f$21 = u$24.current) == null ? void 0 : f$21.nextElementSibling) === null) return {
						...t$12,
						activeOptionIndex: r$20
					};
				}
			}
		}
		let n$16 = g$2(e$8), i$15 = f$6(o$19, {
			resolveItems: () => n$16.options,
			resolveActiveIndex: () => n$16.activeOptionIndex,
			resolveId: (d$13) => d$13.id,
			resolveDisabled: (d$13) => d$13.dataRef.current.disabled
		});
		return {
			...t$12,
			...n$16,
			activeOptionIndex: i$15
		};
	},
	[3]: (e$8, o$19) => {
		if (e$8.dataRef.current.disabled || e$8.listboxState === 1) return e$8;
		let n$16 = e$8.searchQuery !== "" ? 0 : 1, i$15 = e$8.searchQuery + o$19.value.toLowerCase(), l$17 = (e$8.activeOptionIndex !== null ? e$8.options.slice(e$8.activeOptionIndex + n$16).concat(e$8.options.slice(0, e$8.activeOptionIndex + n$16)) : e$8.options).find((p$12) => {
			var f$21;
			return !p$12.dataRef.current.disabled && ((f$21 = p$12.dataRef.current.textValue) == null ? void 0 : f$21.startsWith(i$15));
		}), c$20 = l$17 ? e$8.options.indexOf(l$17) : -1;
		return c$20 === -1 || c$20 === e$8.activeOptionIndex ? {
			...e$8,
			searchQuery: i$15
		} : {
			...e$8,
			searchQuery: i$15,
			activeOptionIndex: c$20,
			activationTrigger: 1
		};
	},
	[4](e$8) {
		return e$8.dataRef.current.disabled || e$8.listboxState === 1 || e$8.searchQuery === "" ? e$8 : {
			...e$8,
			searchQuery: ""
		};
	},
	[5](e$8) {
		return e$8.dataRef.current.mode === 0 ? {
			...e$8,
			frozenValue: !0
		} : { ...e$8 };
	},
	[6]: (e$8, o$19) => {
		let t$12 = e$8.options.concat(o$19.options), n$16 = e$8.activeOptionIndex;
		if (e$8.pendingFocus.focus !== c$4.Nothing && (n$16 = f$6(e$8.pendingFocus, {
			resolveItems: () => t$12,
			resolveActiveIndex: () => e$8.activeOptionIndex,
			resolveId: (i$15) => i$15.id,
			resolveDisabled: (i$15) => i$15.dataRef.current.disabled
		})), e$8.activeOptionIndex === null) {
			let { isSelected: i$15 } = e$8.dataRef.current;
			if (i$15) {
				let s$19 = t$12.findIndex((l$17) => i$15 == null ? void 0 : i$15(l$17.dataRef.current.value));
				s$19 !== -1 && (n$16 = s$19);
			}
		}
		return {
			...e$8,
			options: t$12,
			activeOptionIndex: n$16,
			pendingFocus: { focus: c$4.Nothing },
			pendingShouldSort: !0
		};
	},
	[7]: (e$8, o$19) => {
		let t$12 = e$8.options, n$16 = [], i$15 = new Set(o$19.options);
		for (let [s$19, l$17] of t$12.entries()) if (i$15.has(l$17.id) && (n$16.push(s$19), i$15.delete(l$17.id), i$15.size === 0)) break;
		if (n$16.length > 0) {
			t$12 = t$12.slice();
			for (let s$19 of n$16.reverse()) t$12.splice(s$19, 1);
		}
		return {
			...e$8,
			options: t$12,
			activationTrigger: 1
		};
	},
	[8]: (e$8, o$19) => e$8.buttonElement === o$19.element ? e$8 : {
		...e$8,
		buttonElement: o$19.element
	},
	[9]: (e$8, o$19) => e$8.optionsElement === o$19.element ? e$8 : {
		...e$8,
		optionsElement: o$19.element
	},
	[10]: (e$8) => e$8.pendingShouldSort ? {
		...e$8,
		...g$2(e$8),
		pendingShouldSort: !1
	} : e$8,
	[11](e$8) {
		return e$8.buttonPositionState.kind !== "Tracked" ? e$8 : {
			...e$8,
			buttonPositionState: c$5.Moved
		};
	}
};
var h$4 = class h$4 extends T$2 {
	constructor(t$12) {
		super(t$12);
		b$4(this, "actions", {
			onChange: (t$13) => {
				let { onChange: n$16, compare: i$15, mode: s$19, value: l$17 } = this.state.dataRef.current;
				return u$2(s$19, {
					[0]: () => n$16 == null ? void 0 : n$16(t$13),
					[1]: () => {
						let c$20 = l$17.slice(), p$12 = c$20.findIndex((f$21) => i$15(f$21, t$13));
						return p$12 === -1 ? c$20.push(t$13) : c$20.splice(p$12, 1), n$16 == null ? void 0 : n$16(c$20);
					}
				});
			},
			registerOption: k$3(() => {
				let t$13 = [], n$16 = /* @__PURE__ */ new Set();
				return [(i$15, s$19) => {
					n$16.has(s$19) || (n$16.add(s$19), t$13.push({
						id: i$15,
						dataRef: s$19
					}));
				}, () => (n$16.clear(), this.send({
					type: 6,
					options: t$13.splice(0)
				}))];
			}),
			unregisterOption: k$3(() => {
				let t$13 = [];
				return [(n$16) => t$13.push(n$16), () => {
					this.send({
						type: 7,
						options: t$13.splice(0)
					});
				}];
			}),
			goToOption: k$3(() => {
				let t$13 = null;
				return [(n$16, i$15) => {
					t$13 = {
						type: 2,
						...n$16,
						trigger: i$15
					};
				}, () => t$13 && this.send(t$13)];
			}),
			closeListbox: () => {
				this.send({ type: 1 });
			},
			openListbox: (t$13) => {
				this.send({
					type: 0,
					focus: t$13
				});
			},
			selectActiveOption: () => {
				var t$13;
				if (this.state.activeOptionIndex !== null) {
					let { dataRef: n$16 } = this.state.options[this.state.activeOptionIndex];
					this.actions.selectOption(n$16.current.value);
				} else this.state.dataRef.current.mode === 0 && (this.actions.closeListbox(), (t$13 = this.state.buttonElement) == null || t$13.focus({ preventScroll: !0 }));
			},
			selectOption: (t$13) => {
				this.send({
					type: 5,
					value: t$13
				});
			},
			search: (t$13) => {
				this.send({
					type: 3,
					value: t$13
				});
			},
			clearSearch: () => {
				this.send({ type: 4 });
			},
			setButtonElement: (t$13) => {
				this.send({
					type: 8,
					element: t$13
				});
			},
			setOptionsElement: (t$13) => {
				this.send({
					type: 9,
					element: t$13
				});
			}
		});
		b$4(this, "selectors", {
			activeDescendantId(t$13) {
				var s$19;
				let n$16 = t$13.activeOptionIndex, i$15 = t$13.options;
				return n$16 === null || (s$19 = i$15[n$16]) == null ? void 0 : s$19.id;
			},
			isActive(t$13, n$16) {
				var l$17;
				let i$15 = t$13.activeOptionIndex, s$19 = t$13.options;
				return i$15 !== null ? ((l$17 = s$19[i$15]) == null ? void 0 : l$17.id) === n$16 : !1;
			},
			hasFrozenValue(t$13) {
				return t$13.frozenValue;
			},
			shouldScrollIntoView(t$13, n$16) {
				return t$13.__demoMode || t$13.listboxState !== 0 || t$13.activationTrigger === 0 ? !1 : this.isActive(t$13, n$16);
			},
			didButtonMove(t$13) {
				return t$13.buttonPositionState.kind === "Moved";
			}
		});
		this.on(6, () => {
			requestAnimationFrame(() => {
				this.send({ type: 10 });
			});
		});
		{
			let n$16 = this.state.id, i$15 = x$3.get(null);
			this.disposables.add(i$15.on(k$4.Push, (s$19) => {
				!i$15.selectors.isTop(s$19, n$16) && this.state.listboxState === 0 && this.actions.closeListbox();
			})), this.on(0, () => i$15.actions.push(n$16)), this.on(1, () => i$15.actions.pop(n$16));
		}
		this.disposables.group((n$16) => {
			this.on(1, (i$15) => {
				i$15.buttonElement && (n$16.dispose(), n$16.add(p$4(i$15.buttonElement, i$15.buttonPositionState, () => {
					this.send({ type: 11 });
				})));
			});
		}), this.on(5, (n$16, i$15) => {
			var s$19;
			this.actions.onChange(i$15.value), this.state.dataRef.current.mode === 0 && (this.actions.closeListbox(), (s$19 = this.state.buttonElement) == null || s$19.focus({ preventScroll: !0 }));
		});
	}
	static new({ id: t$12, __demoMode: n$16 = !1 }) {
		return new h$4({
			id: t$12,
			dataRef: { current: {} },
			listboxState: n$16 ? 0 : 1,
			options: [],
			searchQuery: "",
			activeOptionIndex: null,
			activationTrigger: 1,
			buttonElement: null,
			optionsElement: null,
			pendingShouldSort: !1,
			pendingFocus: { focus: c$4.Nothing },
			frozenValue: !1,
			__demoMode: n$16,
			buttonPositionState: c$5.Idle
		});
	}
	reduce(t$12, n$16) {
		return u$2(n$16.type, D$2, t$12, n$16);
	}
};

//#endregion
//#region node_modules/@headlessui/react/dist/components/listbox/listbox-machine-glue.js
var c$6 = (0, import_react.createContext)(null);
function p$5(o$19) {
	let e$8 = (0, import_react.useContext)(c$6);
	if (e$8 === null) {
		let t$12 = /* @__PURE__ */ new Error(`<${o$19} /> is missing a parent <Listbox /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(t$12, u$11), t$12;
	}
	return e$8;
}
function u$11({ id: o$19, __demoMode: e$8 = !1 }) {
	let t$12 = (0, import_react.useMemo)(() => h$4.new({
		id: o$19,
		__demoMode: e$8
	}), []);
	return c$3(() => t$12.dispose()), t$12;
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/listbox/listbox.js
var import_react_dom$1 = /* @__PURE__ */ __toESM(require_react_dom(), 1);
var oe$2 = (0, import_react.createContext)(null);
oe$2.displayName = "ListboxDataContext";
function Q$3(b$13) {
	let E$13 = (0, import_react.useContext)(oe$2);
	if (E$13 === null) {
		let m$9 = /* @__PURE__ */ new Error(`<${b$13} /> is missing a parent <Listbox /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(m$9, Q$3), m$9;
	}
	return E$13;
}
var Pt$1 = import_react.Fragment;
function gt$2(b$13, E$13) {
	let m$9 = (0, import_react.useId)(), u$24 = a(), { value: s$19, defaultValue: a$27, form: _$10, name: i$15, onChange: y$9, by: o$19, invalid: x$9 = !1, disabled: O$4 = u$24 || !1, horizontal: l$17 = !1, multiple: t$12 = !1, __demoMode: p$12 = !1,...S$9 } = b$13;
	const h$14 = l$17 ? "horizontal" : "vertical";
	let I$9 = y$1(E$13), R$6 = l(a$27), [c$20 = t$12 ? [] : void 0, L$6] = b$2(s$19, y$9, R$6), f$21 = u$11({
		id: m$9,
		__demoMode: p$12
	}), k$13 = (0, import_react.useRef)({
		static: !1,
		hold: !1
	}), N$3 = (0, import_react.useRef)(/* @__PURE__ */ new Map()), C$10 = u$3(o$19), V$5 = (0, import_react.useCallback)((P$7) => u$2(n$16.mode, {
		[P$1.Multi]: () => c$20.some((W$4) => C$10(W$4, P$7)),
		[P$1.Single]: () => C$10(c$20, P$7)
	}), [c$20]), n$16 = n({
		value: c$20,
		disabled: O$4,
		invalid: x$9,
		mode: t$12 ? P$1.Multi : P$1.Single,
		orientation: h$14,
		onChange: L$6,
		compare: C$10,
		isSelected: V$5,
		optionsPropsRef: k$13,
		listRef: N$3
	});
	n$1(() => {
		f$21.state.dataRef.current = n$16;
	}, [n$16]);
	let F$6 = S$1(f$21, (P$7) => P$7.listboxState), U$2 = x$3.get(null), H$8 = S$1(U$2, (0, import_react.useCallback)((P$7) => U$2.selectors.isTop(P$7, m$9), [U$2, m$9])), [A$4, $$5] = S$1(f$21, (P$7) => [P$7.buttonElement, P$7.optionsElement]);
	k$1(H$8, [A$4, $$5], (P$7, W$4) => {
		f$21.send({ type: k$6.CloseListbox }), H$3(W$4, I$1.Loose) || (P$7.preventDefault(), A$4?.focus());
	});
	let r$20 = n({
		open: F$6 === F$1.Open,
		disabled: O$4,
		invalid: x$9,
		value: c$20
	}), [M$11, ne$3] = V$2({ inherit: !0 }), re$4 = { ref: I$9 }, q$4 = (0, import_react.useCallback)(() => {
		if (R$6 !== void 0) return L$6 == null ? void 0 : L$6(R$6);
	}, [L$6, R$6]), le$1 = K();
	return import_react.createElement(ne$3, {
		value: M$11,
		props: { htmlFor: A$4 == null ? void 0 : A$4.id },
		slot: {
			open: F$6 === F$1.Open,
			disabled: O$4
		}
	}, import_react.createElement(Ae$1, null, import_react.createElement(c$6.Provider, { value: f$21 }, import_react.createElement(oe$2.Provider, { value: n$16 }, import_react.createElement(c$2, { value: u$2(F$6, {
		[F$1.Open]: i$1.Open,
		[F$1.Closed]: i$1.Closed
	}) }, i$15 != null && c$20 != null && import_react.createElement(j, {
		disabled: O$4,
		data: { [i$15]: c$20 },
		form: _$10,
		onReset: q$4
	}), le$1({
		ourProps: re$4,
		theirProps: S$9,
		slot: r$20,
		defaultTag: Pt$1,
		name: "Listbox"
	}))))));
}
var vt$1 = "button";
function Et$2(b$13, E$13) {
	let m$9 = (0, import_react.useId)(), u$24 = u$1(), s$19 = Q$3("Listbox.Button"), a$27 = p$5("Listbox.Button"), { id: _$10 = u$24 || `headlessui-listbox-button-${m$9}`, disabled: i$15 = s$19.disabled || !1, autoFocus: y$9 = !1,...o$19 } = b$13, x$9 = y$1(E$13, Fe$3(), a$27.actions.setButtonElement), O$4 = be(), [l$17, t$12, p$12] = S$1(a$27, (r$20) => [
		r$20.listboxState,
		r$20.buttonElement,
		r$20.optionsElement
	]), S$9 = l$17 === F$1.Open;
	L$2(S$9, {
		trigger: t$12,
		action: (0, import_react.useCallback)((r$20) => {
			if (t$12 != null && t$12.contains(r$20.target)) return S$2.Ignore;
			let M$11 = r$20.target.closest("[role=\"option\"]:not([data-disabled])");
			return n$13(M$11) ? S$2.Select(M$11) : p$12 != null && p$12.contains(r$20.target) ? S$2.Ignore : S$2.Close;
		}, [t$12, p$12]),
		close: a$27.actions.closeListbox,
		select: a$27.actions.selectActiveOption
	});
	let h$14 = o((r$20) => {
		switch (r$20.key) {
			case o$1.Enter:
				g(r$20.currentTarget);
				break;
			case o$1.Space:
			case o$1.ArrowDown:
				r$20.preventDefault(), a$27.actions.openListbox({ focus: s$19.value ? c$4.Nothing : c$4.First });
				break;
			case o$1.ArrowUp:
				r$20.preventDefault(), a$27.actions.openListbox({ focus: s$19.value ? c$4.Nothing : c$4.Last });
				break;
		}
	}), I$9 = o((r$20) => {
		switch (r$20.key) {
			case o$1.Space:
				r$20.preventDefault();
				break;
		}
	}), R$6 = s$6((r$20) => {
		var M$11;
		a$27.state.listboxState === F$1.Open ? ((0, import_react_dom$1.flushSync)(() => a$27.actions.closeListbox()), (M$11 = a$27.state.buttonElement) == null || M$11.focus({ preventScroll: !0 })) : (r$20.preventDefault(), a$27.actions.openListbox({ focus: c$4.Nothing }));
	}), c$20 = o((r$20) => r$20.preventDefault()), L$6 = N([_$10]), f$21 = w(), { isFocusVisible: k$13, focusProps: N$3 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: y$9 }), { isHovered: C$10, hoverProps: V$5 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: i$15 }), { pressed: n$16, pressProps: F$6 } = w$1({ disabled: i$15 }), U$2 = n({
		open: l$17 === F$1.Open,
		active: n$16 || l$17 === F$1.Open,
		disabled: i$15,
		invalid: s$19.invalid,
		value: s$19.value,
		hover: C$10,
		focus: k$13,
		autofocus: y$9
	}), H$8 = S$1(a$27, (r$20) => r$20.listboxState === F$1.Open), A$4 = V(O$4(), {
		ref: x$9,
		id: _$10,
		type: e(b$13, t$12),
		"aria-haspopup": "listbox",
		"aria-controls": p$12 == null ? void 0 : p$12.id,
		"aria-expanded": H$8,
		"aria-labelledby": L$6,
		"aria-describedby": f$21,
		disabled: i$15 || void 0,
		autoFocus: y$9,
		onKeyDown: h$14,
		onKeyUp: I$9,
		onKeyPress: c$20
	}, R$6, N$3, V$5, F$6);
	return K()({
		ourProps: A$4,
		theirProps: o$19,
		slot: U$2,
		defaultTag: vt$1,
		name: "Listbox.Button"
	});
}
var Oe$3 = (0, import_react.createContext)(!1), ht$2 = "div", At$1 = A$1.RenderStrategy | A$1.Static;
function _t$1(b$13, E$13) {
	let m$9 = (0, import_react.useId)(), { id: u$24 = `headlessui-listbox-options-${m$9}`, anchor: s$19, portal: a$27 = !1, modal: _$10 = !0, transition: i$15 = !1,...y$9 } = b$13, o$19 = ye(s$19), [x$9, O$4] = (0, import_react.useState)(null);
	o$19 && (a$27 = !0);
	let l$17 = Q$3("Listbox.Options"), t$12 = p$5("Listbox.Options"), [p$12, S$9, h$14, I$9] = S$1(t$12, (e$8) => [
		e$8.listboxState,
		e$8.buttonElement,
		e$8.optionsElement,
		e$8.__demoMode
	]), R$6 = u$4(S$9), c$20 = u$4(h$14), L$6 = u$6(), [f$21, k$13] = N$1(i$15, x$9, L$6 !== null ? (L$6 & i$1.Open) === i$1.Open : p$12 === F$1.Open);
	p$1(f$21, S$9, t$12.actions.closeListbox);
	let N$3 = I$9 ? !1 : _$10 && p$12 === F$1.Open;
	f$3(N$3, c$20);
	let C$10 = I$9 ? !1 : _$10 && p$12 === F$1.Open;
	y$2(C$10, { allowed: (0, import_react.useCallback)(() => [S$9, h$14], [S$9, h$14]) });
	let n$16 = S$1(t$12, t$12.selectors.didButtonMove) ? !1 : f$21, F$6 = S$1(t$12, t$12.selectors.hasFrozenValue) && !b$13.static, U$2 = u$10(F$6, l$17.value), H$8 = (0, import_react.useCallback)((e$8) => l$17.compare(U$2, e$8), [l$17.compare, U$2]), A$4 = S$1(t$12, (e$8) => {
		var de$5;
		if (o$19 == null || !((de$5 = o$19 == null ? void 0 : o$19.to) != null && de$5.includes("selection"))) return null;
		let w$12 = e$8.options.findIndex((ve$2) => H$8(ve$2.dataRef.current.value));
		return w$12 === -1 && (w$12 = 0), w$12;
	}), $$5 = (() => {
		if (o$19 == null) return;
		if (A$4 === null) return {
			...o$19,
			inner: void 0
		};
		let e$8 = Array.from(l$17.listRef.current.values());
		return {
			...o$19,
			inner: {
				listRef: { current: e$8 },
				index: A$4
			}
		};
	})(), [r$20, M$11] = Re$1($$5), ne$3 = Te(), re$4 = y$1(E$13, o$19 ? r$20 : null, t$12.actions.setOptionsElement, O$4), q$4 = p();
	(0, import_react.useEffect)(() => {
		let e$8 = h$14;
		e$8 && p$12 === F$1.Open && (d$1(e$8) || e$8 == null || e$8.focus({ preventScroll: !0 }));
	}, [p$12, h$14]);
	let le$1 = o((e$8) => {
		var w$12;
		switch (q$4.dispose(), e$8.key) {
			case o$1.Space: if (t$12.state.searchQuery !== "") return e$8.preventDefault(), e$8.stopPropagation(), t$12.actions.search(e$8.key);
			case o$1.Enter:
				e$8.preventDefault(), e$8.stopPropagation(), t$12.actions.selectActiveOption();
				break;
			case u$2(l$17.orientation, {
				vertical: o$1.ArrowDown,
				horizontal: o$1.ArrowRight
			}): return e$8.preventDefault(), e$8.stopPropagation(), t$12.actions.goToOption({ focus: c$4.Next });
			case u$2(l$17.orientation, {
				vertical: o$1.ArrowUp,
				horizontal: o$1.ArrowLeft
			}): return e$8.preventDefault(), e$8.stopPropagation(), t$12.actions.goToOption({ focus: c$4.Previous });
			case o$1.Home:
			case o$1.PageUp: return e$8.preventDefault(), e$8.stopPropagation(), t$12.actions.goToOption({ focus: c$4.First });
			case o$1.End:
			case o$1.PageDown: return e$8.preventDefault(), e$8.stopPropagation(), t$12.actions.goToOption({ focus: c$4.Last });
			case o$1.Escape:
				e$8.preventDefault(), e$8.stopPropagation(), (0, import_react_dom$1.flushSync)(() => t$12.actions.closeListbox()), (w$12 = t$12.state.buttonElement) == null || w$12.focus({ preventScroll: !0 });
				return;
			case o$1.Tab:
				e$8.preventDefault(), e$8.stopPropagation(), (0, import_react_dom$1.flushSync)(() => t$12.actions.closeListbox()), R(t$12.state.buttonElement, e$8.shiftKey ? T.Previous : T.Next);
				break;
			default:
				e$8.key.length === 1 && (t$12.actions.search(e$8.key), q$4.setTimeout(() => t$12.actions.clearSearch(), 350));
				break;
		}
	}), P$7 = S$1(t$12, (e$8) => {
		var w$12;
		return (w$12 = e$8.buttonElement) == null ? void 0 : w$12.id;
	}), W$4 = n({ open: p$12 === F$1.Open }), Le$5 = V(o$19 ? ne$3() : {}, {
		id: u$24,
		ref: re$4,
		"aria-activedescendant": S$1(t$12, t$12.selectors.activeDescendantId),
		"aria-multiselectable": l$17.mode === P$1.Multi ? !0 : void 0,
		"aria-labelledby": P$7,
		"aria-orientation": l$17.orientation,
		onKeyDown: le$1,
		role: "listbox",
		tabIndex: p$12 === F$1.Open ? 0 : void 0,
		style: {
			...y$9.style,
			...M$11,
			"--button-width": w$3(f$21, S$9, !0).width
		},
		...x$1(k$13)
	}), Pe$1 = K(), ge$6 = (0, import_react.useMemo)(() => l$17.mode === P$1.Multi ? l$17 : {
		...l$17,
		isSelected: H$8
	}, [l$17, H$8]);
	return import_react.createElement(te, {
		enabled: a$27 ? b$13.static || f$21 : !1,
		ownerDocument: R$6
	}, import_react.createElement(oe$2.Provider, { value: ge$6 }, Pe$1({
		ourProps: Le$5,
		theirProps: y$9,
		slot: W$4,
		defaultTag: ht$2,
		features: At$1,
		visible: n$16,
		name: "Listbox.Options"
	})));
}
var St = "div";
function Dt$1(b$13, E$13) {
	let m$9 = (0, import_react.useId)(), { id: u$24 = `headlessui-listbox-option-${m$9}`, disabled: s$19 = !1, value: a$27,..._$10 } = b$13, i$15 = (0, import_react.useContext)(Oe$3) === !0, y$9 = Q$3("Listbox.Option"), o$19 = p$5("Listbox.Option"), x$9 = S$1(o$19, (n$16) => o$19.selectors.isActive(n$16, u$24)), O$4 = y$9.isSelected(a$27), l$17 = (0, import_react.useRef)(null), t$12 = s$7(l$17), p$12 = s({
		disabled: s$19,
		value: a$27,
		domRef: l$17,
		get textValue() {
			return t$12();
		}
	}), S$9 = y$1(E$13, l$17, (n$16) => {
		n$16 ? y$9.listRef.current.set(u$24, n$16) : y$9.listRef.current.delete(u$24);
	}), h$14 = S$1(o$19, (n$16) => o$19.selectors.shouldScrollIntoView(n$16, u$24));
	n$1(() => {
		if (h$14) return o$2().requestAnimationFrame(() => {
			var n$16, F$6;
			(F$6 = (n$16 = l$17.current) == null ? void 0 : n$16.scrollIntoView) == null || F$6.call(n$16, { block: "nearest" });
		});
	}, [h$14, l$17]), n$1(() => {
		if (!i$15) return o$19.actions.registerOption(u$24, p$12), () => o$19.actions.unregisterOption(u$24);
	}, [
		p$12,
		u$24,
		i$15
	]);
	let I$9 = o((n$16) => {
		if (s$19) return n$16.preventDefault();
		o$19.actions.selectOption(a$27);
	}), R$6 = o(() => {
		if (s$19) return o$19.actions.goToOption({ focus: c$4.Nothing });
		o$19.actions.goToOption({
			focus: c$4.Specific,
			id: u$24
		});
	}), c$20 = u$8(), L$6 = o((n$16) => c$20.update(n$16)), f$21 = o((n$16) => {
		c$20.wasMoved(n$16) && (s$19 || x$9 && o$19.state.activationTrigger === C$4.Pointer || o$19.actions.goToOption({
			focus: c$4.Specific,
			id: u$24
		}, C$4.Pointer));
	}), k$13 = o((n$16) => {
		c$20.wasMoved(n$16) && (s$19 || x$9 && o$19.state.activationTrigger === C$4.Pointer && o$19.actions.goToOption({ focus: c$4.Nothing }));
	}), N$3 = n({
		active: x$9,
		focus: x$9,
		selected: O$4,
		disabled: s$19,
		selectedOption: O$4 && i$15
	}), C$10 = i$15 ? {} : {
		id: u$24,
		ref: S$9,
		role: "option",
		tabIndex: s$19 === !0 ? void 0 : -1,
		"aria-disabled": s$19 === !0 ? !0 : void 0,
		"aria-selected": O$4,
		disabled: void 0,
		onClick: I$9,
		onFocus: R$6,
		onPointerEnter: L$6,
		onMouseEnter: L$6,
		onPointerMove: f$21,
		onMouseMove: f$21,
		onPointerLeave: k$13,
		onMouseLeave: k$13
	}, V$5 = K();
	return !O$4 && i$15 ? null : V$5({
		ourProps: C$10,
		theirProps: _$10,
		slot: N$3,
		defaultTag: St,
		name: "Listbox.Option"
	});
}
var Rt$1 = import_react.Fragment;
function Ft$1(b$13, E$13) {
	let { options: m$9, placeholder: u$24,...s$19 } = b$13, _$10 = { ref: y$1(E$13) }, i$15 = Q$3("ListboxSelectedOption"), y$9 = n({}), o$19 = i$15.value === void 0 || i$15.value === null || i$15.mode === P$1.Multi && Array.isArray(i$15.value) && i$15.value.length === 0, x$9 = K();
	return import_react.createElement(Oe$3.Provider, { value: !0 }, x$9({
		ourProps: _$10,
		theirProps: {
			...s$19,
			children: import_react.createElement(import_react.Fragment, null, u$24 && o$19 ? u$24 : m$9)
		},
		slot: y$9,
		defaultTag: Rt$1,
		name: "ListboxSelectedOption"
	}));
}
var Ct$1 = Y(gt$2), Mt = Y(Et$2), wt = Z, Bt = Y(_t$1), It = Y(Dt$1), kt = Y(Ft$1), Mo = Object.assign(Ct$1, {
	Button: Mt,
	Label: wt,
	Options: Bt,
	Option: It,
	SelectedOption: kt
});

//#endregion
//#region node_modules/@headlessui/react/dist/components/menu/menu-machine.js
var y$3 = Object.defineProperty;
var M$3 = (e$8, i$15, t$12) => i$15 in e$8 ? y$3(e$8, i$15, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t$12
}) : e$8[i$15] = t$12;
var S$3 = (e$8, i$15, t$12) => (M$3(e$8, typeof i$15 != "symbol" ? i$15 + "" : i$15, t$12), t$12);
var P = ((t$12) => (t$12[t$12.Open = 0] = "Open", t$12[t$12.Closed = 1] = "Closed", t$12))(P || {}), D = ((t$12) => (t$12[t$12.Pointer = 0] = "Pointer", t$12[t$12.Other = 1] = "Other", t$12))(D || {}), C$3 = ((o$19) => (o$19[o$19.OpenMenu = 0] = "OpenMenu", o$19[o$19.CloseMenu = 1] = "CloseMenu", o$19[o$19.GoToItem = 2] = "GoToItem", o$19[o$19.Search = 3] = "Search", o$19[o$19.ClearSearch = 4] = "ClearSearch", o$19[o$19.RegisterItems = 5] = "RegisterItems", o$19[o$19.UnregisterItems = 6] = "UnregisterItems", o$19[o$19.SetButtonElement = 7] = "SetButtonElement", o$19[o$19.SetItemsElement = 8] = "SetItemsElement", o$19[o$19.SortItems = 9] = "SortItems", o$19[o$19.MarkButtonAsMoved = 10] = "MarkButtonAsMoved", o$19))(C$3 || {});
function x$4(e$8, i$15 = (t$13) => t$13) {
	let t$12 = e$8.activeItemIndex !== null ? e$8.items[e$8.activeItemIndex] : null, n$16 = G$2(i$15(e$8.items.slice()), (s$19) => s$19.dataRef.current.domRef.current), r$20 = t$12 ? n$16.indexOf(t$12) : null;
	return r$20 === -1 && (r$20 = null), {
		items: n$16,
		activeItemIndex: r$20
	};
}
var k$5 = {
	[1](e$8) {
		if (e$8.menuState === 1) return e$8;
		let i$15 = e$8.buttonElement ? c$5.Tracked(a$5(e$8.buttonElement)) : e$8.buttonPositionState;
		return {
			...e$8,
			activeItemIndex: null,
			pendingFocus: { focus: c$4.Nothing },
			menuState: 1,
			buttonPositionState: i$15
		};
	},
	[0](e$8, i$15) {
		return e$8.menuState === 0 ? e$8 : {
			...e$8,
			__demoMode: !1,
			pendingFocus: i$15.focus,
			menuState: 0,
			buttonPositionState: c$5.Idle
		};
	},
	[2]: (e$8, i$15) => {
		var s$19, l$17, a$27, I$9, f$21;
		if (e$8.menuState === 1) return e$8;
		let t$12 = {
			...e$8,
			searchQuery: "",
			activationTrigger: (s$19 = i$15.trigger) != null ? s$19 : 1,
			__demoMode: !1
		};
		if (i$15.focus === c$4.Nothing) return {
			...t$12,
			activeItemIndex: null
		};
		if (i$15.focus === c$4.Specific) return {
			...t$12,
			activeItemIndex: e$8.items.findIndex((d$13) => d$13.id === i$15.id)
		};
		if (i$15.focus === c$4.Previous) {
			let d$13 = e$8.activeItemIndex;
			if (d$13 !== null) {
				let o$19 = e$8.items[d$13].dataRef.current.domRef, c$20 = f$6(i$15, {
					resolveItems: () => e$8.items,
					resolveActiveIndex: () => e$8.activeItemIndex,
					resolveId: (u$24) => u$24.id,
					resolveDisabled: (u$24) => u$24.dataRef.current.disabled
				});
				if (c$20 !== null) {
					let u$24 = e$8.items[c$20].dataRef.current.domRef;
					if (((l$17 = o$19.current) == null ? void 0 : l$17.previousElementSibling) === u$24.current || ((a$27 = u$24.current) == null ? void 0 : a$27.previousElementSibling) === null) return {
						...t$12,
						activeItemIndex: c$20
					};
				}
			}
		} else if (i$15.focus === c$4.Next) {
			let d$13 = e$8.activeItemIndex;
			if (d$13 !== null) {
				let o$19 = e$8.items[d$13].dataRef.current.domRef, c$20 = f$6(i$15, {
					resolveItems: () => e$8.items,
					resolveActiveIndex: () => e$8.activeItemIndex,
					resolveId: (u$24) => u$24.id,
					resolveDisabled: (u$24) => u$24.dataRef.current.disabled
				});
				if (c$20 !== null) {
					let u$24 = e$8.items[c$20].dataRef.current.domRef;
					if (((I$9 = o$19.current) == null ? void 0 : I$9.nextElementSibling) === u$24.current || ((f$21 = u$24.current) == null ? void 0 : f$21.nextElementSibling) === null) return {
						...t$12,
						activeItemIndex: c$20
					};
				}
			}
		}
		let n$16 = x$4(e$8), r$20 = f$6(i$15, {
			resolveItems: () => n$16.items,
			resolveActiveIndex: () => n$16.activeItemIndex,
			resolveId: (d$13) => d$13.id,
			resolveDisabled: (d$13) => d$13.dataRef.current.disabled
		});
		return {
			...t$12,
			...n$16,
			activeItemIndex: r$20
		};
	},
	[3]: (e$8, i$15) => {
		let n$16 = e$8.searchQuery !== "" ? 0 : 1, r$20 = e$8.searchQuery + i$15.value.toLowerCase(), l$17 = (e$8.activeItemIndex !== null ? e$8.items.slice(e$8.activeItemIndex + n$16).concat(e$8.items.slice(0, e$8.activeItemIndex + n$16)) : e$8.items).find((I$9) => {
			var f$21;
			return ((f$21 = I$9.dataRef.current.textValue) == null ? void 0 : f$21.startsWith(r$20)) && !I$9.dataRef.current.disabled;
		}), a$27 = l$17 ? e$8.items.indexOf(l$17) : -1;
		return a$27 === -1 || a$27 === e$8.activeItemIndex ? {
			...e$8,
			searchQuery: r$20
		} : {
			...e$8,
			searchQuery: r$20,
			activeItemIndex: a$27,
			activationTrigger: 1
		};
	},
	[4](e$8) {
		return e$8.searchQuery === "" ? e$8 : {
			...e$8,
			searchQuery: "",
			searchActiveItemIndex: null
		};
	},
	[5]: (e$8, i$15) => {
		let t$12 = e$8.items.concat(i$15.items.map((r$20) => r$20)), n$16 = e$8.activeItemIndex;
		return e$8.pendingFocus.focus !== c$4.Nothing && (n$16 = f$6(e$8.pendingFocus, {
			resolveItems: () => t$12,
			resolveActiveIndex: () => e$8.activeItemIndex,
			resolveId: (r$20) => r$20.id,
			resolveDisabled: (r$20) => r$20.dataRef.current.disabled
		})), {
			...e$8,
			items: t$12,
			activeItemIndex: n$16,
			pendingFocus: { focus: c$4.Nothing },
			pendingShouldSort: !0
		};
	},
	[6]: (e$8, i$15) => {
		let t$12 = e$8.items, n$16 = [], r$20 = new Set(i$15.items);
		for (let [s$19, l$17] of t$12.entries()) if (r$20.has(l$17.id) && (n$16.push(s$19), r$20.delete(l$17.id), r$20.size === 0)) break;
		if (n$16.length > 0) {
			t$12 = t$12.slice();
			for (let s$19 of n$16.reverse()) t$12.splice(s$19, 1);
		}
		return {
			...e$8,
			items: t$12,
			activationTrigger: 1
		};
	},
	[7]: (e$8, i$15) => e$8.buttonElement === i$15.element ? e$8 : {
		...e$8,
		buttonElement: i$15.element
	},
	[8]: (e$8, i$15) => e$8.itemsElement === i$15.element ? e$8 : {
		...e$8,
		itemsElement: i$15.element
	},
	[9]: (e$8) => e$8.pendingShouldSort ? {
		...e$8,
		...x$4(e$8),
		pendingShouldSort: !1
	} : e$8,
	[10](e$8) {
		return e$8.buttonPositionState.kind !== "Tracked" ? e$8 : {
			...e$8,
			buttonPositionState: c$5.Moved
		};
	}
};
var h$3 = class h$3 extends T$2 {
	constructor(t$12) {
		super(t$12);
		S$3(this, "actions", {
			registerItem: k$3(() => {
				let t$13 = [], n$16 = /* @__PURE__ */ new Set();
				return [(r$20, s$19) => {
					n$16.has(s$19) || (n$16.add(s$19), t$13.push({
						id: r$20,
						dataRef: s$19
					}));
				}, () => (n$16.clear(), this.send({
					type: 5,
					items: t$13.splice(0)
				}))];
			}),
			unregisterItem: k$3(() => {
				let t$13 = [];
				return [(n$16) => t$13.push(n$16), () => this.send({
					type: 6,
					items: t$13.splice(0)
				})];
			})
		});
		S$3(this, "selectors", {
			activeDescendantId(t$13) {
				var s$19;
				let n$16 = t$13.activeItemIndex, r$20 = t$13.items;
				return n$16 === null || (s$19 = r$20[n$16]) == null ? void 0 : s$19.id;
			},
			isActive(t$13, n$16) {
				var l$17;
				let r$20 = t$13.activeItemIndex, s$19 = t$13.items;
				return r$20 !== null ? ((l$17 = s$19[r$20]) == null ? void 0 : l$17.id) === n$16 : !1;
			},
			shouldScrollIntoView(t$13, n$16) {
				return t$13.__demoMode || t$13.menuState !== 0 || t$13.activationTrigger === 0 ? !1 : this.isActive(t$13, n$16);
			},
			didButtonMove(t$13) {
				return t$13.buttonPositionState.kind === "Moved";
			}
		});
		this.on(5, () => {
			this.disposables.requestAnimationFrame(() => {
				this.send({ type: 9 });
			});
		});
		{
			let n$16 = this.state.id, r$20 = x$3.get(null);
			this.disposables.add(r$20.on(k$4.Push, (s$19) => {
				!r$20.selectors.isTop(s$19, n$16) && this.state.menuState === 0 && this.send({ type: 1 });
			})), this.on(0, () => r$20.actions.push(n$16)), this.on(1, () => r$20.actions.pop(n$16));
		}
		this.disposables.group((n$16) => {
			this.on(1, (r$20) => {
				r$20.buttonElement && (n$16.dispose(), n$16.add(p$4(r$20.buttonElement, r$20.buttonPositionState, () => {
					this.send({ type: 10 });
				})));
			});
		});
	}
	static new({ id: t$12, __demoMode: n$16 = !1 }) {
		return new h$3({
			id: t$12,
			__demoMode: n$16,
			menuState: n$16 ? 0 : 1,
			buttonElement: null,
			itemsElement: null,
			items: [],
			searchQuery: "",
			activeItemIndex: null,
			activationTrigger: 1,
			pendingShouldSort: !1,
			pendingFocus: { focus: c$4.Nothing },
			buttonPositionState: c$5.Idle
		});
	}
	reduce(t$12, n$16) {
		return u$2(n$16.type, k$5, t$12, n$16);
	}
};

//#endregion
//#region node_modules/@headlessui/react/dist/components/menu/menu-machine-glue.js
var a$4 = (0, import_react.createContext)(null);
function p$3(t$12) {
	let n$16 = (0, import_react.useContext)(a$4);
	if (n$16 === null) {
		let e$8 = /* @__PURE__ */ new Error(`<${t$12} /> is missing a parent <Menu /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(e$8, s$8), e$8;
	}
	return n$16;
}
function s$8({ id: t$12, __demoMode: n$16 = !1 }) {
	let e$8 = (0, import_react.useMemo)(() => h$3.new({
		id: t$12,
		__demoMode: n$16
	}), []);
	return c$3(() => e$8.dispose()), e$8;
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/menu/menu.js
var import_react_dom = /* @__PURE__ */ __toESM(require_react_dom(), 1);
var Ze = import_react.Fragment;
function et(m$9, y$9) {
	let l$17 = (0, import_react.useId)(), { __demoMode: a$27 = !1,...p$12 } = m$9, s$19 = s$8({
		id: l$17,
		__demoMode: a$27
	}), [n$16, M$11, f$21] = S$1(s$19, (d$13) => [
		d$13.menuState,
		d$13.itemsElement,
		d$13.buttonElement
	]), _$10 = y$1(y$9), o$19 = x$3.get(null), F$6 = S$1(o$19, (0, import_react.useCallback)((d$13) => o$19.selectors.isTop(d$13, l$17), [o$19, l$17]));
	k$1(F$6, [f$21, M$11], (d$13, T$9) => {
		var P$7;
		s$19.send({ type: C$3.CloseMenu }), H$3(T$9, I$1.Loose) || (d$13.preventDefault(), (P$7 = s$19.state.buttonElement) == null || P$7.focus());
	});
	let I$9 = o(() => {
		s$19.send({ type: C$3.CloseMenu });
	}), b$13 = n({
		open: n$16 === P.Open,
		close: I$9
	}), i$15 = { ref: _$10 }, g$8 = K();
	return import_react.createElement(Ae$1, null, import_react.createElement(a$4.Provider, { value: s$19 }, import_react.createElement(c$2, { value: u$2(n$16, {
		[P.Open]: i$1.Open,
		[P.Closed]: i$1.Closed
	}) }, g$8({
		ourProps: i$15,
		theirProps: p$12,
		slot: b$13,
		defaultTag: Ze,
		name: "Menu"
	}))));
}
var tt$1 = "button";
function ot(m$9, y$9) {
	let l$17 = p$3("Menu.Button"), a$27 = (0, import_react.useId)(), { id: p$12 = `headlessui-menu-button-${a$27}`, disabled: s$19 = !1, autoFocus: n$16 = !1,...M$11 } = m$9, f$21 = (0, import_react.useRef)(null), _$10 = be(), o$19 = y$1(y$9, f$21, Fe$3(), o((t$12) => l$17.send({
		type: C$3.SetButtonElement,
		element: t$12
	}))), F$6 = o((t$12) => {
		switch (t$12.key) {
			case o$1.Space:
			case o$1.Enter:
			case o$1.ArrowDown:
				t$12.preventDefault(), t$12.stopPropagation(), l$17.send({
					type: C$3.OpenMenu,
					focus: { focus: c$4.First }
				});
				break;
			case o$1.ArrowUp:
				t$12.preventDefault(), t$12.stopPropagation(), l$17.send({
					type: C$3.OpenMenu,
					focus: { focus: c$4.Last }
				});
				break;
		}
	}), I$9 = o((t$12) => {
		switch (t$12.key) {
			case o$1.Space:
				t$12.preventDefault();
				break;
		}
	}), [b$13, i$15, g$8] = S$1(l$17, (t$12) => [
		t$12.menuState,
		t$12.buttonElement,
		t$12.itemsElement
	]), d$13 = b$13 === P.Open;
	L$2(d$13, {
		trigger: i$15,
		action: (0, import_react.useCallback)((t$12) => {
			if (i$15 != null && i$15.contains(t$12.target)) return S$2.Ignore;
			let S$9 = t$12.target.closest("[role=\"menuitem\"]:not([data-disabled])");
			return n$13(S$9) ? S$2.Select(S$9) : g$8 != null && g$8.contains(t$12.target) ? S$2.Ignore : S$2.Close;
		}, [i$15, g$8]),
		close: (0, import_react.useCallback)(() => l$17.send({ type: C$3.CloseMenu }), []),
		select: (0, import_react.useCallback)((t$12) => t$12.click(), [])
	});
	let T$9 = s$6((t$12) => {
		var S$9;
		s$19 || (b$13 === P.Open ? ((0, import_react_dom.flushSync)(() => l$17.send({ type: C$3.CloseMenu })), (S$9 = f$21.current) == null || S$9.focus({ preventScroll: !0 })) : (t$12.preventDefault(), l$17.send({
			type: C$3.OpenMenu,
			focus: { focus: c$4.Nothing },
			trigger: D.Pointer
		})));
	}), { isFocusVisible: P$7, focusProps: L$6 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: n$16 }), { isHovered: O$4, hoverProps: v$10 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: s$19 }), { pressed: D$11, pressProps: U$2 } = w$1({ disabled: s$19 }), H$8 = n({
		open: b$13 === P.Open,
		active: D$11 || b$13 === P.Open,
		disabled: s$19,
		hover: O$4,
		focus: P$7,
		autofocus: n$16
	}), G$5 = V(_$10(), {
		ref: o$19,
		id: p$12,
		type: e(m$9, f$21.current),
		"aria-haspopup": "menu",
		"aria-controls": g$8 == null ? void 0 : g$8.id,
		"aria-expanded": b$13 === P.Open,
		disabled: s$19 || void 0,
		autoFocus: n$16,
		onKeyDown: F$6,
		onKeyUp: I$9
	}, T$9, L$6, v$10, U$2);
	return K()({
		ourProps: G$5,
		theirProps: M$11,
		slot: H$8,
		defaultTag: tt$1,
		name: "Menu.Button"
	});
}
var nt = "div", rt = A$1.RenderStrategy | A$1.Static;
function at(m$9, y$9) {
	let l$17 = (0, import_react.useId)(), { id: a$27 = `headlessui-menu-items-${l$17}`, anchor: p$12, portal: s$19 = !1, modal: n$16 = !0, transition: M$11 = !1,...f$21 } = m$9, _$10 = ye(p$12), o$19 = p$3("Menu.Items"), [F$6, I$9] = Re$1(_$10), b$13 = Te(), [i$15, g$8] = (0, import_react.useState)(null), d$13 = y$1(y$9, _$10 ? F$6 : null, o((e$8) => o$19.send({
		type: C$3.SetItemsElement,
		element: e$8
	})), g$8), [T$9, P$7] = S$1(o$19, (e$8) => [e$8.menuState, e$8.buttonElement]), L$6 = u$4(P$7), O$4 = u$4(i$15);
	_$10 && (s$19 = !0);
	let v$10 = u$6(), [D$11, U$2] = N$1(M$11, i$15, v$10 !== null ? (v$10 & i$1.Open) === i$1.Open : T$9 === P.Open);
	p$1(D$11, P$7, () => {
		o$19.send({ type: C$3.CloseMenu });
	});
	let H$8 = S$1(o$19, (e$8) => e$8.__demoMode), G$5 = H$8 ? !1 : n$16 && T$9 === P.Open;
	f$3(G$5, O$4);
	let w$12 = H$8 ? !1 : n$16 && T$9 === P.Open;
	y$2(w$12, { allowed: (0, import_react.useCallback)(() => [P$7, i$15], [P$7, i$15]) });
	let S$9 = S$1(o$19, o$19.selectors.didButtonMove) ? !1 : D$11;
	(0, import_react.useEffect)(() => {
		let e$8 = i$15;
		e$8 && T$9 === P.Open && (d$1(e$8) || e$8.focus({ preventScroll: !0 }));
	}, [T$9, i$15]), F(T$9 === P.Open, {
		container: i$15,
		accept(e$8) {
			return e$8.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : e$8.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
		},
		walk(e$8) {
			e$8.setAttribute("role", "none");
		}
	});
	let z$3 = p(), le$1 = o((e$8) => {
		var N$3, Y$4, Z$3;
		switch (z$3.dispose(), e$8.key) {
			case o$1.Space: if (o$19.state.searchQuery !== "") return e$8.preventDefault(), e$8.stopPropagation(), o$19.send({
				type: C$3.Search,
				value: e$8.key
			});
			case o$1.Enter:
				if (e$8.preventDefault(), e$8.stopPropagation(), o$19.state.activeItemIndex !== null) {
					let { dataRef: de$5 } = o$19.state.items[o$19.state.activeItemIndex];
					(Y$4 = (N$3 = de$5.current) == null ? void 0 : N$3.domRef.current) == null || Y$4.click();
				}
				o$19.send({ type: C$3.CloseMenu }), K$1(o$19.state.buttonElement);
				break;
			case o$1.ArrowDown: return e$8.preventDefault(), e$8.stopPropagation(), o$19.send({
				type: C$3.GoToItem,
				focus: c$4.Next
			});
			case o$1.ArrowUp: return e$8.preventDefault(), e$8.stopPropagation(), o$19.send({
				type: C$3.GoToItem,
				focus: c$4.Previous
			});
			case o$1.Home:
			case o$1.PageUp: return e$8.preventDefault(), e$8.stopPropagation(), o$19.send({
				type: C$3.GoToItem,
				focus: c$4.First
			});
			case o$1.End:
			case o$1.PageDown: return e$8.preventDefault(), e$8.stopPropagation(), o$19.send({
				type: C$3.GoToItem,
				focus: c$4.Last
			});
			case o$1.Escape:
				e$8.preventDefault(), e$8.stopPropagation(), (0, import_react_dom.flushSync)(() => o$19.send({ type: C$3.CloseMenu })), (Z$3 = o$19.state.buttonElement) == null || Z$3.focus({ preventScroll: !0 });
				break;
			case o$1.Tab:
				e$8.preventDefault(), e$8.stopPropagation(), (0, import_react_dom.flushSync)(() => o$19.send({ type: C$3.CloseMenu })), R(o$19.state.buttonElement, e$8.shiftKey ? T.Previous : T.Next);
				break;
			default:
				e$8.key.length === 1 && (o$19.send({
					type: C$3.Search,
					value: e$8.key
				}), z$3.setTimeout(() => o$19.send({ type: C$3.ClearSearch }), 350));
				break;
		}
	}), pe$3 = o((e$8) => {
		switch (e$8.key) {
			case o$1.Space:
				e$8.preventDefault();
				break;
		}
	}), ie$3 = n({ open: T$9 === P.Open }), ue$4 = V(_$10 ? b$13() : {}, {
		"aria-activedescendant": S$1(o$19, o$19.selectors.activeDescendantId),
		"aria-labelledby": S$1(o$19, (e$8) => {
			var N$3;
			return (N$3 = e$8.buttonElement) == null ? void 0 : N$3.id;
		}),
		id: a$27,
		onKeyDown: le$1,
		onKeyUp: pe$3,
		role: "menu",
		tabIndex: T$9 === P.Open ? 0 : void 0,
		ref: d$13,
		style: {
			...f$21.style,
			...I$9,
			"--button-width": w$3(D$11, P$7, !0).width
		},
		...x$1(U$2)
	}), me$4 = K();
	return import_react.createElement(te, {
		enabled: s$19 ? m$9.static || D$11 : !1,
		ownerDocument: L$6
	}, me$4({
		ourProps: ue$4,
		theirProps: f$21,
		slot: ie$3,
		defaultTag: nt,
		features: rt,
		visible: S$9,
		name: "Menu.Items"
	}));
}
var st = import_react.Fragment;
function lt(m$9, y$9) {
	let l$17 = (0, import_react.useId)(), { id: a$27 = `headlessui-menu-item-${l$17}`, disabled: p$12 = !1,...s$19 } = m$9, n$16 = p$3("Menu.Item"), M$11 = S$1(n$16, (t$12) => n$16.selectors.isActive(t$12, a$27)), f$21 = (0, import_react.useRef)(null), _$10 = y$1(y$9, f$21), o$19 = S$1(n$16, (t$12) => n$16.selectors.shouldScrollIntoView(t$12, a$27));
	n$1(() => {
		if (o$19) return o$2().requestAnimationFrame(() => {
			var t$12, S$9;
			(S$9 = (t$12 = f$21.current) == null ? void 0 : t$12.scrollIntoView) == null || S$9.call(t$12, { block: "nearest" });
		});
	}, [o$19, f$21]);
	let F$6 = s$7(f$21), I$9 = (0, import_react.useRef)({
		disabled: p$12,
		domRef: f$21,
		get textValue() {
			return F$6();
		}
	});
	n$1(() => {
		I$9.current.disabled = p$12;
	}, [I$9, p$12]), n$1(() => (n$16.actions.registerItem(a$27, I$9), () => n$16.actions.unregisterItem(a$27)), [I$9, a$27]);
	let b$13 = o(() => {
		n$16.send({ type: C$3.CloseMenu });
	}), i$15 = o((t$12) => {
		if (p$12) return t$12.preventDefault();
		n$16.send({ type: C$3.CloseMenu }), K$1(n$16.state.buttonElement);
	}), g$8 = o(() => {
		if (p$12) return n$16.send({
			type: C$3.GoToItem,
			focus: c$4.Nothing
		});
		n$16.send({
			type: C$3.GoToItem,
			focus: c$4.Specific,
			id: a$27
		});
	}), d$13 = u$8(), T$9 = o((t$12) => d$13.update(t$12)), P$7 = o((t$12) => {
		d$13.wasMoved(t$12) && (p$12 || M$11 || n$16.send({
			type: C$3.GoToItem,
			focus: c$4.Specific,
			id: a$27,
			trigger: D.Pointer
		}));
	}), L$6 = o((t$12) => {
		d$13.wasMoved(t$12) && (p$12 || M$11 && n$16.state.activationTrigger === D.Pointer && n$16.send({
			type: C$3.GoToItem,
			focus: c$4.Nothing
		}));
	}), [O$4, v$10] = V$2(), [D$11, U$2] = H$1(), H$8 = n({
		active: M$11,
		focus: M$11,
		disabled: p$12,
		close: b$13
	}), G$5 = {
		id: a$27,
		ref: _$10,
		role: "menuitem",
		tabIndex: p$12 === !0 ? void 0 : -1,
		"aria-disabled": p$12 === !0 ? !0 : void 0,
		"aria-labelledby": O$4,
		"aria-describedby": D$11,
		disabled: void 0,
		onClick: i$15,
		onFocus: g$8,
		onPointerEnter: T$9,
		onMouseEnter: T$9,
		onPointerMove: P$7,
		onMouseMove: P$7,
		onPointerLeave: L$6,
		onMouseLeave: L$6
	}, w$12 = K();
	return import_react.createElement(v$10, null, import_react.createElement(U$2, null, w$12({
		ourProps: G$5,
		theirProps: s$19,
		slot: H$8,
		defaultTag: st,
		name: "Menu.Item"
	})));
}
var pt = "div";
function it(m$9, y$9) {
	let [l$17, a$27] = V$2(), p$12 = m$9, s$19 = {
		ref: y$9,
		"aria-labelledby": l$17,
		role: "group"
	}, n$16 = K();
	return import_react.createElement(a$27, null, n$16({
		ourProps: s$19,
		theirProps: p$12,
		slot: {},
		defaultTag: pt,
		name: "Menu.Section"
	}));
}
var ut = "header";
function mt$1(m$9, y$9) {
	let l$17 = (0, import_react.useId)(), { id: a$27 = `headlessui-menu-heading-${l$17}`,...p$12 } = m$9, s$19 = C$2();
	n$1(() => s$19.register(a$27), [a$27, s$19.register]);
	let n$16 = {
		id: a$27,
		ref: y$9,
		role: "presentation",
		...s$19.props
	};
	return K()({
		ourProps: n$16,
		theirProps: p$12,
		slot: {},
		defaultTag: ut,
		name: "Menu.Heading"
	});
}
var dt$1 = "div";
function Tt$1(m$9, y$9) {
	let l$17 = m$9, a$27 = {
		ref: y$9,
		role: "separator"
	};
	return K()({
		ourProps: a$27,
		theirProps: l$17,
		slot: {},
		defaultTag: dt$1,
		name: "Menu.Separator"
	});
}
var ct = Y(et), ft = Y(ot), yt = Y(at), gt = Y(lt), Pt = Y(it), Et = Y(mt$1), Mt$1 = Y(Tt$1), lo = Object.assign(ct, {
	Button: ft,
	Items: yt,
	Item: gt,
	Section: Pt,
	Heading: Et,
	Separator: Mt$1
});

//#endregion
//#region node_modules/@headlessui/react/dist/components/popover/popover-machine.js
var f$5 = Object.defineProperty;
var b$3 = (t$12, n$16, e$8) => n$16 in t$12 ? f$5(t$12, n$16, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: e$8
}) : t$12[n$16] = e$8;
var p$2 = (t$12, n$16, e$8) => (b$3(t$12, typeof n$16 != "symbol" ? n$16 + "" : n$16, e$8), e$8);
var v$2 = ((e$8) => (e$8[e$8.Open = 0] = "Open", e$8[e$8.Closed = 1] = "Closed", e$8))(v$2 || {}), h$1 = ((r$20) => (r$20[r$20.OpenPopover = 0] = "OpenPopover", r$20[r$20.ClosePopover = 1] = "ClosePopover", r$20[r$20.SetButton = 2] = "SetButton", r$20[r$20.SetButtonId = 3] = "SetButtonId", r$20[r$20.SetPanel = 4] = "SetPanel", r$20[r$20.SetPanelId = 5] = "SetPanelId", r$20))(h$1 || {});
var E$3 = {
	[0]: (t$12) => t$12.popoverState === 0 ? t$12 : {
		...t$12,
		popoverState: 0,
		__demoMode: !1
	},
	[1](t$12) {
		return t$12.popoverState === 1 ? t$12 : {
			...t$12,
			popoverState: 1,
			__demoMode: !1
		};
	},
	[2](t$12, n$16) {
		return t$12.button === n$16.button ? t$12 : {
			...t$12,
			button: n$16.button
		};
	},
	[3](t$12, n$16) {
		return t$12.buttonId === n$16.buttonId ? t$12 : {
			...t$12,
			buttonId: n$16.buttonId
		};
	},
	[4](t$12, n$16) {
		return t$12.panel === n$16.panel ? t$12 : {
			...t$12,
			panel: n$16.panel
		};
	},
	[5](t$12, n$16) {
		return t$12.panelId === n$16.panelId ? t$12 : {
			...t$12,
			panelId: n$16.panelId
		};
	}
};
var d$2 = class d$2 extends T$2 {
	constructor(e$8) {
		super(e$8);
		p$2(this, "actions", {
			close: () => this.send({ type: 1 }),
			refocusableClose: (e$9) => {
				this.actions.close();
				(() => e$9 ? n$13(e$9) ? e$9 : "current" in e$9 && n$13(e$9.current) ? e$9.current : this.state.button : this.state.button)()?.focus();
			},
			open: () => this.send({ type: 0 }),
			setButtonId: (e$9) => this.send({
				type: 3,
				buttonId: e$9
			}),
			setButton: (e$9) => this.send({
				type: 2,
				button: e$9
			}),
			setPanelId: (e$9) => this.send({
				type: 5,
				panelId: e$9
			}),
			setPanel: (e$9) => this.send({
				type: 4,
				panel: e$9
			})
		});
		p$2(this, "selectors", { isPortalled: (e$9) => {
			var i$15;
			if (!e$9.button || !e$9.panel) return !1;
			let o$19 = (i$15 = l$1(e$9.button)) != null ? i$15 : document;
			for (let u$24 of o$19.querySelectorAll("body > *")) if (Number(u$24 == null ? void 0 : u$24.contains(e$9.button)) ^ Number(u$24 == null ? void 0 : u$24.contains(e$9.panel))) return !0;
			let l$17 = x$2(o$19), s$19 = l$17.indexOf(e$9.button), r$20 = (s$19 + l$17.length - 1) % l$17.length, c$20 = (s$19 + 1) % l$17.length, S$9 = l$17[r$20], m$9 = l$17[c$20];
			return !e$9.panel.contains(S$9) && !e$9.panel.contains(m$9);
		} });
		{
			let o$19 = this.state.id, l$17 = x$3.get(null);
			this.on(0, () => l$17.actions.push(o$19)), this.on(1, () => l$17.actions.pop(o$19));
		}
	}
	static new({ id: e$8, __demoMode: o$19 = !1 }) {
		return new d$2({
			id: e$8,
			__demoMode: o$19,
			popoverState: o$19 ? 0 : 1,
			buttons: { current: [] },
			button: null,
			buttonId: null,
			panel: null,
			panelId: null,
			beforePanelSentinel: { current: null },
			afterPanelSentinel: { current: null },
			afterButtonSentinel: { current: null }
		});
	}
	reduce(e$8, o$19) {
		return u$2(o$19.type, E$3, e$8, o$19);
	}
};

//#endregion
//#region node_modules/@headlessui/react/dist/components/popover/popover-machine-glue.js
var a$3 = (0, import_react.createContext)(null);
function u$7(r$20) {
	let o$19 = (0, import_react.useContext)(a$3);
	if (o$19 === null) {
		let e$8 = /* @__PURE__ */ new Error(`<${r$20} /> is missing a parent <Popover /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(e$8, u$7), e$8;
	}
	return o$19;
}
function f$4({ id: r$20, __demoMode: o$19 = !1 }) {
	let e$8 = (0, import_react.useMemo)(() => d$2.new({
		id: r$20,
		__demoMode: o$19
	}), []);
	return c$3(() => e$8.dispose()), e$8;
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/popover/popover.js
var Fe$4 = (0, import_react.createContext)(null);
Fe$4.displayName = "PopoverGroupContext";
function we$2() {
	return (0, import_react.useContext)(Fe$4);
}
var de = (0, import_react.createContext)(null);
de.displayName = "PopoverPanelContext";
function mt() {
	return (0, import_react.useContext)(de);
}
var vt = "div";
function Tt(E$13, O$4) {
	var M$11;
	let R$6 = (0, import_react.useId)(), { __demoMode: B$3 = !1,...T$9 } = E$13, n$16 = f$4({
		id: R$6,
		__demoMode: B$3
	}), b$13 = (0, import_react.useRef)(null), t$12 = y$1(O$4, T$1((r$20) => {
		b$13.current = r$20;
	})), [A$4, d$13, o$19, C$10, y$9] = S$1(n$16, (0, import_react.useCallback)((r$20) => [
		r$20.popoverState,
		r$20.button,
		r$20.panel,
		r$20.buttonId,
		r$20.panelId
	], [])), D$11 = c$1((M$11 = b$13.current) != null ? M$11 : d$13), _$10 = s(C$10), a$27 = s(y$9), u$24 = (0, import_react.useMemo)(() => ({
		buttonId: _$10,
		panelId: a$27,
		close: n$16.actions.close
	}), [
		_$10,
		a$27,
		n$16
	]), f$21 = we$2(), l$17 = f$21 == null ? void 0 : f$21.registerPopover, c$20 = o(() => {
		var F$6, G$5;
		let r$20 = e$1((F$6 = b$13.current) != null ? F$6 : d$13);
		return (G$5 = f$21 == null ? void 0 : f$21.isFocusWithinPopoverGroup()) != null ? G$5 : r$20 && ((d$13 == null ? void 0 : d$13.contains(r$20)) || (o$19 == null ? void 0 : o$19.contains(r$20)));
	});
	(0, import_react.useEffect)(() => l$17 == null ? void 0 : l$17(u$24), [l$17, u$24]);
	let [m$9, W$4] = ee$2(), V$5 = x(d$13), j$9 = S({
		mainTreeNode: V$5,
		portals: m$9,
		defaultContainers: [{ get current() {
			return n$16.state.button;
		} }, { get current() {
			return n$16.state.panel;
		} }]
	});
	E$2(D$11, "focus", (r$20) => {
		var F$6, G$5, h$14, k$13, I$9, H$8;
		r$20.target !== window && i$11(r$20.target) && n$16.state.popoverState === v$2.Open && (c$20() || n$16.state.button && n$16.state.panel && (j$9.contains(r$20.target) || (G$5 = (F$6 = n$16.state.beforePanelSentinel.current) == null ? void 0 : F$6.contains) != null && G$5.call(F$6, r$20.target) || (k$13 = (h$14 = n$16.state.afterPanelSentinel.current) == null ? void 0 : h$14.contains) != null && k$13.call(h$14, r$20.target) || (H$8 = (I$9 = n$16.state.afterButtonSentinel.current) == null ? void 0 : I$9.contains) != null && H$8.call(I$9, r$20.target) || n$16.actions.close()));
	}, !0);
	let L$6 = A$4 === v$2.Open;
	k$1(L$6, j$9.resolveContainers, (r$20, F$6) => {
		n$16.actions.close(), H$3(F$6, I$1.Loose) || (r$20.preventDefault(), d$13?.focus());
	});
	let Y$4 = n({
		open: A$4 === v$2.Open,
		close: n$16.actions.refocusableClose
	}), $$5 = S$1(n$16, (0, import_react.useCallback)((r$20) => u$2(r$20.popoverState, {
		[v$2.Open]: i$1.Open,
		[v$2.Closed]: i$1.Closed
	}), [])), Q$7 = { ref: t$12 }, Z$3 = K();
	return import_react.createElement(j$1, { node: V$5 }, import_react.createElement(Ae$1, null, import_react.createElement(de.Provider, { value: null }, import_react.createElement(a$3.Provider, { value: n$16 }, import_react.createElement(C$1, { value: n$16.actions.refocusableClose }, import_react.createElement(c$2, { value: $$5 }, import_react.createElement(W$4, null, Z$3({
		ourProps: Q$7,
		theirProps: T$9,
		slot: Y$4,
		defaultTag: vt,
		name: "Popover"
	}))))))));
}
var Et$1 = "button";
function bt(E$13, O$4) {
	let R$6 = (0, import_react.useId)(), { id: B$3 = `headlessui-popover-button-${R$6}`, disabled: T$9 = !1, autoFocus: n$16 = !1,...b$13 } = E$13, t$12 = u$7("Popover.Button"), [A$4, d$13, o$19, C$10, y$9, D$11, _$10] = S$1(t$12, (0, import_react.useCallback)((e$8) => [
		e$8.popoverState,
		t$12.selectors.isPortalled(e$8),
		e$8.button,
		e$8.buttonId,
		e$8.panel,
		e$8.panelId,
		e$8.afterButtonSentinel
	], [])), a$27 = (0, import_react.useRef)(null), u$24 = `headlessui-focus-sentinel-${(0, import_react.useId)()}`, f$21 = we$2(), l$17 = f$21 == null ? void 0 : f$21.closeOthers, m$9 = mt() !== null;
	(0, import_react.useEffect)(() => {
		if (!m$9) return t$12.actions.setButtonId(B$3), () => t$12.actions.setButtonId(null);
	}, [
		m$9,
		B$3,
		t$12
	]);
	let [W$4] = (0, import_react.useState)(() => Symbol()), V$5 = y$1(a$27, O$4, Fe$3(), o((e$8) => {
		if (!m$9) {
			if (e$8) t$12.state.buttons.current.push(W$4);
			else {
				let p$12 = t$12.state.buttons.current.indexOf(W$4);
				p$12 !== -1 && t$12.state.buttons.current.splice(p$12, 1);
			}
			t$12.state.buttons.current.length > 1 && console.warn("You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported."), e$8 && t$12.actions.setButton(e$8);
		}
	})), j$9 = y$1(a$27, O$4), L$6 = o((e$8) => {
		var p$12, i$15, x$9;
		if (m$9) {
			if (t$12.state.popoverState === v$2.Closed) return;
			switch (e$8.key) {
				case o$1.Space:
				case o$1.Enter:
					e$8.preventDefault(), (i$15 = (p$12 = e$8.target).click) == null || i$15.call(p$12), t$12.actions.close(), (x$9 = t$12.state.button) == null || x$9.focus();
					break;
			}
		} else switch (e$8.key) {
			case o$1.Space:
			case o$1.Enter:
				e$8.preventDefault(), e$8.stopPropagation(), t$12.state.popoverState === v$2.Closed ? (l$17?.(t$12.state.buttonId), t$12.actions.open()) : t$12.actions.close();
				break;
			case o$1.Escape:
				if (t$12.state.popoverState !== v$2.Open) return l$17 == null ? void 0 : l$17(t$12.state.buttonId);
				if (!a$27.current) return;
				let S$9 = e$1(a$27.current);
				if (S$9 && !a$27.current.contains(S$9)) return;
				e$8.preventDefault(), e$8.stopPropagation(), t$12.actions.close();
				break;
		}
	}), Y$4 = o((e$8) => {
		m$9 || e$8.key === o$1.Space && e$8.preventDefault();
	}), $$5 = o((e$8) => {
		var p$12, i$15;
		s$4(e$8.currentTarget) || T$9 || (m$9 ? (t$12.actions.close(), (p$12 = t$12.state.button) == null || p$12.focus()) : (e$8.preventDefault(), e$8.stopPropagation(), t$12.state.popoverState === v$2.Closed ? (l$17?.(t$12.state.buttonId), t$12.actions.open()) : t$12.actions.close(), (i$15 = t$12.state.button) == null || i$15.focus()));
	}), Q$7 = o((e$8) => {
		e$8.preventDefault(), e$8.stopPropagation();
	}), { isFocusVisible: Z$3, focusProps: M$11 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: n$16 }), { isHovered: r$20, hoverProps: F$6 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: T$9 }), { pressed: G$5, pressProps: h$14 } = w$1({ disabled: T$9 }), k$13 = A$4 === v$2.Open, I$9 = n({
		open: k$13,
		active: G$5 || k$13,
		disabled: T$9,
		hover: r$20,
		focus: Z$3,
		autofocus: n$16
	}), H$8 = e(E$13, o$19), fe$6 = m$9 ? V({
		ref: j$9,
		type: H$8,
		onKeyDown: L$6,
		onClick: $$5,
		disabled: T$9 || void 0,
		autoFocus: n$16
	}, M$11, F$6, h$14) : V({
		ref: V$5,
		id: C$10,
		type: H$8,
		"aria-expanded": A$4 === v$2.Open,
		"aria-controls": y$9 ? D$11 : void 0,
		disabled: T$9 || void 0,
		autoFocus: n$16,
		onKeyDown: L$6,
		onKeyUp: Y$4,
		onClick: $$5,
		onMouseDown: Q$7
	}, M$11, F$6, h$14), ae$4 = u$5(), Pe$1 = o(() => {
		if (!n$13(t$12.state.panel)) return;
		let e$8 = t$12.state.panel;
		function p$12() {
			u$2(ae$4.current, {
				[a$2.Forwards]: () => v(e$8, T.First),
				[a$2.Backwards]: () => v(e$8, T.Last)
			}) === A.Error && v(x$2(r(t$12.state.button)).filter((x$9) => x$9.dataset.headlessuiFocusGuard !== "true"), u$2(ae$4.current, {
				[a$2.Forwards]: T.Next,
				[a$2.Backwards]: T.Previous
			}), { relativeTo: t$12.state.button });
		}
		p$12();
	}), s$19 = K();
	return import_react.createElement(import_react.Fragment, null, s$19({
		ourProps: fe$6,
		theirProps: b$13,
		slot: I$9,
		defaultTag: Et$1,
		name: "Popover.Button"
	}), k$13 && !m$9 && d$13 && import_react.createElement(f, {
		id: u$24,
		ref: _$10,
		features: s$3.Focusable,
		"data-headlessui-focus-guard": !0,
		as: "button",
		type: "button",
		onFocus: Pe$1
	}));
}
var yt$2 = "div", gt$1 = A$1.RenderStrategy | A$1.Static;
function Ne$2(E$13, O$4) {
	let R$6 = (0, import_react.useId)(), { id: B$3 = `headlessui-popover-backdrop-${R$6}`, transition: T$9 = !1,...n$16 } = E$13, b$13 = u$7("Popover.Backdrop"), t$12 = S$1(b$13, (0, import_react.useCallback)((l$17) => l$17.popoverState, [])), [A$4, d$13] = (0, import_react.useState)(null), o$19 = y$1(O$4, d$13), C$10 = u$6(), [y$9, D$11] = N$1(T$9, A$4, C$10 !== null ? (C$10 & i$1.Open) === i$1.Open : t$12 === v$2.Open), _$10 = o((l$17) => {
		if (s$4(l$17.currentTarget)) return l$17.preventDefault();
		b$13.actions.close();
	}), a$27 = n({ open: t$12 === v$2.Open }), u$24 = {
		ref: o$19,
		id: B$3,
		"aria-hidden": !0,
		onClick: _$10,
		...x$1(D$11)
	};
	return K()({
		ourProps: u$24,
		theirProps: n$16,
		slot: a$27,
		defaultTag: yt$2,
		features: gt$1,
		visible: y$9,
		name: "Popover.Backdrop"
	});
}
var Rt = "div", Ft = A$1.RenderStrategy | A$1.Static;
function Bt$1(E$13, O$4) {
	let R$6 = (0, import_react.useId)(), { id: B$3 = `headlessui-popover-panel-${R$6}`, focus: T$9 = !1, anchor: n$16, portal: b$13 = !1, modal: t$12 = !1, transition: A$4 = !1,...d$13 } = E$13, o$19 = u$7("Popover.Panel"), C$10 = S$1(o$19, o$19.selectors.isPortalled), [y$9, D$11, _$10, a$27, u$24] = S$1(o$19, (0, import_react.useCallback)((s$19) => [
		s$19.popoverState,
		s$19.button,
		s$19.__demoMode,
		s$19.beforePanelSentinel,
		s$19.afterPanelSentinel
	], [])), f$21 = `headlessui-focus-sentinel-before-${R$6}`, l$17 = `headlessui-focus-sentinel-after-${R$6}`, c$20 = (0, import_react.useRef)(null), m$9 = ye(n$16), [W$4, V$5] = Re$1(m$9), j$9 = Te();
	m$9 && (b$13 = !0);
	let [L$6, Y$4] = (0, import_react.useState)(null), $$5 = y$1(c$20, O$4, m$9 ? W$4 : null, o$19.actions.setPanel, Y$4), Q$7 = u$4(D$11), Z$3 = u$4(c$20.current);
	n$1(() => (o$19.actions.setPanelId(B$3), () => o$19.actions.setPanelId(null)), [B$3, o$19]);
	let M$11 = u$6(), [r$20, F$6] = N$1(A$4, L$6, M$11 !== null ? (M$11 & i$1.Open) === i$1.Open : y$9 === v$2.Open);
	p$1(r$20, D$11, o$19.actions.close), f$3(_$10 ? !1 : t$12 && r$20, Z$3);
	let h$14 = o((s$19) => {
		var e$8;
		switch (s$19.key) {
			case o$1.Escape:
				if (o$19.state.popoverState !== v$2.Open || !c$20.current) return;
				let p$12 = e$1(c$20.current);
				if (p$12 && !c$20.current.contains(p$12)) return;
				s$19.preventDefault(), s$19.stopPropagation(), o$19.actions.close(), (e$8 = o$19.state.button) == null || e$8.focus();
				break;
		}
	});
	(0, import_react.useEffect)(() => {
		var s$19;
		E$13.static || y$9 === v$2.Closed && ((s$19 = E$13.unmount) == null || s$19) && o$19.actions.setPanel(null);
	}, [
		y$9,
		E$13.unmount,
		E$13.static,
		o$19
	]), (0, import_react.useEffect)(() => {
		if (_$10 || !T$9 || y$9 !== v$2.Open || !c$20.current) return;
		let s$19 = e$1(c$20.current);
		c$20.current.contains(s$19) || v(c$20.current, T.First);
	}, [
		_$10,
		T$9,
		c$20.current,
		y$9
	]);
	let k$13 = n({
		open: y$9 === v$2.Open,
		close: o$19.actions.refocusableClose
	}), I$9 = V(m$9 ? j$9() : {}, {
		ref: $$5,
		id: B$3,
		onKeyDown: h$14,
		onBlur: T$9 && y$9 === v$2.Open ? (s$19) => {
			var p$12, i$15, x$9, S$9, me$4;
			let e$8 = s$19.relatedTarget;
			e$8 && c$20.current && ((p$12 = c$20.current) != null && p$12.contains(e$8) || (o$19.actions.close(), ((x$9 = (i$15 = a$27.current) == null ? void 0 : i$15.contains) != null && x$9.call(i$15, e$8) || (me$4 = (S$9 = u$24.current) == null ? void 0 : S$9.contains) != null && me$4.call(S$9, e$8)) && e$8.focus({ preventScroll: !0 })));
		} : void 0,
		tabIndex: -1,
		style: {
			...d$13.style,
			...V$5,
			"--button-width": w$3(r$20, D$11, !0).width
		},
		...x$1(F$6)
	}), H$8 = u$5(), fe$6 = o(() => {
		let s$19 = c$20.current;
		if (!s$19) return;
		function e$8() {
			u$2(H$8.current, {
				[a$2.Forwards]: () => {
					var i$15;
					v(s$19, T.First) === A.Error && ((i$15 = o$19.state.afterPanelSentinel.current) == null || i$15.focus());
				},
				[a$2.Backwards]: () => {
					var p$12;
					(p$12 = o$19.state.button) == null || p$12.focus({ preventScroll: !0 });
				}
			});
		}
		e$8();
	}), ae$4 = o(() => {
		let s$19 = c$20.current;
		if (!s$19) return;
		function e$8() {
			u$2(H$8.current, {
				[a$2.Forwards]: () => {
					var Be$3;
					if (!o$19.state.button) return;
					let p$12 = (Be$3 = r(o$19.state.button)) != null ? Be$3 : document.body, i$15 = x$2(p$12), x$9 = i$15.indexOf(o$19.state.button), S$9 = i$15.slice(0, x$9 + 1), se$2 = [...i$15.slice(x$9 + 1), ...S$9];
					for (let ve$2 of se$2.slice()) if (ve$2.dataset.headlessuiFocusGuard === "true" || L$6 != null && L$6.contains(ve$2)) {
						let Ae$6 = se$2.indexOf(ve$2);
						Ae$6 !== -1 && se$2.splice(Ae$6, 1);
					}
					v(se$2, T.First, { sorted: !1 });
				},
				[a$2.Backwards]: () => {
					var i$15;
					v(s$19, T.Previous) === A.Error && ((i$15 = o$19.state.button) == null || i$15.focus());
				}
			});
		}
		e$8();
	}), Pe$1 = K();
	return import_react.createElement(s$5, null, import_react.createElement(de.Provider, { value: B$3 }, import_react.createElement(C$1, { value: o$19.actions.refocusableClose }, import_react.createElement(te, {
		enabled: b$13 ? E$13.static || r$20 : !1,
		ownerDocument: Q$7
	}, r$20 && C$10 && import_react.createElement(f, {
		id: f$21,
		ref: a$27,
		features: s$3.Focusable,
		"data-headlessui-focus-guard": !0,
		as: "button",
		type: "button",
		onFocus: fe$6
	}), Pe$1({
		ourProps: I$9,
		theirProps: d$13,
		slot: k$13,
		defaultTag: Rt,
		features: Ft,
		visible: r$20,
		name: "Popover.Panel"
	}), r$20 && C$10 && import_react.createElement(f, {
		id: l$17,
		ref: u$24,
		features: s$3.Focusable,
		"data-headlessui-focus-guard": !0,
		as: "button",
		type: "button",
		onFocus: ae$4
	})))));
}
var At = "div";
function _t(E$13, O$4) {
	let R$6 = (0, import_react.useRef)(null), B$3 = y$1(R$6, O$4), [T$9, n$16] = (0, import_react.useState)([]), b$13 = o((a$27) => {
		n$16((u$24) => {
			let f$21 = u$24.indexOf(a$27);
			if (f$21 !== -1) {
				let l$17 = u$24.slice();
				return l$17.splice(f$21, 1), l$17;
			}
			return u$24;
		});
	}), t$12 = o((a$27) => (n$16((u$24) => [...u$24, a$27]), () => b$13(a$27))), A$4 = o(() => {
		var f$21;
		let a$27 = r(R$6.current);
		if (!a$27) return !1;
		let u$24 = e$1(R$6.current);
		return (f$21 = R$6.current) != null && f$21.contains(u$24) ? !0 : T$9.some((l$17) => {
			var c$20, m$9;
			return ((c$20 = a$27.getElementById(l$17.buttonId.current)) == null ? void 0 : c$20.contains(u$24)) || ((m$9 = a$27.getElementById(l$17.panelId.current)) == null ? void 0 : m$9.contains(u$24));
		});
	}), d$13 = o((a$27) => {
		for (let u$24 of T$9) u$24.buttonId.current !== a$27 && u$24.close();
	}), o$19 = (0, import_react.useMemo)(() => ({
		registerPopover: t$12,
		unregisterPopover: b$13,
		isFocusWithinPopoverGroup: A$4,
		closeOthers: d$13
	}), [
		t$12,
		b$13,
		A$4,
		d$13
	]), C$10 = n({}), y$9 = E$13, D$11 = { ref: B$3 }, _$10 = K();
	return import_react.createElement(j$1, null, import_react.createElement(Fe$4.Provider, { value: o$19 }, _$10({
		ourProps: D$11,
		theirProps: y$9,
		slot: C$10,
		defaultTag: At,
		name: "Popover.Group"
	})));
}
var Ct = Y(Tt), Dt = Y(bt), Ot = Y(Ne$2), xt$1 = Y(Ne$2), Lt$1 = Y(Bt$1), ht$1 = Y(_t), vo = Object.assign(Ct, {
	Button: Dt,
	Backdrop: xt$1,
	Overlay: Ot,
	Panel: Lt$1,
	Group: ht$1
});

//#endregion
//#region node_modules/@headlessui/react/dist/components/radio-group/radio-group.js
var Ie$1 = ((e$8) => (e$8[e$8.RegisterOption = 0] = "RegisterOption", e$8[e$8.UnregisterOption = 1] = "UnregisterOption", e$8))(Ie$1 || {});
var Fe$2 = {
	[0](o$19, t$12) {
		let e$8 = [...o$19.options, {
			id: t$12.id,
			element: t$12.element,
			propsRef: t$12.propsRef
		}];
		return {
			...o$19,
			options: G$2(e$8, (n$16) => n$16.element.current)
		};
	},
	[1](o$19, t$12) {
		let e$8 = o$19.options.slice(), n$16 = o$19.options.findIndex((P$7) => P$7.id === t$12.id);
		return n$16 === -1 ? o$19 : (e$8.splice(n$16, 1), {
			...o$19,
			options: e$8
		});
	}
}, X$1 = (0, import_react.createContext)(null);
X$1.displayName = "RadioGroupDataContext";
function z$1(o$19) {
	let t$12 = (0, import_react.useContext)(X$1);
	if (t$12 === null) {
		let e$8 = /* @__PURE__ */ new Error(`<${o$19} /> is missing a parent <RadioGroup /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(e$8, z$1), e$8;
	}
	return t$12;
}
var q$1 = (0, import_react.createContext)(null);
q$1.displayName = "RadioGroupActionsContext";
function Q$1(o$19) {
	let t$12 = (0, import_react.useContext)(q$1);
	if (t$12 === null) {
		let e$8 = /* @__PURE__ */ new Error(`<${o$19} /> is missing a parent <RadioGroup /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(e$8, Q$1), e$8;
	}
	return t$12;
}
function Ue$1(o$19, t$12) {
	return u$2(t$12.type, Fe$2, o$19, t$12);
}
var we$1 = "div";
function Se$1(o$19, t$12) {
	let e$8 = (0, import_react.useId)(), n$16 = a(), { id: P$7 = `headlessui-radiogroup-${e$8}`, value: R$6, form: D$11, name: i$15, onChange: c$20, by: d$13, disabled: a$27 = n$16 || !1, defaultValue: h$14, tabIndex: f$21 = 0,...L$6 } = o$19, T$9 = u$3(d$13), [v$10, y$9] = (0, import_react.useReducer)(Ue$1, { options: [] }), p$12 = v$10.options, [k$13, G$5] = V$2(), [I$9, F$6] = H$1(), E$13 = (0, import_react.useRef)(null), m$9 = y$1(E$13, t$12), b$13 = l(h$14), [s$19, x$9] = b$2(R$6, c$20, b$13), g$8 = (0, import_react.useMemo)(() => p$12.find((r$20) => !r$20.propsRef.current.disabled), [p$12]), O$4 = (0, import_react.useMemo)(() => p$12.some((r$20) => T$9(r$20.propsRef.current.value, s$19)), [p$12, s$19]), l$17 = o((r$20) => {
		var U$2;
		if (a$27 || T$9(r$20, s$19)) return !1;
		let S$9 = (U$2 = p$12.find((u$24) => T$9(u$24.propsRef.current.value, r$20))) == null ? void 0 : U$2.propsRef.current;
		return S$9 != null && S$9.disabled ? !1 : (x$9?.(r$20), !0);
	}), ce$2 = o((r$20) => {
		if (!E$13.current) return;
		let U$2 = p$12.filter((u$24) => u$24.propsRef.current.disabled === !1).map((u$24) => u$24.element.current);
		switch (r$20.key) {
			case o$1.Enter:
				g(r$20.currentTarget);
				break;
			case o$1.ArrowLeft:
			case o$1.ArrowUp:
				if (r$20.preventDefault(), r$20.stopPropagation(), v(U$2, T.Previous | T.WrapAround) === A.Success) {
					let A$4 = p$12.find((N$3) => d$1(N$3.element.current));
					A$4 && l$17(A$4.propsRef.current.value);
				}
				break;
			case o$1.ArrowRight:
			case o$1.ArrowDown:
				if (r$20.preventDefault(), r$20.stopPropagation(), v(U$2, T.Next | T.WrapAround) === A.Success) {
					let A$4 = p$12.find((N$3) => d$1(N$3.element.current));
					A$4 && l$17(A$4.propsRef.current.value);
				}
				break;
			case o$1.Space:
				{
					r$20.preventDefault(), r$20.stopPropagation();
					let u$24 = p$12.find((A$4) => d$1(A$4.element.current));
					u$24 && l$17(u$24.propsRef.current.value);
				}
				break;
		}
	}), Y$4 = o((r$20) => (y$9({
		type: 0,
		...r$20
	}), () => y$9({
		type: 1,
		id: r$20.id
	}))), fe$6 = (0, import_react.useMemo)(() => ({
		value: s$19,
		firstOption: g$8,
		containsCheckedOption: O$4,
		disabled: a$27,
		compare: T$9,
		tabIndex: f$21,
		...v$10
	}), [
		s$19,
		g$8,
		O$4,
		a$27,
		T$9,
		f$21,
		v$10
	]), Te$4 = (0, import_react.useMemo)(() => ({
		registerOption: Y$4,
		change: l$17
	}), [Y$4, l$17]), me$4 = {
		ref: m$9,
		id: P$7,
		role: "radiogroup",
		"aria-labelledby": k$13,
		"aria-describedby": I$9,
		onKeyDown: ce$2
	}, Re$3 = n({ value: s$19 }), ye$3 = (0, import_react.useCallback)(() => {
		if (b$13 !== void 0) return l$17(b$13);
	}, [l$17, b$13]), be$2 = K();
	return import_react.createElement(F$6, { name: "RadioGroup.Description" }, import_react.createElement(G$5, { name: "RadioGroup.Label" }, import_react.createElement(q$1.Provider, { value: Te$4 }, import_react.createElement(X$1.Provider, { value: fe$6 }, i$15 != null && import_react.createElement(j, {
		disabled: a$27,
		data: { [i$15]: s$19 || "on" },
		overrides: {
			type: "radio",
			checked: s$19 != null
		},
		form: D$11,
		onReset: ye$3
	}), be$2({
		ourProps: me$4,
		theirProps: L$6,
		slot: Re$3,
		defaultTag: we$1,
		name: "RadioGroup"
	})))));
}
var Me$1 = "div";
function He$1(o$19, t$12) {
	var g$8;
	let e$8 = z$1("RadioGroup.Option"), n$16 = Q$1("RadioGroup.Option"), P$7 = (0, import_react.useId)(), { id: R$6 = `headlessui-radiogroup-option-${P$7}`, value: D$11, disabled: i$15 = e$8.disabled || !1, autoFocus: c$20 = !1,...d$13 } = o$19, a$27 = (0, import_react.useRef)(null), h$14 = y$1(a$27, t$12), [f$21, L$6] = V$2(), [T$9, v$10] = H$1(), y$9 = s({
		value: D$11,
		disabled: i$15
	});
	n$1(() => n$16.registerOption({
		id: R$6,
		element: a$27,
		propsRef: y$9
	}), [
		R$6,
		n$16,
		a$27,
		y$9
	]);
	let p$12 = o((O$4) => {
		var l$17;
		if (s$4(O$4.currentTarget)) return O$4.preventDefault();
		n$16.change(D$11) && ((l$17 = a$27.current) == null || l$17.focus());
	}), k$13 = ((g$8 = e$8.firstOption) == null ? void 0 : g$8.id) === R$6, { isFocusVisible: G$5, focusProps: I$9 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: c$20 }), { isHovered: F$6, hoverProps: E$13 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: i$15 }), m$9 = e$8.compare(e$8.value, D$11), b$13 = V({
		ref: h$14,
		id: R$6,
		role: "radio",
		"aria-checked": m$9 ? "true" : "false",
		"aria-labelledby": f$21,
		"aria-describedby": T$9,
		"aria-disabled": i$15 ? !0 : void 0,
		tabIndex: (() => i$15 ? -1 : m$9 || !e$8.containsCheckedOption && k$13 ? e$8.tabIndex : -1)(),
		onClick: i$15 ? void 0 : p$12,
		autoFocus: c$20
	}, I$9, E$13), s$19 = n({
		checked: m$9,
		disabled: i$15,
		active: G$5,
		hover: F$6,
		focus: G$5,
		autofocus: c$20
	}), x$9 = K();
	return import_react.createElement(v$10, { name: "RadioGroup.Description" }, import_react.createElement(L$6, { name: "RadioGroup.Label" }, x$9({
		ourProps: b$13,
		theirProps: d$13,
		slot: s$19,
		defaultTag: Me$1,
		name: "RadioGroup.Option"
	})));
}
var Ne$1 = "span";
function We$1(o$19, t$12) {
	var g$8;
	let e$8 = z$1("Radio"), n$16 = Q$1("Radio"), P$7 = (0, import_react.useId)(), R$6 = u$1(), D$11 = a(), { id: i$15 = R$6 || `headlessui-radio-${P$7}`, value: c$20, disabled: d$13 = e$8.disabled || D$11 || !1, autoFocus: a$27 = !1,...h$14 } = o$19, f$21 = (0, import_react.useRef)(null), L$6 = y$1(f$21, t$12), T$9 = N(), v$10 = w(), y$9 = s({
		value: c$20,
		disabled: d$13
	});
	n$1(() => n$16.registerOption({
		id: i$15,
		element: f$21,
		propsRef: y$9
	}), [
		i$15,
		n$16,
		f$21,
		y$9
	]);
	let p$12 = o((O$4) => {
		var l$17;
		if (s$4(O$4.currentTarget)) return O$4.preventDefault();
		n$16.change(c$20) && ((l$17 = f$21.current) == null || l$17.focus());
	}), { isFocusVisible: k$13, focusProps: G$5 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: a$27 }), { isHovered: I$9, hoverProps: F$6 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: d$13 }), E$13 = ((g$8 = e$8.firstOption) == null ? void 0 : g$8.id) === i$15, m$9 = e$8.compare(e$8.value, c$20), b$13 = V({
		ref: L$6,
		id: i$15,
		role: "radio",
		"aria-checked": m$9 ? "true" : "false",
		"aria-labelledby": T$9,
		"aria-describedby": v$10,
		"aria-disabled": d$13 ? !0 : void 0,
		tabIndex: (() => d$13 ? -1 : m$9 || !e$8.containsCheckedOption && E$13 ? e$8.tabIndex : -1)(),
		autoFocus: a$27,
		onClick: d$13 ? void 0 : p$12
	}, G$5, F$6), s$19 = n({
		checked: m$9,
		disabled: d$13,
		hover: I$9,
		focus: k$13,
		autofocus: a$27
	});
	return K()({
		ourProps: b$13,
		theirProps: h$14,
		slot: s$19,
		defaultTag: Ne$1,
		name: "Radio"
	});
}
var Be$1 = Y(Se$1), Ve = Y(He$1), Ke$1 = Y(We$1), $e = Z, je = M, yt$1 = Object.assign(Be$1, {
	Option: Ve,
	Radio: Ke$1,
	Label: $e,
	Description: je
});

//#endregion
//#region node_modules/@headlessui/react/dist/components/select/select.js
var H$2 = "select";
function B(r$20, l$17) {
	let s$19 = (0, import_react.useId)(), a$27 = u$1(), i$15 = a(), { id: p$12 = a$27 || `headlessui-select-${s$19}`, disabled: e$8 = i$15 || !1, invalid: t$12 = !1, autoFocus: o$19 = !1,...d$13 } = r$20, n$16 = N(), c$20 = w(), { isFocusVisible: m$9, focusProps: f$21 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: o$19 }), { isHovered: u$24, hoverProps: T$9 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e$8 }), { pressed: b$13, pressProps: y$9 } = w$1({ disabled: e$8 }), P$7 = V({
		ref: l$17,
		id: p$12,
		"aria-labelledby": n$16,
		"aria-describedby": c$20,
		"aria-invalid": t$12 ? "true" : void 0,
		disabled: e$8 || void 0,
		autoFocus: o$19
	}, f$21, T$9, y$9), S$9 = n({
		disabled: e$8,
		invalid: t$12,
		hover: u$24,
		focus: m$9,
		active: b$13,
		autofocus: o$19
	});
	return K()({
		ourProps: P$7,
		theirProps: d$13,
		slot: S$9,
		defaultTag: H$2,
		name: "Select"
	});
}
var k = Y(B);

//#endregion
//#region node_modules/@headlessui/react/dist/components/switch/switch.js
var E$1 = (0, import_react.createContext)(null);
E$1.displayName = "GroupContext";
var ve$1 = import_react.Fragment;
function xe$1(n$16) {
	var c$20;
	let [t$12, a$27] = (0, import_react.useState)(null), [f$21, h$14] = V$2(), [b$13, o$19] = H$1(), s$19 = (0, import_react.useMemo)(() => ({
		switch: t$12,
		setSwitch: a$27
	}), [t$12, a$27]), T$9 = {}, y$9 = n$16, p$12 = K();
	return import_react.createElement(o$19, {
		name: "Switch.Description",
		value: b$13
	}, import_react.createElement(h$14, {
		name: "Switch.Label",
		value: f$21,
		props: {
			htmlFor: (c$20 = s$19.switch) == null ? void 0 : c$20.id,
			onClick(u$24) {
				t$12 && (m$6(u$24.currentTarget) && u$24.preventDefault(), t$12.click(), t$12.focus({ preventScroll: !0 }));
			}
		}
	}, import_react.createElement(E$1.Provider, { value: s$19 }, p$12({
		ourProps: T$9,
		theirProps: y$9,
		slot: {},
		defaultTag: ve$1,
		name: "Switch.Group"
	}))));
}
var Ce$1 = "button";
function Le$2(n$16, t$12) {
	var g$8;
	let a$27 = (0, import_react.useId)(), f$21 = u$1(), h$14 = a(), { id: b$13 = f$21 || `headlessui-switch-${a$27}`, disabled: o$19 = h$14 || !1, checked: s$19, defaultChecked: T$9, onChange: y$9, name: p$12, value: c$20, form: u$24, autoFocus: S$9 = !1,...C$10 } = n$16, _$10 = (0, import_react.useContext)(E$1), [L$6, R$6] = (0, import_react.useState)(null), G$5 = (0, import_react.useRef)(null), A$4 = y$1(G$5, t$12, _$10 === null ? null : _$10.setSwitch, R$6), l$17 = l(T$9), [d$13, r$20] = b$2(s$19, y$9, l$17 != null ? l$17 : !1), F$6 = p(), [H$8, P$7] = (0, import_react.useState)(!1), D$11 = o(() => {
		P$7(!0), r$20?.(!d$13), F$6.nextFrame(() => {
			P$7(!1);
		});
	}), k$13 = o((e$8) => {
		if (s$4(e$8.currentTarget)) return e$8.preventDefault();
		e$8.preventDefault(), D$11();
	}), M$11 = o((e$8) => {
		e$8.key === o$1.Space ? (e$8.preventDefault(), D$11()) : e$8.key === o$1.Enter && g(e$8.currentTarget);
	}), U$2 = o((e$8) => e$8.preventDefault()), I$9 = N(), B$3 = w(), { isFocusVisible: K$3, focusProps: O$4 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: S$9 }), { isHovered: W$4, hoverProps: N$3 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: o$19 }), { pressed: J$3, pressProps: V$5 } = w$1({ disabled: o$19 }), X$4 = n({
		checked: d$13,
		disabled: o$19,
		hover: W$4,
		focus: K$3,
		active: J$3,
		autofocus: S$9,
		changing: H$8
	}), j$9 = V({
		id: b$13,
		ref: A$4,
		role: "switch",
		type: e(n$16, L$6),
		tabIndex: n$16.tabIndex === -1 ? 0 : (g$8 = n$16.tabIndex) != null ? g$8 : 0,
		"aria-checked": d$13,
		"aria-labelledby": I$9,
		"aria-describedby": B$3,
		disabled: o$19 || void 0,
		autoFocus: S$9,
		onClick: k$13,
		onKeyUp: M$11,
		onKeyPress: U$2
	}, O$4, N$3, V$5), $$5 = (0, import_react.useCallback)(() => {
		if (l$17 !== void 0) return r$20 == null ? void 0 : r$20(l$17);
	}, [r$20, l$17]), q$4 = K();
	return import_react.createElement(import_react.Fragment, null, p$12 != null && import_react.createElement(j, {
		disabled: o$19,
		data: { [p$12]: c$20 || "on" },
		overrides: {
			type: "checkbox",
			checked: d$13
		},
		form: u$24,
		onReset: $$5
	}), q$4({
		ourProps: j$9,
		theirProps: C$10,
		slot: X$4,
		defaultTag: Ce$1,
		name: "Switch"
	}));
}
var Re = Y(Le$2), Ge = xe$1, Ae = Z, Fe = M, tt = Object.assign(Re, {
	Group: Ge,
	Label: Ae,
	Description: Fe
});

//#endregion
//#region node_modules/@headlessui/react/dist/internal/focus-sentinel.js
function b$1({ onFocus: n$16 }) {
	let [r$20, o$19] = (0, import_react.useState)(!0), u$24 = f$2();
	return r$20 ? import_react.createElement(f, {
		as: "button",
		type: "button",
		features: s$3.Focusable,
		onFocus: (a$27) => {
			a$27.preventDefault();
			let e$8, i$15 = 50;
			function t$12() {
				if (i$15-- <= 0) {
					e$8 && cancelAnimationFrame(e$8);
					return;
				}
				if (n$16()) {
					if (cancelAnimationFrame(e$8), !u$24.current) return;
					o$19(!1);
					return;
				}
				e$8 = requestAnimationFrame(t$12);
			}
			e$8 = requestAnimationFrame(t$12);
		}
	}) : null;
}

//#endregion
//#region node_modules/@headlessui/react/dist/utils/stable-collection.js
var s$1 = import_react.createContext(null);
function a$1() {
	return {
		groups: /* @__PURE__ */ new Map(),
		get(o$19, e$8) {
			var i$15;
			let t$12 = this.groups.get(o$19);
			t$12 || (t$12 = /* @__PURE__ */ new Map(), this.groups.set(o$19, t$12));
			let n$16 = (i$15 = t$12.get(e$8)) != null ? i$15 : 0;
			t$12.set(e$8, n$16 + 1);
			let r$20 = Array.from(t$12.keys()).indexOf(e$8);
			function u$24() {
				let c$20 = t$12.get(e$8);
				c$20 > 1 ? t$12.set(e$8, c$20 - 1) : t$12.delete(e$8);
			}
			return [r$20, u$24];
		}
	};
}
function f$1({ children: o$19 }) {
	let e$8 = import_react.useRef(a$1());
	return import_react.createElement(s$1.Provider, { value: e$8 }, o$19);
}
function C(o$19) {
	let e$8 = import_react.useContext(s$1);
	if (!e$8) throw new Error("You must wrap your component in a <StableCollection>");
	let t$12 = import_react.useId(), [n$16, r$20] = e$8.current.get(o$19, t$12);
	return import_react.useEffect(() => r$20, []), n$16;
}

//#endregion
//#region node_modules/@headlessui/react/dist/components/tabs/tabs.js
var Le$1 = ((t$12) => (t$12[t$12.Forwards = 0] = "Forwards", t$12[t$12.Backwards = 1] = "Backwards", t$12))(Le$1 || {}), _e = ((l$17) => (l$17[l$17.Less = -1] = "Less", l$17[l$17.Equal = 0] = "Equal", l$17[l$17.Greater = 1] = "Greater", l$17))(_e || {}), Se = ((n$16) => (n$16[n$16.SetSelectedIndex = 0] = "SetSelectedIndex", n$16[n$16.RegisterTab = 1] = "RegisterTab", n$16[n$16.UnregisterTab = 2] = "UnregisterTab", n$16[n$16.RegisterPanel = 3] = "RegisterPanel", n$16[n$16.UnregisterPanel = 4] = "UnregisterPanel", n$16))(Se || {});
var De = {
	[0](e$8, r$20) {
		var d$13;
		let t$12 = G$2(e$8.tabs, (u$24) => u$24.current), l$17 = G$2(e$8.panels, (u$24) => u$24.current), a$27 = t$12.filter((u$24) => {
			var T$9;
			return !((T$9 = u$24.current) != null && T$9.hasAttribute("disabled"));
		}), n$16 = {
			...e$8,
			tabs: t$12,
			panels: l$17
		};
		if (r$20.index < 0 || r$20.index > t$12.length - 1) {
			let u$24 = u$2(Math.sign(r$20.index - e$8.selectedIndex), {
				[-1]: () => 1,
				[0]: () => u$2(Math.sign(r$20.index), {
					[-1]: () => 0,
					[0]: () => 0,
					[1]: () => 1
				}),
				[1]: () => 0
			});
			if (a$27.length === 0) return n$16;
			let T$9 = u$2(u$24, {
				[0]: () => t$12.indexOf(a$27[0]),
				[1]: () => t$12.indexOf(a$27[a$27.length - 1])
			});
			return {
				...n$16,
				selectedIndex: T$9 === -1 ? e$8.selectedIndex : T$9
			};
		}
		let s$19 = t$12.slice(0, r$20.index), f$21 = [...t$12.slice(r$20.index), ...s$19].find((u$24) => a$27.includes(u$24));
		if (!f$21) return n$16;
		let b$13 = (d$13 = t$12.indexOf(f$21)) != null ? d$13 : e$8.selectedIndex;
		return b$13 === -1 && (b$13 = e$8.selectedIndex), {
			...n$16,
			selectedIndex: b$13
		};
	},
	[1](e$8, r$20) {
		if (e$8.tabs.includes(r$20.tab)) return e$8;
		let t$12 = e$8.tabs[e$8.selectedIndex], l$17 = G$2([...e$8.tabs, r$20.tab], (n$16) => n$16.current), a$27 = e$8.selectedIndex;
		return e$8.info.current.isControlled || (a$27 = l$17.indexOf(t$12), a$27 === -1 && (a$27 = e$8.selectedIndex)), {
			...e$8,
			tabs: l$17,
			selectedIndex: a$27
		};
	},
	[2](e$8, r$20) {
		return {
			...e$8,
			tabs: e$8.tabs.filter((t$12) => t$12 !== r$20.tab)
		};
	},
	[3](e$8, r$20) {
		return e$8.panels.includes(r$20.panel) ? e$8 : {
			...e$8,
			panels: G$2([...e$8.panels, r$20.panel], (t$12) => t$12.current)
		};
	},
	[4](e$8, r$20) {
		return {
			...e$8,
			panels: e$8.panels.filter((t$12) => t$12 !== r$20.panel)
		};
	}
}, z = (0, import_react.createContext)(null);
z.displayName = "TabsDataContext";
function h(e$8) {
	let r$20 = (0, import_react.useContext)(z);
	if (r$20 === null) {
		let t$12 = /* @__PURE__ */ new Error(`<${e$8} /> is missing a parent <Tab.Group /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(t$12, h), t$12;
	}
	return r$20;
}
var V$1 = (0, import_react.createContext)(null);
V$1.displayName = "TabsActionsContext";
function Q(e$8) {
	let r$20 = (0, import_react.useContext)(V$1);
	if (r$20 === null) {
		let t$12 = /* @__PURE__ */ new Error(`<${e$8} /> is missing a parent <Tab.Group /> component.`);
		throw Error.captureStackTrace && Error.captureStackTrace(t$12, Q), t$12;
	}
	return r$20;
}
function Fe$1(e$8, r$20) {
	return u$2(r$20.type, De, e$8, r$20);
}
var Ie = "div";
function he(e$8, r$20) {
	let { defaultIndex: t$12 = 0, vertical: l$17 = !1, manual: a$27 = !1, onChange: n$16, selectedIndex: s$19 = null,...g$8 } = e$8;
	const f$21 = l$17 ? "vertical" : "horizontal", b$13 = a$27 ? "manual" : "auto";
	let d$13 = s$19 !== null, u$24 = s({ isControlled: d$13 }), T$9 = y$1(r$20), [p$12, c$20] = (0, import_react.useReducer)(Fe$1, {
		info: u$24,
		selectedIndex: s$19 != null ? s$19 : t$12,
		tabs: [],
		panels: []
	}), v$10 = n({ selectedIndex: p$12.selectedIndex }), m$9 = s(n$16 || (() => {})), C$10 = s(p$12.tabs), D$11 = (0, import_react.useMemo)(() => ({
		orientation: f$21,
		activation: b$13,
		...p$12
	}), [
		f$21,
		b$13,
		p$12
	]), P$7 = o((i$15) => (c$20({
		type: 1,
		tab: i$15
	}), () => c$20({
		type: 2,
		tab: i$15
	}))), R$6 = o((i$15) => (c$20({
		type: 3,
		panel: i$15
	}), () => c$20({
		type: 4,
		panel: i$15
	}))), A$4 = o((i$15) => {
		L$6.current !== i$15 && m$9.current(i$15), d$13 || c$20({
			type: 0,
			index: i$15
		});
	}), L$6 = s(d$13 ? e$8.selectedIndex : p$12.selectedIndex), _$10 = (0, import_react.useMemo)(() => ({
		registerTab: P$7,
		registerPanel: R$6,
		change: A$4
	}), []);
	n$1(() => {
		c$20({
			type: 0,
			index: s$19 != null ? s$19 : t$12
		});
	}, [s$19]), n$1(() => {
		if (L$6.current === void 0 || p$12.tabs.length <= 0) return;
		let i$15 = G$2(p$12.tabs, (S$9) => S$9.current);
		i$15.some((S$9, $$5) => p$12.tabs[$$5] !== S$9) && A$4(i$15.indexOf(p$12.tabs[L$6.current]));
	});
	let J$3 = { ref: T$9 }, X$4 = K();
	return import_react.createElement(f$1, null, import_react.createElement(V$1.Provider, { value: _$10 }, import_react.createElement(z.Provider, { value: D$11 }, D$11.tabs.length <= 0 && import_react.createElement(b$1, { onFocus: () => {
		var i$15, M$11;
		for (let S$9 of C$10.current) if (((i$15 = S$9.current) == null ? void 0 : i$15.tabIndex) === 0) return (M$11 = S$9.current) == null || M$11.focus(), !0;
		return !1;
	} }), X$4({
		ourProps: J$3,
		theirProps: g$8,
		slot: v$10,
		defaultTag: Ie,
		name: "Tabs"
	}))));
}
var ve = "div";
function Ce(e$8, r$20) {
	let { orientation: t$12, selectedIndex: l$17 } = h("Tab.List"), a$27 = y$1(r$20), n$16 = n({ selectedIndex: l$17 }), s$19 = e$8, g$8 = {
		ref: a$27,
		role: "tablist",
		"aria-orientation": t$12
	};
	return K()({
		ourProps: g$8,
		theirProps: s$19,
		slot: n$16,
		defaultTag: ve,
		name: "Tabs.List"
	});
}
var Me = "button";
function Ge$1(e$8, r$20) {
	var Y$4, Z$3;
	let t$12 = (0, import_react.useId)(), { id: l$17 = `headlessui-tabs-tab-${t$12}`, disabled: a$27 = !1, autoFocus: n$16 = !1,...s$19 } = e$8, { orientation: g$8, activation: f$21, selectedIndex: b$13, tabs: d$13, panels: u$24 } = h("Tab"), T$9 = Q("Tab"), p$12 = h("Tab"), [c$20, v$10] = (0, import_react.useState)(null), m$9 = (0, import_react.useRef)(null), C$10 = y$1(m$9, r$20, v$10);
	n$1(() => T$9.registerTab(m$9), [T$9, m$9]);
	let D$11 = C("tabs"), P$7 = d$13.indexOf(m$9);
	P$7 === -1 && (P$7 = D$11);
	let R$6 = P$7 === b$13, A$4 = o((o$19) => {
		let E$13 = o$19();
		if (E$13 === A.Success && f$21 === "auto") {
			let ee$6 = e$1(m$9.current), B$3 = p$12.tabs.findIndex((ce$2) => ce$2.current === ee$6);
			B$3 !== -1 && T$9.change(B$3);
		}
		return E$13;
	}), L$6 = o((o$19) => {
		let E$13 = d$13.map((B$3) => B$3.current).filter(Boolean);
		if (o$19.key === o$1.Space || o$19.key === o$1.Enter) {
			o$19.preventDefault(), o$19.stopPropagation(), T$9.change(P$7);
			return;
		}
		switch (o$19.key) {
			case o$1.Home:
			case o$1.PageUp: return o$19.preventDefault(), o$19.stopPropagation(), A$4(() => v(E$13, T.First));
			case o$1.End:
			case o$1.PageDown: return o$19.preventDefault(), o$19.stopPropagation(), A$4(() => v(E$13, T.Last));
		}
		if (A$4(() => u$2(g$8, {
			vertical() {
				return o$19.key === o$1.ArrowUp ? v(E$13, T.Previous | T.WrapAround) : o$19.key === o$1.ArrowDown ? v(E$13, T.Next | T.WrapAround) : A.Error;
			},
			horizontal() {
				return o$19.key === o$1.ArrowLeft ? v(E$13, T.Previous | T.WrapAround) : o$19.key === o$1.ArrowRight ? v(E$13, T.Next | T.WrapAround) : A.Error;
			}
		})) === A.Success) return o$19.preventDefault();
	}), _$10 = (0, import_react.useRef)(!1), J$3 = o(() => {
		var o$19;
		_$10.current || (_$10.current = !0, (o$19 = m$9.current) == null || o$19.focus({ preventScroll: !0 }), T$9.change(P$7), t(() => {
			_$10.current = !1;
		}));
	}), X$4 = o((o$19) => {
		o$19.preventDefault();
	}), { isFocusVisible: i$15, focusProps: M$11 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: n$16 }), { isHovered: S$9, hoverProps: $$5 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: a$27 }), { pressed: pe$3, pressProps: ue$4 } = w$1({ disabled: a$27 }), Te$4 = n({
		selected: R$6,
		hover: S$9,
		active: pe$3,
		focus: i$15,
		autofocus: n$16,
		disabled: a$27
	}), de$5 = V({
		ref: C$10,
		onKeyDown: L$6,
		onMouseDown: X$4,
		onClick: J$3,
		id: l$17,
		role: "tab",
		type: e(e$8, c$20),
		"aria-controls": (Z$3 = (Y$4 = u$24[P$7]) == null ? void 0 : Y$4.current) == null ? void 0 : Z$3.id,
		"aria-selected": R$6,
		tabIndex: R$6 ? 0 : -1,
		disabled: a$27 || void 0,
		autoFocus: n$16
	}, M$11, $$5, ue$4);
	return K()({
		ourProps: de$5,
		theirProps: s$19,
		slot: Te$4,
		defaultTag: Me,
		name: "Tabs.Tab"
	});
}
var Ue = "div";
function He(e$8, r$20) {
	let { selectedIndex: t$12 } = h("Tab.Panels"), l$17 = y$1(r$20), a$27 = n({ selectedIndex: t$12 }), n$16 = e$8, s$19 = { ref: l$17 };
	return K()({
		ourProps: s$19,
		theirProps: n$16,
		slot: a$27,
		defaultTag: Ue,
		name: "Tabs.Panels"
	});
}
var we = "div", Oe$1 = A$1.RenderStrategy | A$1.Static;
function Ne(e$8, r$20) {
	var R$6, A$4, L$6, _$10;
	let t$12 = (0, import_react.useId)(), { id: l$17 = `headlessui-tabs-panel-${t$12}`, tabIndex: a$27 = 0,...n$16 } = e$8, { selectedIndex: s$19, tabs: g$8, panels: f$21 } = h("Tab.Panel"), b$13 = Q("Tab.Panel"), d$13 = (0, import_react.useRef)(null), u$24 = y$1(d$13, r$20);
	n$1(() => b$13.registerPanel(d$13), [b$13, d$13]);
	let T$9 = C("panels"), p$12 = f$21.indexOf(d$13);
	p$12 === -1 && (p$12 = T$9);
	let c$20 = p$12 === s$19, { isFocusVisible: v$10, focusProps: m$9 } = $f7dceffc5ad7768b$export$4e328f61c538687f(), C$10 = n({
		selected: c$20,
		focus: v$10
	}), D$11 = V({
		ref: u$24,
		id: l$17,
		role: "tabpanel",
		"aria-labelledby": (A$4 = (R$6 = g$8[p$12]) == null ? void 0 : R$6.current) == null ? void 0 : A$4.id,
		tabIndex: c$20 ? a$27 : -1
	}, m$9), P$7 = K();
	return !c$20 && ((L$6 = n$16.unmount) == null || L$6) && !((_$10 = n$16.static) != null && _$10) ? import_react.createElement(f, {
		"aria-hidden": "true",
		...D$11
	}) : P$7({
		ourProps: D$11,
		theirProps: n$16,
		slot: C$10,
		defaultTag: we,
		features: Oe$1,
		visible: c$20,
		name: "Tabs.Panel"
	});
}
var ke = Y(Ge$1), Be = Y(he), We = Y(Ce), je$1 = Y(He), Ke$2 = Y(Ne), dt = Object.assign(ke, {
	Group: Be,
	List: We,
	Panels: je$1,
	Panel: Ke$2
});

//#endregion
//#region node_modules/@headlessui/react/dist/components/textarea/textarea.js
var L$1 = "textarea";
function H(a$27, t$12) {
	let s$19 = (0, import_react.useId)(), l$17 = u$1(), d$13 = a(), { id: i$15 = l$17 || `headlessui-textarea-${s$19}`, disabled: e$8 = d$13 || !1, autoFocus: r$20 = !1, invalid: o$19 = !1,...p$12 } = a$27, n$16 = N(), T$9 = w(), { isFocused: f$21, focusProps: m$9 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: r$20 }), { isHovered: u$24, hoverProps: b$13 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e$8 }), y$9 = V({
		ref: t$12,
		id: i$15,
		"aria-labelledby": n$16,
		"aria-describedby": T$9,
		"aria-invalid": o$19 ? "true" : void 0,
		disabled: e$8 || void 0,
		autoFocus: r$20
	}, m$9, b$13), x$9 = n({
		disabled: e$8,
		invalid: o$19,
		hover: u$24,
		focus: f$21,
		autofocus: r$20
	});
	return K()({
		ourProps: y$9,
		theirProps: p$12,
		slot: x$9,
		defaultTag: L$1,
		name: "Textarea"
	});
}
var M$1 = Y(H);

//#endregion
export { L as Button, Ke as Checkbox, y as CloseButton, Ht as Combobox, Bo as ComboboxButton, ko as ComboboxInput, No as ComboboxLabel, Ho as ComboboxOption, Uo as ComboboxOptions, b as DataInteractive, M as Description, ht as Dialog, Lt as DialogBackdrop, xt as DialogDescription, ze as DialogPanel, Qe as DialogTitle, Xe as Disclosure, xe as DisclosureButton, Le as DisclosurePanel, W as Field, I as Fieldset, ge as FocusTrap, G as FocusTrapFeatures, X as Input, Z as Label, d as Legend, Mo as Listbox, Mt as ListboxButton, wt as ListboxLabel, It as ListboxOption, Bt as ListboxOptions, kt as ListboxSelectedOption, lo as Menu, ft as MenuButton, Et as MenuHeading, gt as MenuItem, yt as MenuItems, Pt as MenuSection, Mt$1 as MenuSeparator, vo as Popover, xt$1 as PopoverBackdrop, Dt as PopoverButton, ht$1 as PopoverGroup, Ot as PopoverOverlay, Lt$1 as PopoverPanel, te as Portal, Ke$1 as Radio, yt$1 as RadioGroup, je as RadioGroupDescription, $e as RadioGroupLabel, Ve as RadioGroupOption, k as Select, tt as Switch, Fe as SwitchDescription, Ge as SwitchGroup, Ae as SwitchLabel, dt as Tab, Be as TabGroup, We as TabList, Ke$2 as TabPanel, je$1 as TabPanels, M$1 as Textarea, Ke$3 as Transition, Oe as TransitionChild, u as useClose };
//# sourceMappingURL=@headlessui_react.js.map